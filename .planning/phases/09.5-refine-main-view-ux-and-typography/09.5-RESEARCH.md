# Phase 09.5: Refine Main View UX and Typography - Research

**Researched:** 2026-02-22
**Domain:** Frontend layout restructure, content rendering, UX polish
**Confidence:** HIGH

## Summary

This phase is a significant UI restructure covering six areas: (1) layout shell changes (remove header, restructure sidebar), (2) article row redesign (summary preview, context menu, read/unread distinction), (3) toolbar/controls bar overhaul (filter dropdown, sticky scroll-collapse), (4) reader layout swap (inline view replacing drawer), (5) content rendering pipeline (html-react-parser + DOMPurify replacing dangerouslySetInnerHTML), and (6) backend additions (summary/score_reasoning in list endpoint, per-article rescore endpoint, mark-all-read across all feeds).

The project already uses Chakra UI v3, TanStack Query, and Next.js App Router. No new paradigms are needed. The content rendering change is the only new library addition (html-react-parser + isomorphic-dompurify). All other changes are restructuring existing components and patterns.

**Primary recommendation:** Break into 8-10 plans ordered by dependency: backend data layer first, then layout shell, then article row redesign, then toolbar, then reader swap (depends on layout), then content rendering, then keyboard shortcuts/polish.

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

**Article Row Design:**
- 2-line summary/preview below the title, muted + smaller font size (sm)
- Summary source: use RSS `summary` field for unscored articles; replace with `score_reasoning` once scored
- Subtle brain/sparkle icon prefix on score reasoning text to signal AI-generated content
- Feed source: plain text name only, shown only when viewing mixed feeds (already implemented)
- Category tags stay inline with metadata (feed name + date), not on their own line
- Read/unread state: combine typography weight shift (semibold unread, regular read) + subtle background tint for unread
- Read articles: remove the dot entirely (not hollow dot), collapse the space (no alignment placeholder)
- Unread articles: keep filled accent dot, clickable to toggle
- Mark-unread for read articles: hover-reveal context menu on the far right of the row (reuse categories settings pattern)
- Context menu items: Mark unread, Open original, Rescore
- Remove high-score row background tint (`accent.subtle`) -- score badge alone signals high scores
- Keep current scoring state indicators (Queued, Categorizing, Scoring, etc.) as-is

**Layout Restructure:**
- Remove the top header bar (`Header.tsx`) entirely
- Sidebar absorbs: logo/branding at top, settings icon + theme toggle pinned at bottom
- Collapsed sidebar shows icon-only layout: logo icon at top, feed icons/initials in middle, settings + theme icons at bottom (like VS Code/Slack)
- "Feeds" heading with + icon for add feed stays as current pattern
- Main content area: feed name heading at top, controls bar below, then article list
- Feed name heading shows "Articles" when All Articles selected, specific feed name when a feed is selected
- Mobile: hamburger icon in main content area (top-left next to feed name) opens mobile sidebar drawer

**Toolbar / Controls Bar:**
- Filter becomes a dropdown (not individual buttons) -- shows count on active filter label and all dropdown options
- Filter options: Unread, All, Scoring, Blocked -- each with count
- Sort stays as dropdown (current SortSelect pattern)
- Mark all read as icon button -- always visible (not conditional), works on all views including All Articles (with confirmation prompt for All)
- Scroll behavior: on scroll, controls bar becomes sticky and feed name collapses to small inline text on the same row as controls (Inoreader-style collapse)

**Reader Layout & Navigation:**
- Reader replaces the article list in the main content area (not a drawer overlay) -- full viewport height
- Sidebar remains visible as normal
- State-based navigation (same URL, component swap) -- not route-based
- Sticky reader header: article title (truncated) + Open original icon + Up/Down arrows (prev/next) + X close icon
- Escape key closes the reader (back to list)
- J/K keyboard shortcuts for prev/next article
- Below sticky header: metadata (feed, date, author) -> category tags -> score + reasoning -> content
- Content max-width increased to ~800px (from 680px)
- Typography: refine spacing/sizing within existing Lora (reader) + Inter (UI) font pairing

**Content Rendering:**
- Replace `dangerouslySetInnerHTML` with `html-react-parser`
- Add DOMPurify sanitization before parsing (belt and suspenders)
- Element replacements: images (responsive/lazy-loaded), code blocks (styled), links (external in new tab with proper rel)
- Images stay constrained (no lightbox), click opens image URL in new tab
- Move reader content CSS styles to theme-level textStyle (single source of truth)

**Component Architecture:**
- Keep article selection state in the article domain component (not AppShell)
- Rename `ArticleList` to `ArticleFeed` or `ArticleView` -- reflects dual role as list/reader container
- Conditional rendering: `selectedArticle === null` shows list, `selectedArticle !== null` shows reader
- Data layer stays mounted regardless of view (article query persists for prev/next navigation)

**Data Layer:**
- Add `summary` and `score_reasoning` to article list endpoint response (backend change)
- Keep on-demand fetch for full article content (separate query when reader opens)
- New single-article rescore endpoint: `POST /api/articles/{id}/rescore`
- Per-article rescore triggered from context menu, uses new endpoint

### Claude's Discretion
- Exact scroll-collapse animation/transition timing
- Sidebar collapsed icon choices (feed initials vs generic icon)
- Spacing/sizing refinements for reader typography within Lora + Inter pairing
- Context menu visual style details
- Responsive breakpoint adjustments for the new layout
- Empty state handling in the reader (loading spinner, error states)

### Deferred Ideas (OUT OF SCOPE)
- Article search (visible in Inoreader reference) -- separate feature/phase
- View mode switching (grid/card/list like Inoreader icons) -- separate feature/phase
- Per-article feedback (thumbs up/down) -- Phase 10: LLM Feedback Loop
</user_constraints>

## Standard Stack

### Core (already installed)
| Library | Purpose | Notes |
|---------|---------|-------|
| `@chakra-ui/react` | UI components (Menu, Select, Badge, Box, etc.) | Already used throughout. Menu.Root for context menus. |
| `@tanstack/react-query` | Server state management | Already used. No changes needed to query infrastructure. |
| `next` | App Router, SSR framework | Already used. No framework changes needed. |
| `react-icons/lu` | Lucide icons | Already used. New icons needed: LuBrain/LuSparkles, LuArrowUp/LuArrowDown, LuX, LuExternalLink, LuMenu. |

### New Dependencies
| Library | Version | Purpose | Why |
|---------|---------|---------|-----|
| `html-react-parser` | ^5.x | Parse HTML strings to React elements with custom replacements | Replaces `dangerouslySetInnerHTML`. Supports `replace` callback for images, links, code blocks. |
| `isomorphic-dompurify` | ^2.x | XSS sanitization that works in both SSR and client | Wraps DOMPurify for Next.js SSR compatibility. Sanitize before `html-react-parser` processes content. |

### Alternatives Considered
| Instead of | Could Use | Why Not |
|------------|-----------|---------|
| `isomorphic-dompurify` | `dompurify` | Raw DOMPurify requires different initialization for SSR vs client. `isomorphic-dompurify` handles this automatically. Project uses Next.js with SSR. |
| `html-react-parser` | `rehype-react` / `react-markdown` | Content is raw HTML from RSS feeds (not Markdown). `html-react-parser` is the direct replacement for `dangerouslySetInnerHTML` with the simplest API. |

**Installation:**
```bash
cd frontend && bun add html-react-parser isomorphic-dompurify && bun add -d @types/dompurify
```

## Architecture Patterns

### Pattern 1: Content Rendering Pipeline (DOMPurify + html-react-parser)

**What:** Two-stage pipeline: sanitize HTML with DOMPurify, then parse to React elements with custom replacements.
**When to use:** When rendering ArticleReader content.

```tsx
// Source: Context7 /remarkablemark/html-react-parser + /kkomelin/isomorphic-dompurify
import DOMPurify from "isomorphic-dompurify";
import parse, { domToReact, Element, HTMLReactParserOptions } from "html-react-parser";
import { Box, Image, Link, Code } from "@chakra-ui/react";

const parserOptions: HTMLReactParserOptions = {
  replace(domNode) {
    if (!(domNode instanceof Element)) return;

    // Images: responsive, lazy-loaded, click opens in new tab
    if (domNode.name === "img") {
      const src = domNode.attribs.src;
      const alt = domNode.attribs.alt || "";
      return (
        <a href={src} target="_blank" rel="noopener noreferrer">
          <Image src={src} alt={alt} maxW="100%" loading="lazy" borderRadius="md" my={4} />
        </a>
      );
    }

    // Links: external in new tab with proper rel
    if (domNode.name === "a") {
      return (
        <Link href={domNode.attribs.href} target="_blank" rel="noopener noreferrer">
          {domToReact(domNode.children, parserOptions)}
        </Link>
      );
    }
  },
};

// Usage in component:
const sanitized = DOMPurify.sanitize(contentHtml);
const content = parse(sanitized, parserOptions);
```

**Confidence:** HIGH -- verified via Context7 for both libraries.

### Pattern 2: Scroll-Collapse Sticky Header

**What:** Feed name heading collapses into the controls bar when user scrolls past it. Controls bar becomes sticky.
**When to use:** Article list view (not reader).

Approach: Use a `ref` + `IntersectionObserver` on the feed name heading. When it goes out of viewport, a `isScrolled` state toggles to true, which:
1. Makes controls bar `position: sticky; top: 0`
2. Inserts a small feed name text inline in the controls bar
3. Transition via CSS opacity/height

No external library needed. `IntersectionObserver` is native and well-supported.

**Confidence:** HIGH -- standard pattern, no library needed.

### Pattern 3: Inline Reader (Component Swap)

**What:** Article selection swaps between list view and reader view within the same container. No drawer, no route change.
**When to use:** When user clicks an article row.

```tsx
// ArticleView (renamed from ArticleList)
function ArticleView({ selectedFeedId }: ArticleViewProps) {
  const [selectedArticle, setSelectedArticle] = useState<ArticleListItem | null>(null);

  // Data layer stays mounted regardless of view
  const { data: articles, ... } = useArticles({ ... });

  if (selectedArticle) {
    return (
      <ArticleReader
        key={selectedArticle.id}
        article={selectedArticle}
        articles={displayArticles ?? []}
        onClose={() => setSelectedArticle(null)}
        onNavigate={setSelectedArticle}
      />
    );
  }

  return (
    // list view with feed heading, controls, article rows
  );
}
```

The key insight: `useArticles` is called unconditionally at the top of the component, so the query stays alive for prev/next navigation even when the reader is shown.

**Confidence:** HIGH -- simple conditional render, already have this pattern.

### Pattern 4: Context Menu on Article Rows

**What:** Hover-reveal ellipsis button on the right side of read article rows, opening a Menu with actions.
**When to use:** For read articles (to mark unread, open original, rescore).

Reuse the same pattern from `CategoryContextMenu.tsx`:
- `Menu.Root` > `Menu.Trigger asChild` > `IconButton` (LuEllipsisVertical)
- `Portal` > `Menu.Positioner` > `Menu.Content` > `Menu.Item` entries

**Important list consideration:** Each `Menu.Root` creates 2 Zag state machines. For article lists of ~50 items, that's 100 machines. This is acceptable since:
1. Context menu only renders on read articles (subset of rows)
2. Menu only appears on hover (desktop) -- could conditionally mount
3. The row count is bounded by page size (50)

Alternative: Conditionally render `Menu.Root` only when row is hovered (`isHovered && article.is_read`). This eliminates Zag machines for non-hovered rows at the cost of a mount delay.

**Recommendation:** Use conditional mount on hover to keep machines at 0-2 at any time.

**Confidence:** HIGH -- existing pattern in the codebase.

### Pattern 5: Sidebar Restructure (Absorb Header Content)

**What:** Remove `Header.tsx`. Move logo, settings icon, theme toggle, and hamburger into the Sidebar.
**When to use:** Layout restructure.

New sidebar structure:
```
[Logo/brand icon]           <- top, fixed
[Feeds heading + add]       <- below logo
[All Articles]
[Feed 1]
[Feed 2]
...                         <- scrollable middle
[Settings icon]             <- bottom, fixed
[Theme toggle]              <- bottom, fixed
```

Collapsed state (icon-only):
```
[Logo icon]                 <- top
[Feed icons/initials]       <- middle, scrollable
[Settings icon]             <- bottom
[Theme toggle]              <- bottom
```

Implementation: Use Flex column with `flex: 1` on the scrollable feed list, `mt="auto"` or a spacer for bottom-pinned icons.

**Confidence:** HIGH -- straightforward Flex layout.

### Pattern 6: Reader Sticky Header with Keyboard Navigation

**What:** Sticky bar at top of reader with title, navigation controls. Keyboard shortcuts for J/K/Escape.
**When to use:** When reader is displayed.

Keyboard handler via `useEffect` with `keydown` event listener on `document`:
```tsx
useEffect(() => {
  const handler = (e: KeyboardEvent) => {
    if (e.key === "Escape") onClose();
    if (e.key === "j" || e.key === "J") nextArticle && onNavigate(nextArticle);
    if (e.key === "k" || e.key === "K") prevArticle && onNavigate(prevArticle);
  };
  document.addEventListener("keydown", handler);
  return () => document.removeEventListener("keydown", handler);
}, [onClose, onNavigate, prevArticle, nextArticle]);
```

**Confidence:** HIGH -- standard DOM event listener pattern.

### Anti-Patterns to Avoid

- **Mounting Menu.Root per row unconditionally:** Creates 2 Zag machines per read article row. Conditionally render on hover.
- **Using `useBreakpointValue` in sidebar for collapsed state detection:** Already using `useLocalStorage` for collapse state -- keep that, don't duplicate with MQL.
- **Routing for reader navigation:** Decision is state-based (component swap), not route-based. Do NOT use `useRouter` or `Link` for article reader.
- **Removing `key={article.id}` on reader:** The key prop resets all state (optimistic weights, etc.) when article changes. Must preserve.
- **Re-fetching article list in reader:** The query is mounted in the parent component. Reader accesses `articles` prop for prev/next. Do NOT create a second `useArticles` call in the reader.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| HTML sanitization | Regex-based strip, custom sanitizer | `isomorphic-dompurify` | XSS is hard; DOMPurify handles edge cases, has huge test suite |
| HTML to React | Manual DOM parsing, regex replacement | `html-react-parser` | Handles malformed HTML, preserves DOM hierarchy, TypeScript types |
| Scroll detection | Manual scroll event + getBoundingClientRect | `IntersectionObserver` | Native, no library needed, handles edge cases (resize, layout shift) |
| Keyboard shortcuts | Custom key mapping framework | Raw `keydown` event listener | Only 3 shortcuts (Escape, J, K). Framework is overkill. |

## Common Pitfalls

### Pitfall 1: Summary Field Length in List Endpoint
**What goes wrong:** Adding `summary` to the list endpoint could significantly increase payload size. RSS summaries can be full HTML content (thousands of characters).
**Why it happens:** Some feeds use `summary` as a content mirror, not a brief description.
**How to avoid:** Truncate `summary` in the backend `_article_to_list_item` converter. Strip HTML tags and limit to ~200 characters. Frontend already shows 2 lines (sm font) so ~150 chars is sufficient.
**Warning signs:** Slow article list loading, large network payloads visible in DevTools.

### Pitfall 2: DOMPurify in SSR Context
**What goes wrong:** Raw `dompurify` fails in Node.js because it needs a DOM.
**Why it happens:** Next.js pre-renders components on the server.
**How to avoid:** Use `isomorphic-dompurify` which handles SSR/client automatically. The ArticleReader is a `"use client"` component, but imports still get server-evaluated.
**Warning signs:** `ReferenceError: window is not defined` or `document is not defined`.

### Pitfall 3: Lost Scroll Position on List/Reader Toggle
**What goes wrong:** User reads article, closes reader, article list is scrolled back to top.
**Why it happens:** Conditional render unmounts the list DOM, losing scroll position.
**How to avoid:** Two options: (1) Save/restore scroll position via ref, or (2) Use `display: none` instead of conditional render to keep DOM alive. Option 1 is simpler and avoids keeping the entire list DOM mounted during reading.
**Warning signs:** User frustration when repeatedly going back and forth between list and reader.

### Pitfall 4: Stale prevArticle/nextArticle After Re-fetch
**What goes wrong:** If the article list re-fetches while reading (polling), prev/next could point to stale objects.
**Why it happens:** `useMemo` depends on `articles` array reference which changes on re-fetch.
**How to avoid:** The current approach of finding by index in `articles` prop already handles this correctly -- new data gets new array, useMemo recomputes. No change needed, but verify this still works after restructure.
**Warning signs:** J/K navigation jumps to wrong articles or crashes on null.

### Pitfall 5: Mark-All-Read for "All Articles" Scope
**What goes wrong:** No backend endpoint exists for marking all articles across all feeds as read.
**Why it happens:** Current endpoint is `POST /api/feeds/{feed_id}/mark-read` -- feed-scoped only.
**How to avoid:** Add new endpoint `POST /api/articles/mark-all-read` that marks all unread scored+non-blocked articles as read. Frontend sends this when no feedId is selected.
**Warning signs:** Mark all read button does nothing or errors on "All Articles" view.

### Pitfall 6: IntersectionObserver Threshold Timing
**What goes wrong:** Sticky header flickers when near the threshold, toggling rapidly between states.
**Why it happens:** Element at exact boundary causes repeated intersecting/not-intersecting callbacks.
**How to avoid:** Use a small negative `rootMargin` (e.g., `-1px 0px 0px 0px`) to create a hysteresis zone. Or debounce the state change.
**Warning signs:** Controls bar rapidly switching between collapsed/expanded near scroll threshold.

### Pitfall 7: Sidebar Height After Header Removal
**What goes wrong:** Sidebar positioning breaks because it currently uses `top: HEADER_HEIGHT` (64px).
**Why it happens:** Removing the header means sidebar should start at `top: 0`.
**How to avoid:** Update sidebar `top` to `0`, remove `HEADER_HEIGHT` constant usage from `AppShell` main content `pt`, and update `MobileSidebar` hamburger position.
**Warning signs:** Gap at top of sidebar, or content overlapping where header used to be.

## Code Examples

### Backend: Add summary/score_reasoning to ArticleListItem Schema

```python
# In schemas.py -- add two fields to ArticleListItem
class ArticleListItem(BaseModel):
    """Lightweight article for list endpoints."""
    # ... existing fields ...
    summary_preview: str | None  # Truncated, HTML-stripped summary (max ~200 chars)
    score_reasoning: str | None  # Full score reasoning text
```

```python
# In routers/articles.py -- update _article_to_list_item
import re

def _strip_html_truncate(html: str | None, max_len: int = 200) -> str | None:
    if not html:
        return None
    text = re.sub(r"<[^>]+>", "", html)  # Strip HTML tags
    text = " ".join(text.split())  # Normalize whitespace
    return text[:max_len] + "..." if len(text) > max_len else text

def _article_to_list_item(article: Article) -> ArticleListItem:
    # ... existing code ...
    return ArticleListItem(
        # ... existing fields ...
        summary_preview=_strip_html_truncate(article.summary),
        score_reasoning=article.score_reasoning,
    )
```

### Backend: Per-Article Rescore Endpoint

```python
# In routers/articles.py
@router.post("/{article_id}/rescore")
def rescore_article(
    article_id: int,
    session: Session = Depends(get_session),
):
    """Queue a single article for re-scoring."""
    from backend.scheduler import scoring_queue

    article = session.get(Article, article_id)
    if not article:
        raise HTTPException(status_code=404, detail="Article not found")

    article.scoring_state = "queued"
    article.scoring_priority = 1  # Higher priority than batch
    session.add(article)
    session.commit()

    return {"ok": True}
```

### Backend: Mark All Articles Read (Cross-Feed)

```python
# In routers/articles.py
@router.post("/mark-all-read")
def mark_all_articles_read(
    session: Session = Depends(get_session),
):
    """Mark all unread scored non-blocked articles as read."""
    result = session.exec(
        update(Article)
        .where(Article.is_read.is_(False))
        .where(Article.scoring_state == "scored")
        .where(Article.composite_score != 0)
        .values(is_read=True)
    )
    session.commit()
    return {"ok": True, "count": result.rowcount}
```

**Important:** This static route (`/mark-all-read`) MUST be registered before the parameterized route (`/{article_id}`) to avoid path conflicts. Per project rules: "static routes registered before parameterized to avoid path conflicts."

### Frontend: html-react-parser Options

```tsx
// Source: Context7 /remarkablemark/html-react-parser
import DOMPurify from "isomorphic-dompurify";
import parse, { domToReact, Element, HTMLReactParserOptions } from "html-react-parser";

const parserOptions: HTMLReactParserOptions = {
  replace(domNode) {
    if (!(domNode instanceof Element)) return;

    if (domNode.name === "img") {
      const src = domNode.attribs.src;
      return (
        <a href={src} target="_blank" rel="noopener noreferrer">
          <img
            src={src}
            alt={domNode.attribs.alt || ""}
            loading="lazy"
            style={{ maxWidth: "100%", height: "auto", borderRadius: "8px" }}
          />
        </a>
      );
    }

    if (domNode.name === "a") {
      return (
        <a
          href={domNode.attribs.href}
          target="_blank"
          rel="noopener noreferrer"
        >
          {domToReact(domNode.children, parserOptions)}
        </a>
      );
    }
  },
};

// Usage:
const sanitized = DOMPurify.sanitize(contentHtml);
const rendered = parse(sanitized, parserOptions);
```

### Frontend: Reader textStyle in Theme

```typescript
// In theme/typography.ts -- add reader content styles
export const textStyles = defineTextStyles({
  // ... existing styles ...
  "reader.content": {
    value: {
      fontFamily: "serif",
      fontSize: "1.125rem",
      lineHeight: "1.85",
      "& p": { mb: "1.25rem" },
      "& h1, & h2, & h3": { fontWeight: "600", lineHeight: "1.3", fontFamily: "sans" },
      "& h1": { fontSize: "1.5rem", mt: "1.5rem", mb: "0.75rem" },
      "& h2": { fontSize: "1.25rem", mt: "1.5rem", mb: "0.75rem" },
      "& h3": { fontSize: "1.125rem", mt: "1.25rem", mb: "0.5rem" },
      // ... etc
    },
  },
});
```

**Note:** Chakra's `defineTextStyles` supports nested selectors in the `value` object, which is how the current `reader` textStyle is used. Verify that deeply nested `& pre code` selectors work in textStyles -- if not, fall back to the `css` prop on the content wrapper (current approach).

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| `dangerouslySetInnerHTML` | `html-react-parser` + `DOMPurify` | Established pattern since React ecosystem matured | Safer, more controllable, enables lazy loading and link handling |
| Drawer/modal reader | Inline/panel reader | Adopted by Feedly, Inoreader, Miniflux | Better information density, sidebar stays visible, feels more integrated |
| Individual filter buttons | Filter dropdown with counts | Common in mature feed readers | Saves horizontal space, shows counts at a glance |

## Open Questions

1. **Scroll position restoration on reader close**
   - What we know: Conditional render unmounts list DOM, losing scroll position
   - What's unclear: Whether `display: none` (keeping DOM alive) is better than save/restore via ref
   - Recommendation: Start with save/restore via ref (simpler, less memory). Use `scrollTop` of the main content area saved before showing reader, restored on close.

2. **Collapsed sidebar feed icons**
   - What we know: Decision says "feed icons/initials in middle"
   - What's unclear: Whether to use first letter of feed title, or a generic RSS icon
   - Recommendation: Use first letter of feed title in a small circle (like avatar). Generic RSS icon if all feeds look the same. This is discretionary per CONTEXT.md.

3. **textStyle nested selectors for reader content**
   - What we know: Current reader styles use `css` prop with nested selectors (`& p`, `& h1`, etc.)
   - What's unclear: Whether Chakra's `defineTextStyles` supports deeply nested selectors (e.g., `& pre code`, `& :not(pre) > code`)
   - Recommendation: Attempt theme-level textStyle first. If nested selectors don't work in textStyles, keep the `css` prop approach (current) and document why. Either way, the styles should be defined as a constant, not inline.

## Sources

### Primary (HIGH confidence)
- Context7 `/remarkablemark/html-react-parser` -- replace option API, TypeScript types, domToReact usage
- Context7 `/cure53/dompurify` -- ALLOWED_TAGS/ALLOWED_ATTR configuration, sanitization API
- Context7 `/kkomelin/isomorphic-dompurify` -- SSR/client unified import, basic sanitization API

### Secondary (MEDIUM confidence)
- Codebase analysis of all affected files (ArticleList, ArticleRow, ArticleReader, AppShell, Header, Sidebar, MobileSidebar, schemas.py, routers/articles.py, scoring_queue.py)
- Existing project patterns (CategoryContextMenu for Menu.Root usage, FeedRow for hover-reveal pattern)

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH -- only 2 new packages, both well-established and verified via Context7
- Architecture: HIGH -- all patterns derive from existing codebase patterns or standard React techniques
- Pitfalls: HIGH -- identified from direct codebase analysis (missing endpoints, payload sizes, SSR concerns)

**Research date:** 2026-02-22
**Valid until:** 2026-03-22 (stable domain, no fast-moving dependencies)
