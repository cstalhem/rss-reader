---
phase: 09.5-refine-main-view-ux-and-typography
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/components/layout/AppShell.tsx
  - frontend/src/components/article/ArticleList.tsx
  - frontend/src/components/article/ArticleReader.tsx
autonomous: true
requirements: []
gap_closure: true

must_haves:
  truths:
    - "Controls bar sticks at top of viewport when scrolled past the feed name heading"
    - "Feed name heading fades/slides out when scrolled; inline name fades in alongside controls"
    - "Reader sticky header stays fixed at top while scrolling through article content"
    - "Inline reader opens with an accordion-style height animation instead of instant swap"
    - "Scroll position is correctly saved and restored using the main scroll container"
  artifacts:
    - path: "frontend/src/components/layout/AppShell.tsx"
      provides: "Fixed-height main scroll container (height=100vh, overflowY=auto)"
      contains: "height.*100vh"
    - path: "frontend/src/components/article/ArticleList.tsx"
      provides: "Controls bar with unconditional sticky, IntersectionObserver using mainRef, scroll save/restore via mainRef"
      contains: "position.*sticky"
    - path: "frontend/src/components/article/ArticleReader.tsx"
      provides: "Sticky header working inside fixed main container"
      contains: "position.*sticky"
  key_links:
    - from: "frontend/src/components/layout/AppShell.tsx"
      to: "frontend/src/components/article/ArticleList.tsx"
      via: "mainRef forwarded via onOpenMobileSidebar pattern or new prop"
      pattern: "mainRef|scrollContainer"
    - from: "frontend/src/components/article/ArticleList.tsx"
      to: "main scroll container"
      via: "IntersectionObserver root: mainRef.current"
      pattern: "root.*mainRef"
---

<objective>
Fix sticky positioning failures and add accordion animation to the inline reader.

Purpose: Three UAT failures share the same root cause — `<main>` uses `minHeight="100vh"` which allows infinite growth, so the document (not `<main>`) becomes the scroll container. `position: sticky` then behaves unpredictably because there is no single authoritative scroll ancestor. Fixing this one layout property resolves both the controls-bar sticky issue (Test 7) and the reader header sticky issue (Test 10). The accordion animation (Test 9) is addressed in the same plan because it requires restructuring how the reader is rendered inside ArticleList, which is already being touched.

Output: AppShell with fixed scroll container, always-sticky controls bar with heading animation, sticky reader header, and accordion reader open/close animation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09.5-refine-main-view-ux-and-typography/09.5-CONTEXT.md
@frontend/src/components/layout/AppShell.tsx
@frontend/src/components/article/ArticleList.tsx
@frontend/src/components/article/ArticleReader.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix scroll container in AppShell and expose mainRef to ArticleList</name>
  <files>
    frontend/src/components/layout/AppShell.tsx
    frontend/src/components/article/ArticleList.tsx
  </files>
  <action>
**Root cause:** `<Box as="main" minHeight="100vh" overflowY="auto">` — `minHeight` lets the element grow unboundedly, so content taller than the viewport causes the *document* to scroll, not `<main>`. `position: sticky` elements inside `<main>` then have no reliable scroll ancestor to stick relative to.

**Fix in AppShell.tsx:**

Change the main Box from `minHeight="100vh"` to `height="100vh"` with `overflowY="auto"`. Also add a `ref` to this element and pass it to ArticleList via a new `mainRef` prop so the IntersectionObserver and scroll save/restore can target the correct container:

```tsx
// AppShell.tsx
import { useRef } from "react";
// ...
const mainRef = useRef<HTMLDivElement>(null);
// ...
<Box
  ref={mainRef}
  as="main"
  ml={{ base: 0, md: isSidebarCollapsed ? SIDEBAR_WIDTH_COLLAPSED : SIDEBAR_WIDTH_EXPANDED }}
  height="100vh"        // was: minHeight="100vh"
  overflowY="auto"
  transition="margin-left 0.2s ease"
>
  <ArticleList
    selectedFeedId={selectedFeedId}
    onOpenMobileSidebar={() => setIsMobileSidebarOpen(true)}
    mainRef={mainRef}   // new prop
  />
</Box>
```

**Fix in ArticleList.tsx:**

1. Add `mainRef: React.RefObject<HTMLDivElement>` to `ArticleListProps`.

2. Update IntersectionObserver to use `mainRef.current` as the root (so the observer fires relative to the scroll container, not the viewport):
```tsx
const observer = new IntersectionObserver(
  ([entry]) => {
    setIsScrolled(!entry.isIntersecting);
  },
  { root: mainRef.current, rootMargin: "-1px 0px 0px 0px" }
);
```

3. Update `handleSelect` to save and restore scroll via `mainRef.current` instead of `window`:
```tsx
const handleSelect = (article: ArticleListItem) => {
  scrollPositionRef.current = mainRef.current?.scrollTop ?? 0;
  setSelectedArticle(article);
  mainRef.current?.scrollTo(0, 0);
};

const handleCloseReader = useCallback(() => {
  setSelectedArticle(null);
  requestAnimationFrame(() => {
    mainRef.current?.scrollTo(0, scrollPositionRef.current);
  });
}, [mainRef]);
```

4. Make the controls bar `position="sticky"` unconditionally (remove the `isScrolled` ternary for position). Keep `isScrolled` only to show/hide the inline feed name:
```tsx
<Flex
  px={4}
  py={2}
  borderBottom="1px solid"
  borderColor="border.subtle"
  alignItems="center"
  gap={2}
  position="sticky"    // was: position={isScrolled ? "sticky" : "static"}
  top={0}
  zIndex={5}
  bg="bg"
>
```

5. For the heading animation: keep the heading always rendered but add an opacity + translateY transition based on `isScrolled`. This makes the heading visually slide-and-fade out when scrolled, coordinated with the inline name fading in:
```tsx
<Heading
  ref={headingRef}
  fontSize="2xl"
  fontWeight="bold"
  transition="opacity 0.2s ease, transform 0.2s ease"
  opacity={isScrolled ? 0 : 1}
  transform={isScrolled ? "translateY(-4px)" : "translateY(0)"}
>
  {feedName}
</Heading>
```

The inline feed name in the controls bar already fades in using the existing `css` animation when `isScrolled` is true — keep that as-is.
  </action>
  <verify>
`cd /Users/cstalhem/projects/rss-reader/frontend && bun run build` — no TypeScript errors. Dev server: scroll down past the "Articles" / feed name heading — controls bar sticks at top immediately. Heading fades/slides up as it exits. Inline feed name appears in controls bar.
  </verify>
  <done>
`<main>` is fixed-height (100vh) and scrolls internally. Controls bar is always sticky at top=0. Heading fades out on scroll; inline name fades in. IntersectionObserver and scroll save/restore both use mainRef.current. No window.scrollY / window.scrollTo usage remaining in ArticleList.
  </done>
</task>

<task type="auto">
  <name>Task 2: Accordion-style reader open animation and reader sticky header</name>
  <files>
    frontend/src/components/article/ArticleList.tsx
    frontend/src/components/article/ArticleReader.tsx
  </files>
  <action>
**Reader sticky header (Test 10):**

The reader header is already `position="sticky" top={0} zIndex={2}` in ArticleReader.tsx. Once Task 1 fixes `<main>` to be the definitive scroll container with `height="100vh" overflowY="auto"`, the sticky header should work correctly without any change to ArticleReader. Verify this is the case. If not, ensure the reader's outer Box has no `overflow: hidden` or similar that could break stickiness.

**Accordion-style animation (Test 9):**

Currently ArticleList does an early return when `selectedArticle` is set, replacing the list entirely with no animation. The user wants it to animate open like an accordion.

Use the CSS grid trick for height: 0 → auto animation (works without JS-measured heights):

Instead of an early return, keep the article list rendered and insert the reader below the clicked article row using Chakra's `Collapsible.Root`. The approach:

1. Remove the early return (`if (selectedArticle) return <ArticleReader ... />`).

2. In the article list `map`, after the selected article's `ArticleRow`, render a `Collapsible.Root` containing `ArticleReader`:

```tsx
{displayArticles.map((article) => (
  <React.Fragment key={article.id}>
    <ArticleRow
      article={article}
      feedName={selectedFeedId ? undefined : feedNames[article.feed_id]}
      onSelect={handleSelect}
      onToggleRead={handleToggleRead}
      onRescore={handleRescore}
      isCompleting={completingIds.has(article.id)}
      scoringPhase={...}
    />
    {selectedArticle?.id === article.id && (
      <Collapsible.Root open={true} lazyMount unmountOnExit={false}>
        <Collapsible.Content>
          <ArticleReader
            key={selectedArticle.id}
            article={selectedArticle}
            articles={displayArticles ?? []}
            feedName={feedNames[selectedArticle.feed_id]}
            onClose={handleCloseReader}
            onNavigate={setSelectedArticle}
          />
        </Collapsible.Content>
      </Collapsible.Root>
    )}
  </React.Fragment>
))}
```

3. For the close animation, control the Collapsible open state with a local `isReaderOpen` boolean that tracks `selectedArticle !== null`. Set `isReaderOpen = false` first (triggers close animation), then after the animation completes (~300ms), call `setSelectedArticle(null)`. Use a simple timeout in `handleCloseReader`:

```tsx
const [isReaderOpen, setIsReaderOpen] = useState(false);

// When article selected, set both:
const handleSelect = (article: ArticleListItem) => {
  scrollPositionRef.current = mainRef.current?.scrollTop ?? 0;
  setSelectedArticle(article);
  setIsReaderOpen(true);
  // No scrollTo(0,0) — reader appears inline below the row
};

const handleCloseReader = useCallback(() => {
  setIsReaderOpen(false);
  setTimeout(() => {
    setSelectedArticle(null);
    requestAnimationFrame(() => {
      mainRef.current?.scrollTo(0, scrollPositionRef.current);
    });
  }, 300); // match Collapsible transition duration
}, [mainRef]);
```

4. In the Collapsible: `open={isReaderOpen}` instead of `open={true}`.

5. Since the reader is now inline (not a full-page takeover), the reader's sticky header `position="sticky" top={0}` sticks to the `<main>` scroll container correctly — it will stay visible as the user scrolls through the article content below.

Import `Collapsible` from `@chakra-ui/react` and `React` from `react` at the top of ArticleList.tsx if not already imported.

**Important:** The scroll-to-top behavior on article open is no longer needed (the reader opens below the row, so the user is already positioned near it). Remove `mainRef.current?.scrollTo(0, 0)` from handleSelect.
  </action>
  <verify>
`cd /Users/cstalhem/projects/rss-reader/frontend && bun run build` — no errors. Dev server: click an article row — the reader slides open below it (accordion animation). The article list rows above remain visible. Scrolling into the reader content — the reader's sticky header stays at top. Pressing X / Escape — reader collapses with animation, list returns.
  </verify>
  <done>
Reader opens with accordion slide-down animation. Article list remains visible above the reader. Reader sticky header works correctly within the fixed main scroll container. Close animation plays before article list scrolls back to saved position.
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/cstalhem/projects/rss-reader/frontend && bun run build` — zero TypeScript errors
2. `cd /Users/cstalhem/projects/rss-reader/frontend && bun run lint` — zero ESLint errors
3. Dev server: scroll down past heading — controls bar sticks, heading fades, inline name appears
4. Dev server: click article — accordion slides open, list visible above
5. Dev server: scroll in reader — reader header sticks at top
6. Dev server: close reader — accordion closes, list scrolls back to saved position
</verification>

<success_criteria>
- `position: sticky` controls bar works because `<main>` is `height="100vh" overflowY="auto"` (the true scroll container)
- Controls bar always sticky at top (not conditionally sticky)
- Heading opacity/transform transition provides the animated size-collapse feel when scrolled
- Reader opens with Collapsible accordion animation (not instant swap)
- Reader sticky header works correctly
- IntersectionObserver uses `root: mainRef.current`
- Scroll save/restore uses `mainRef.current.scrollTop` / `.scrollTo()`
- No `window.scrollY` or `window.scrollTo` remaining in ArticleList
</success_criteria>

<output>
After completion, create `/Users/cstalhem/projects/rss-reader/.planning/phases/09.5-refine-main-view-ux-and-typography/09.5-06-SUMMARY.md`
</output>
