---
phase: 02-article-reading-ui
plan: "02"
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/backend/main.py
  - backend/tests/test_api.py
  - frontend/package.json
  - frontend/src/lib/api.ts
  - frontend/src/lib/types.ts
  - frontend/src/lib/queryClient.ts
  - frontend/src/app/providers.tsx
autonomous: true

must_haves:
  truths:
    - "Backend API filters articles by read status when is_read parameter is provided"
    - "Backend API returns all articles when no is_read filter is given"
    - "Frontend has TypeScript types matching backend Article and Feed models"
    - "Frontend has TanStack Query hooks for fetching articles with pagination"
    - "Frontend has mutation hook for marking articles read/unread"
  artifacts:
    - path: "backend/src/backend/main.py"
      provides: "Enhanced list_articles with is_read filter"
      contains: "is_read"
    - path: "frontend/src/lib/types.ts"
      provides: "TypeScript interfaces for Article, Feed"
    - path: "frontend/src/lib/api.ts"
      provides: "API client functions for articles"
      exports: ["fetchArticles", "fetchArticle", "updateArticleReadStatus"]
    - path: "frontend/src/lib/queryClient.ts"
      provides: "TanStack Query client configuration"
    - path: "frontend/src/app/providers.tsx"
      provides: "Client-side provider wrapper with QueryClientProvider"
  key_links:
    - from: "frontend/src/lib/api.ts"
      to: "backend /api/articles"
      via: "fetch calls"
      pattern: "fetch.*api/articles"
    - from: "frontend/src/app/providers.tsx"
      to: "frontend/src/lib/queryClient.ts"
      via: "QueryClientProvider"
      pattern: "QueryClientProvider"
---

<objective>
Add read-status filtering to the backend API and set up the frontend data layer (API client, types, TanStack Query).

Purpose: Provide the data foundation that article list and reader components will consume. The backend filter enables the "unread only" default view. TanStack Query handles caching, background sync, and optimistic updates.

Output: Backend with is_read filter on articles endpoint; frontend with typed API client, TanStack Query configured, and hooks ready for consumption.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-article-reading-ui/02-CONTEXT.md
@.planning/phases/02-article-reading-ui/02-RESEARCH.md
@backend/src/backend/main.py
@backend/src/backend/models.py
@backend/tests/test_api.py
@frontend/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add is_read filter to backend list_articles endpoint</name>
  <files>
    backend/src/backend/main.py
    backend/tests/test_api.py
  </files>
  <action>
    1. In `backend/src/backend/main.py`, modify the `list_articles` endpoint:
       - Add an optional `is_read: bool | None = None` query parameter
       - When `is_read` is not None, add `.where(Article.is_read == is_read)` to the query
       - When `is_read` is None (default), return all articles (current behavior preserved)

    2. In `backend/tests/test_api.py`, add test cases:
       - Test that `GET /api/articles?is_read=false` returns only unread articles
       - Test that `GET /api/articles?is_read=true` returns only read articles
       - Test that `GET /api/articles` (no filter) returns all articles
       - Set up test data: create a mix of read and unread articles in the test fixture

    3. Run the existing test suite to verify no regressions:
       ```bash
       cd backend && uv run pytest -v
       ```
  </action>
  <verify>
    ```bash
    cd backend && uv run pytest -v
    ```
    All tests pass, including the new filter tests.
  </verify>
  <done>
    - `GET /api/articles?is_read=false` returns only unread articles
    - `GET /api/articles?is_read=true` returns only read articles
    - `GET /api/articles` returns all articles (backward compatible)
    - All existing tests still pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Create frontend data layer with TanStack Query</name>
  <files>
    frontend/package.json
    frontend/src/lib/types.ts
    frontend/src/lib/api.ts
    frontend/src/lib/queryClient.ts
    frontend/src/app/providers.tsx
  </files>
  <action>
    1. Install TanStack Query:
       ```bash
       cd frontend && npm install @tanstack/react-query
       ```

    2. Create `frontend/src/lib/types.ts`:
       - Define `Article` interface matching backend model:
         ```typescript
         interface Article {
           id: number;
           feed_id: number;
           title: string;
           url: string;
           author: string | null;
           published_at: string | null;
           summary: string | null;
           content: string | null;
           is_read: boolean;
         }
         ```
       - Define `Feed` interface matching backend model:
         ```typescript
         interface Feed {
           id: number;
           url: string;
           title: string;
           last_fetched_at: string | null;
         }
         ```
       - Export both interfaces

    3. Create `frontend/src/lib/api.ts`:
       - Define `API_BASE_URL` from `process.env.NEXT_PUBLIC_API_URL` with fallback to `http://localhost:8912` (dev port from backend config)
       - `fetchArticles(params: { skip?: number; limit?: number; is_read?: boolean })` — calls `GET /api/articles` with query params, returns `Article[]`
       - `fetchArticle(id: number)` — calls `GET /api/articles/{id}`, returns `Article`
       - `updateArticleReadStatus(id: number, is_read: boolean)` — calls `PATCH /api/articles/{id}` with `{ is_read }`, returns `Article`
       - All functions use native `fetch`, throw on non-ok responses
       - Export all functions

    4. Create `frontend/src/lib/queryClient.ts`:
       - Create and export a QueryClient with sensible defaults:
         - `staleTime: 30 * 1000` (30 seconds — matches feed refresh interval logic)
         - `refetchOnWindowFocus: true` (refresh when user returns to tab)

    5. Create `frontend/src/app/providers.tsx`:
       - 'use client' directive
       - Import QueryClientProvider from @tanstack/react-query
       - Import queryClient from @/lib/queryClient
       - Wrap children in QueryClientProvider
       - NOTE: This file will be consumed by layout.tsx. It is SEPARATE from the Chakra provider. Plan 02-01 creates the Chakra provider; this plan creates the Query provider. The executor of Plan 02-03 will need to compose both in layout.tsx (or the executor of this plan can do it if 02-01 is already complete). For now, just create the QueryProvider component that exports a wrapper.
  </action>
  <verify>
    ```bash
    cd frontend && npx tsc --noEmit
    ```
    TypeScript compiles without errors. All types resolve, imports work.
  </verify>
  <done>
    - TanStack Query installed
    - Article and Feed TypeScript types defined matching backend models
    - API client with fetchArticles (with is_read filter), fetchArticle, updateArticleReadStatus
    - QueryClient configured with sensible defaults
    - QueryProvider component created for use in layout.tsx
    - TypeScript compiles without errors
  </done>
</task>

</tasks>

<verification>
1. `cd backend && uv run pytest -v` — all tests pass including new filter tests
2. `cd frontend && npx tsc --noEmit` — TypeScript compiles cleanly
3. API client functions are importable and properly typed
4. QueryClient and QueryProvider are properly configured
</verification>

<success_criteria>
- Backend articles endpoint supports `is_read=true|false` filtering
- Frontend has typed API client matching backend contract
- TanStack Query configured and provider ready for composition
- All tests pass, TypeScript compiles
</success_criteria>

<output>
After completion, create `.planning/phases/02-article-reading-ui/02-02-SUMMARY.md`
</output>
