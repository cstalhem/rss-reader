# Phase 09.4: Settings Page Architecture Implementation - Research

**Researched:** 2026-02-22
**Domain:** React component architecture refactoring — shared primitives, custom hooks, React Context, Chakra UI v3
**Confidence:** HIGH

---

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

**ModelSelector progress bars (Theme C adjustment):**
- Remove all 3 inline progress bars from ModelSelector entirely — the selector should only list fully downloaded models ready for use
- Model list in the selector dropdown should only update after a pull is confirmed complete by Ollama
- When deleting a model that is currently selected (in categorization or scoring config), show a ConfirmDialog warning the user. If confirmed: delete the model and revert the selector to no selection
- This replaces the original SC6 ("use ModelPullProgress compact") — simpler and cleaner

**Category section decomposition (Theme B):**
- Full three-part split as proposed in 09.3 findings:
  1. `useCategoryTree(categories)` — Extract 4 useMemo computations (tree building, newCategoryIds, hiddenCategories, search filtering) + search state into a custom hook. Pure data logic.
  2. `useCategoryDialogs()` — Extract 4 dialog state objects (delete, move, ungroupConfirm, ungroupParentConfirm) and their open/close/confirm handlers into a custom hook.
  3. `CategoryTreeContext` — Put action callbacks (weight change, rename, delete, hide, badge dismiss, ungroup) into React context. CategoryTree props reduced from 15 to ~5 (data only). Row component props reduced from 10-12 to 3-5 (via useContext).
- Selection state (selectedIds, onToggleSelection) placement in context vs props is Claude's discretion — do what minimises total props while keeping the code clear

### Claude's Discretion

- Component API shapes for SettingsPanel, EmptyState, SettingsPageHeader (props, slots, children patterns)
- Selection state placement (context vs props) for CategoryTreeContext
- Whether to include newCategoryIds in context or pass as prop
- All other themes (A, D, E) implemented per 09.3 findings without modification

### Deferred Ideas (OUT OF SCOPE)

None — discussion stayed within phase scope.
</user_constraints>

---

## Summary

This phase is a pure frontend refactoring pass over the settings area. The codebase audit (Phase 09.3) has already produced a complete, verified findings document — there is no ambiguity about what to change or why. Research focus is therefore on **how** to implement the five change themes correctly within the project's established patterns.

The key implementation risks are: (1) maintaining React.memo prop stability through the CategoryTreeContext change without breaking memo boundaries, (2) correctly placing selection state in context vs props to minimise prop count while keeping memoization effective, and (3) implementing the Chakra UI v3 EmptyState and Select components correctly since NativeSelect is being replaced.

All changes are confined to `frontend/src/components/settings/` and `frontend/src/lib/constants.ts`. No backend changes. No new dependencies.

**Primary recommendation:** Implement in the plan order (A+D first, B second, C+E third) because Plans 01 and 03 are independent leaf changes, while Plan 02 (Category decomposition) requires the deepest refactoring of the most complex component.

---

## Standard Stack

### Core (already installed — no new dependencies needed)

| Library | Purpose | Notes |
|---------|---------|-------|
| React (via Next.js 15) | Context, hooks, memo | `createContext`, `useContext`, `useCallback`, `useMemo` |
| Chakra UI v3 | `EmptyState.*`, `Select.*` components | `EmptyState` is built-in, not a snippet composition |
| `@/components/ui/confirm-dialog` | ConfirmDialog shared component | Already in project, used in CategoriesSection |

### No new packages required

All primitives being created (`SettingsPanel`, `EmptyState`, `SettingsPageHeader`, hooks, context) are pure React + Chakra UI components. No library additions needed.

---

## Architecture Patterns

### Pattern 1: Custom Hook for Derived State (useCategoryTree)

**What:** Extract the four `useMemo` computations and search state from CategoriesSection into a single custom hook.

**Current state in CategoriesSection (lines 70–183):**
```typescript
// 4 useMemos + searchQuery useState + setSearchQuery
const [searchQuery, setSearchQuery] = useState("");
const { parents, childrenMap, ungroupedCategories } = useMemo(() => { ... }, [categories]);
const newCategoryIds = useMemo(() => { ... }, [categories]);
const hiddenCategories = useMemo(() => { ... }, [categories]);
const { filteredParents, filteredChildrenMap, filteredUngrouped } = useMemo(() => { ... }, [searchQuery, parents, childrenMap, ungroupedCategories]);
```

**Target API:**
```typescript
// hooks/useCategoryTree.ts
export function useCategoryTree(categories: Category[]) {
  const [searchQuery, setSearchQuery] = useState("");

  const { parents, childrenMap, ungroupedCategories } = useMemo(() => { ... }, [categories]);
  const newCategoryIds = useMemo(() => { ... }, [categories]);
  const hiddenCategories = useMemo(() => { ... }, [categories]);
  const { filteredParents, filteredChildrenMap, filteredUngrouped } = useMemo(
    () => { ... },
    [searchQuery, parents, childrenMap, ungroupedCategories]
  );

  return {
    parents: filteredParents,
    childrenMap: filteredChildrenMap,
    ungroupedCategories: filteredUngrouped,
    newCategoryIds,
    hiddenCategories,
    searchQuery,
    setSearchQuery,
  };
}
```

**CategoriesSection after:**
```typescript
const { parents, childrenMap, ungroupedCategories, newCategoryIds, hiddenCategories, searchQuery, setSearchQuery } =
  useCategoryTree(categories);
```

### Pattern 2: Custom Hook for Dialog State (useCategoryDialogs)

**What:** Extract the 4 dialog state objects and their handlers from CategoriesSection.

**Target API:**
```typescript
// hooks/useCategoryDialogs.ts
export function useCategoryDialogs(
  categories: Category[],
  childrenMap: Record<number, Category[]>,
  selectedIds: Set<number>,
  clearSelection: () => void,
  batchMoveMutation: ...,
  batchDeleteMutation: ...,
  deleteCategoryMutation: ...,
  ungroupParentMutation: ...,
) {
  // Move dialog state
  const [moveDialogOpen, setMoveDialogOpen] = useState(false);
  // Ungroup batch confirm state
  const [ungroupConfirmCount, setUngroupConfirmCount] = useState<number | null>(null);
  // Delete dialog state (single + bulk)
  const [deleteDialogState, setDeleteDialogState] = useState<DeleteDialogState>({ open: false, ... });
  // Ungroup parent confirm state
  const [ungroupParentConfirm, setUngroupParentConfirm] = useState<{ id: number; name: string } | null>(null);

  // Handlers: handleDeleteCategory, handleDeleteConfirm, handleUngroupParent, handleUngroupParentConfirm
  // handleActionMoveToGroup, handleMoveToGroup, handleCreateAndMove
  // handleActionUngroup, handleUngroupConfirm

  return {
    // state values for dialog rendering
    moveDialogOpen, setMoveDialogOpen,
    ungroupConfirmCount, setUngroupConfirmCount,
    deleteDialogState, setDeleteDialogState,
    ungroupParentConfirm, setUngroupParentConfirm,
    // handlers passed to action bar and context menu
    handleDeleteCategory,
    handleDeleteConfirm,
    handleUngroupParent,
    handleUngroupParentConfirm,
    handleActionMoveToGroup,
    handleMoveToGroup,
    handleCreateAndMove,
    handleActionUngroup,
    handleUngroupConfirm,
  };
}
```

**Note on mutation dependencies:** The hook takes mutation objects as arguments. Per project rules, use `mutation.mutate` (stable reference) not `mutation` (new object each render) in useCallback deps.

### Pattern 3: React Context for Action Callbacks (CategoryTreeContext)

**What:** Create a context that holds the 8 action callbacks, plus selection state (selectedIds, onToggleSelection), and newCategoryIds. CategoryTree receives only structural/data props.

**Target context shape:**
```typescript
// contexts/CategoryTreeContext.ts (or co-located with CategoriesSection)
interface CategoryTreeContextValue {
  onWeightChange: (categoryId: number, weight: string) => void;
  onResetWeight: (categoryId: number) => void;
  onHide: (categoryId: number) => void;
  onBadgeDismiss: (categoryId: number) => void;
  onRename: (categoryId: number, newName: string) => void;
  onDelete: (categoryId: number) => void;
  onUngroup: (categoryId: number) => void;
  // Selection — placed in context to reduce CategoryTree props
  selectedIds: Set<number>;
  onToggleSelection: (id: number) => void;
  // newCategoryIds — placed in context since it's consumed only by row components
  newCategoryIds: Set<number>;
}

export const CategoryTreeContext = createContext<CategoryTreeContextValue | null>(null);

export function useCategoryTreeContext() {
  const ctx = useContext(CategoryTreeContext);
  if (!ctx) throw new Error("useCategoryTreeContext must be used within CategoryTree");
  return ctx;
}
```

**CategoryTree props after (from 15 to ~5):**
```typescript
interface CategoryTreeProps {
  parents: Category[];
  childrenMap: Record<number, Category[]>;
  ungroupedCategories: Category[];
  expandedParents: Record<number, boolean>;
  onToggleParent: (parentId: number) => void;
}
```

**Row component props after (examples):**
```typescript
// CategoryChildRow: category + weight + isOverridden + parentWeight (data only)
// Uses useContext for: onWeightChange, onResetWeight, onHide, onBadgeDismiss, onRename, onDelete, selectedIds, onToggleSelection, newCategoryIds

// CategoryParentRow: category + weight + childCount + isExpanded + onToggleExpand + newChildCount + onDismissNewChildren
// Note: onDismissNewChildren is computed in CategoryTree from context.newCategoryIds + context.onBadgeDismiss
// So it can be passed as a local prop within CategoryTree (not from context) — avoids making CategoryTree itself context-aware for this one case
```

**Decision on selection state:** Selection state goes in context. Both `selectedIds` and `onToggleSelection` are currently passed through CategoryTree to CategoryChildRow and CategoryUngroupedRow. Moving them to context eliminates 2 props from CategoryTree and 2 props from each row component.

**Decision on newCategoryIds:** newCategoryIds goes in context. It is consumed by CategoryChildRow, CategoryUngroupedRow, and CategoryParentRow (for newChildCount calculation). Moving to context removes 1 prop from CategoryTree. CategoryTree can still compute `newChildCount` per parent locally by reading `context.newCategoryIds` inline.

### Pattern 4: SettingsPanel Shared Component

**What:** A simple wrapper component replacing the repeated `Box bg="bg.subtle/bg.panel" borderRadius="md" borderWidth="1px" p={5|6}` pattern.

**Current patterns found in codebase:**
- `OllamaSection`: `Box bg="bg.subtle" borderRadius="md" borderWidth="1px" borderColor="border.subtle" p={6}` (3 instances)
- `InterestsSection` (InterestsForm): `Box bg="bg.subtle" borderRadius="md" borderWidth="1px" borderColor="border.subtle" p={6}`
- `GeneralSection`: `Box bg="bg.panel" borderRadius="lg" borderWidth="1px" borderColor="border.subtle" p={5}`

Note: `bg.subtle` and `bg.panel` are different tokens. The panel card wrapper should accept a `variant` or expose the bg token. Simplest approach: default to `bg.subtle`, allow override via standard Chakra style props (spread via `...rest`).

**Target API:**
```typescript
// components/settings/SettingsPanel.tsx
interface SettingsPanelProps extends BoxProps {
  children: React.ReactNode;
}

export function SettingsPanel({ children, ...rest }: SettingsPanelProps) {
  return (
    <Box
      bg="bg.subtle"
      borderRadius="md"
      borderWidth="1px"
      borderColor="border.subtle"
      p={6}
      {...rest}
    >
      {children}
    </Box>
  );
}
```

Usage: `<SettingsPanel>` for standard panels, `<SettingsPanel bg="bg.panel" borderRadius="lg" p={5}>` for the GeneralSection variant. This keeps the component simple while handling all existing variants.

### Pattern 5: EmptyState Shared Component

**What:** Chakra UI v3 has a built-in `EmptyState` component. The project's existing inline empty states are custom `Flex` layouts. Use Chakra's `EmptyState.*` compound components directly — do NOT create a bespoke wrapper.

**Chakra EmptyState API (verified via MCP):**
```tsx
import { EmptyState, VStack } from "@chakra-ui/react";

<EmptyState.Root>
  <EmptyState.Content>
    <EmptyState.Indicator>
      <LuTag size={40} />
    </EmptyState.Indicator>
    <VStack textAlign="center">
      <EmptyState.Title>No categories yet</EmptyState.Title>
      <EmptyState.Description>
        Categories appear here once articles are scored
      </EmptyState.Description>
    </VStack>
    {/* Optional: action button as children */}
  </EmptyState.Content>
</EmptyState.Root>
```

**Important:** `EmptyState.Root` supports `size` prop ("sm" | "md" | "lg"). No `py={16}` needed — the component handles spacing internally.

**Existing inline empty states to migrate:**
1. CategoriesSection — `LuTag` icon, 1-line description, no action
2. FeedsSection — `LuRss` icon, 2-line description, "Add Feed" button action
3. OllamaSection disconnected state — `LuServerOff` icon, 2-line description, no action button
4. FeedbackPlaceholder — `LuMessageSquare` icon, description, no action

**Decision:** Use `EmptyState.*` primitives directly in each component (not a further wrapper). The Chakra primitives are clean enough. A wrapper would only save ~2 lines per usage and adds an indirection layer.

### Pattern 6: SettingsPageHeader Shared Component

**What:** A `"use client"` component that standardises the `Flex` header row at the top of each settings section. All sections currently have slightly different patterns (fontSize inconsistencies, different spacing).

**Current patterns per section:**
- General: `<Text fontSize="lg" fontWeight="semibold">General</Text>` — wrong size (should be "xl"), no right content
- Feeds: `<Flex><Text fontSize="lg">Feeds</Text><Button>Add Feed</Button></Flex>` — wrong size, button on right
- Interests: `<Text fontSize="xl" fontWeight="semibold">Interest Preferences</Text>` — correct size, no right content
- Categories: `<Flex><Text fontSize="xl">Topic Categories</Text><Badge>{newCount} new</Badge> ... <CreateCategoryPopover /></Flex>` — correct size, badge + popover on right
- Ollama: `<Flex><Text fontSize="xl">Ollama</Text><OllamaHealthBadge /></Flex>` — correct size, badge on right
- Feedback (FeedbackPlaceholder): `<Text fontSize="lg" fontWeight="semibold">Feedback</Text>` — wrong size, no right content

**Target API:**
```typescript
// components/settings/SettingsPageHeader.tsx
// "use client" — children may contain interactive elements

interface SettingsPageHeaderProps {
  title: string;
  titleBadge?: React.ReactNode;   // optional badge next to title (e.g. "N new" badge in Categories)
  children?: React.ReactNode;     // optional right-side content (buttons, badges, popovers)
}

export function SettingsPageHeader({ title, titleBadge, children }: SettingsPageHeaderProps) {
  return (
    <Flex alignItems="center" gap={2}>
      <Text fontSize="xl" fontWeight="semibold">
        {title}
      </Text>
      {titleBadge}
      {children && <Box flex={1} />}
      {children}
    </Flex>
  );
}
```

**Usage examples:**
```tsx
// General (no right content, title only):
<SettingsPageHeader title="General" />

// Feeds (button on right):
<SettingsPageHeader title="Feeds">
  <Button colorPalette="accent" size="sm" onClick={...}>Add Feed</Button>
</SettingsPageHeader>

// Categories (badge + popover):
<SettingsPageHeader
  title="Topic Categories"
  titleBadge={newCount > 0 ? <Badge colorPalette="accent" size="sm">{newCount} new</Badge> : undefined}
>
  <CreateCategoryPopover ... />
</SettingsPageHeader>

// Ollama (health badge on right):
<SettingsPageHeader title="Ollama">
  <OllamaHealthBadge health={health} isLoading={healthLoading} />
</SettingsPageHeader>
```

**Note:** FeedbackPlaceholder currently renders as the full section content (an EmptyState replacing the whole page). When migrated to use EmptyState components, the section page (`feedback/page.tsx`) still imports it. The Feedback section does not have a conventional header since it shows only an EmptyState — the EmptyState.Title takes the place of a header. SettingsPageHeader is not applied to FeedbackPlaceholder.

### Pattern 7: SETTINGS_SECTIONS Shared Array

**What:** Both SettingsSidebar and SettingsMobileNav define their own section arrays independently. These must be unified.

**Current state:**
- `SettingsSidebar`: `SIDEBAR_ITEMS: SidebarItem[]` array with 6 items (id, href, icon, label) — includes "general"
- `SettingsMobileNav`: `SECTIONS` array with 5 items (value, label) — missing "general", no icons

**Target — add to `lib/constants.ts`:**
```typescript
import { LuSettings, LuRss, LuHeart, LuTag, LuBot, LuMessageSquare } from "react-icons/lu";

export type SettingsSection = "general" | "feeds" | "interests" | "categories" | "ollama" | "feedback";

export interface SettingsSectionItem {
  id: SettingsSection;
  href: string;
  icon: React.ElementType;
  label: string;
}

export const SETTINGS_SECTIONS: SettingsSectionItem[] = [
  { id: "general",    href: "/settings/general",    icon: LuSettings,      label: "General" },
  { id: "feeds",      href: "/settings/feeds",       icon: LuRss,           label: "Feeds" },
  { id: "interests",  href: "/settings/interests",   icon: LuHeart,         label: "Interests" },
  { id: "categories", href: "/settings/categories",  icon: LuTag,           label: "Categories" },
  { id: "ollama",     href: "/settings/ollama",      icon: LuBot,           label: "Ollama" },
  { id: "feedback",   href: "/settings/feedback",    icon: LuMessageSquare, label: "Feedback" },
];
```

`SettingsSidebar` removes its local `SIDEBAR_ITEMS` and `SettingsSection` type, imports from `lib/constants.ts`.
`SettingsMobileNav` removes its local `SECTIONS`, imports `SETTINGS_SECTIONS`, gains "general" item automatically.

**Note on icon import in constants.ts:** react-icons imports in `lib/constants.ts` are fine — this is a client-side module. The constants file is already imported by client components.

### Pattern 8: SettingsMobileNav with Chakra Select

**What:** Replace `NativeSelect` with `Select.Root/Control/Trigger/...` pattern. The goal is icon parity with desktop sidebar.

**Key challenge:** The icon for the selected item must appear in the trigger (not just in the dropdown). This requires custom `Select.ValueText` rendering using `Select.Context` or `useSelectContext`.

**Verified Chakra v3 Select API for custom value display:**
```tsx
// Source: Chakra UI MCP — select-with-avatar example
import { Select, Portal, createListCollection, useSelectContext } from "@chakra-ui/react";

// Custom value renderer that shows icon + label in trigger
const SectionValueText = () => {
  const select = useSelectContext();
  const items = select.selectedItems as SettingsSectionItem[];
  if (items.length === 0) return null;
  const item = items[0];
  const Icon = item.icon;
  return (
    <Select.ValueText>
      <Flex alignItems="center" gap={2}>
        <Icon size={16} />
        <Text>{item.label}</Text>
      </Flex>
    </Select.ValueText>
  );
};
```

**Full SettingsMobileNav pattern:**
```tsx
"use client";

import { usePathname, useRouter } from "next/navigation";
import { Select, Portal, createListCollection, Flex, Text } from "@chakra-ui/react";
import { SETTINGS_SECTIONS } from "@/lib/constants";

const sectionsCollection = createListCollection({
  items: SETTINGS_SECTIONS,
  itemToString: (item) => item.label,
  itemToValue: (item) => item.id,
});

export function SettingsMobileNav() {
  const pathname = usePathname();
  const router = useRouter();
  const activeSection = pathname.split("/").pop() ?? "feeds";

  return (
    <Select.Root
      collection={sectionsCollection}
      size="sm"
      value={[activeSection]}
      onValueChange={(details) => {
        const section = SETTINGS_SECTIONS.find(s => s.id === details.value[0]);
        if (section) router.push(section.href);
      }}
      positioning={{ sameWidth: true }}
    >
      <Select.HiddenSelect />
      <Select.Control>
        <Select.Trigger>
          <SectionValueText />
        </Select.Trigger>
        <Select.IndicatorGroup>
          <Select.Indicator />
        </Select.IndicatorGroup>
      </Select.Control>
      <Portal>
        <Select.Positioner>
          <Select.Content>
            {SETTINGS_SECTIONS.map((section) => {
              const Icon = section.icon;
              return (
                <Select.Item key={section.id} item={section}>
                  <Flex alignItems="center" gap={2}>
                    <Icon size={16} />
                    <Text>{section.label}</Text>
                  </Flex>
                  <Select.ItemIndicator />
                </Select.Item>
              );
            })}
          </Select.Content>
        </Select.Positioner>
      </Portal>
    </Select.Root>
  );
}
```

**Note:** `SectionValueText` co-located in `SettingsMobileNav.tsx` as it is a single-consumer sub-component. No separate file.

### Pattern 9: ModelManagement — ConfirmDialog Replacement

**What:** Replace the inline `Dialog.Root` block (lines 328–361 in ModelManagement.tsx) with `ConfirmDialog`.

**Also required per locked decision:** When deleting a model that is currently selected (in either categorization or scoring config), show a ConfirmDialog warning the user that deletion will revert the selector. If confirmed: delete the model, then call `onConfigChange` with the selected model removed.

**Current state:** `deleteTarget` state (`string | null`) + inline `Dialog.Root`. `canDelete` prop currently prevents deletion of active models entirely.

**New state shape:**
```typescript
const [deleteTarget, setDeleteTarget] = useState<string | null>(null);
// deleteTarget is set for both active and non-active models
// dialog body message differs based on whether the model is active
```

**New onConfirm handler:**
```typescript
const handleDeleteConfirm = useCallback(async () => {
  if (!deleteTarget) return;
  const isActive = activeModels.has(deleteTarget);
  try {
    await deleteOllamaModel(deleteTarget);
    queryClient.invalidateQueries({ queryKey: queryKeys.ollama.models });
    if (isActive && config) {
      // Revert config — null out any fields that matched the deleted model
      const nextConfig = { ...config };
      if (nextConfig.categorization_model === deleteTarget) nextConfig.categorization_model = null;
      if (nextConfig.scoring_model === deleteTarget) nextConfig.scoring_model = null;
      onConfigChange(nextConfig);
    }
    toaster.create({ title: `Deleted ${deleteTarget}`, type: "success" });
  } catch {
    toaster.create({ title: `Failed to delete ${deleteTarget}`, type: "error" });
  }
  setDeleteTarget(null);
}, [deleteTarget, activeModels, config, queryClient, onConfigChange]);
```

**This requires adding `onConfigChange` as a prop to ModelManagement.** Currently it receives `config` but not `onConfigChange`. ModelManagement's parent (OllamaSection) already has `handleConfigChange` — just wire it through.

**Updated ModelManagement prop interface:**
```typescript
interface ModelManagementProps {
  models: OllamaModel[];
  config: OllamaConfig | undefined;
  pullHook: ReturnType<typeof useModelPull>;
  onConfigChange: (config: OllamaConfig) => void;  // NEW
}
```

**ConfirmDialog usage:**
```tsx
<ConfirmDialog
  open={!!deleteTarget}
  onOpenChange={(d) => { if (!d.open) setDeleteTarget(null); }}
  title="Delete Model"
  body={
    <Text>
      Delete <strong>{deleteTarget}</strong>?{" "}
      {activeModels.has(deleteTarget ?? "") && "This model is currently selected — it will be deselected. "}
      You can re-download it later.
    </Text>
  }
  confirmLabel="Delete"
  confirmColorPalette="red"
  onConfirm={handleDeleteConfirm}
/>
```

**Unlock the "Remove" button:** The `canDelete` prop currently prevents clicking remove on active models. Since the user decision now allows deletion of active models (with a warning), the button should always be enabled. Remove the `canDelete` guard. The dialog warns the user instead.

### Pattern 10: ModelSelector — Remove Progress Bars

**What:** Remove all 3 inline progress bar blocks from ModelSelector. The selector becomes a pure "pick what's available" component.

**Lines to remove from ModelSelector.tsx:**
- The `useQuery` for downloadStatus (lines 102–110) — no longer needed
- The `downloadingModel` and `downloadPct` derived values (lines 106–111)
- All 3 inline progress bar `<Box>` blocks (after categorization dropdown, after scoring dropdown, after single model dropdown)

**Simplification benefit:** ModelSelector loses its only reason for knowing about download status. The `useQuery` import and `fetchDownloadStatus` import can be removed from this file. `DownloadStatus` type import can be removed.

**No regressions:** The `ModelPullProgress` component is still used in `ModelManagement.tsx` and the download progress is still fully visible there. The sidebar download indicator (SettingsSidebar) also shows download status. Users see download progress in the right places — ModelSelector just becomes cleaner.

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead |
|---------|-------------|-------------|
| Empty state UI | Custom `Flex` centered layout | `EmptyState.Root/.Content/.Indicator/.Title/.Description` from Chakra UI v3 |
| Custom select with icons | Custom dropdown or NativeSelect | `Select.Root` + `useSelectContext` for custom value display |
| Confirmation dialog | Inline `Dialog.Root` blocks | `ConfirmDialog` from `@/components/ui/confirm-dialog` |

---

## Common Pitfalls

### Pitfall 1: Breaking React.memo with Context

**What goes wrong:** Row components (CategoryChildRow, CategoryParentRow, CategoryUngroupedRow) are wrapped in `React.memo`. Adding context consumption does NOT break memo — memo only checks the explicitly passed props. Context changes cause re-renders regardless of memo, but that is correct behavior: when an action callback changes, all rows should re-render.

**How to avoid:** Keep the action callbacks in context stable by wrapping them in `useCallback` in CategoriesSection. The context value object itself should be memoized with `useMemo` to prevent re-renders from a new object reference on every CategoriesSection render:

```typescript
const contextValue = useMemo<CategoryTreeContextValue>(() => ({
  onWeightChange: handleWeightChange,
  onResetWeight: handleResetWeight,
  onHide: handleHideCategory,
  onBadgeDismiss: handleBadgeDismiss,
  onRename: handleRenameCategory,
  onDelete: handleDeleteCategory,
  onUngroup: handleUngroupParent,
  selectedIds,
  onToggleSelection: toggleSelection,
  newCategoryIds,
}), [
  handleWeightChange, handleResetWeight, handleHideCategory, handleBadgeDismiss,
  handleRenameCategory, handleDeleteCategory, handleUngroupParent,
  selectedIds, toggleSelection, newCategoryIds,
]);
```

Without the `useMemo`, every render of CategoriesSection creates a new object reference, causing all context consumers to re-render even if their callbacks haven't changed.

### Pitfall 2: useSelectContext Must Be Inside Select.Root

**What goes wrong:** `useSelectContext()` from Chakra UI throws if called outside a `Select.Root` tree.

**How to avoid:** `SectionValueText` (the custom value renderer) must be defined as a component and rendered INSIDE `Select.Root`. It should NOT be extracted to a separate file where it might accidentally be used outside context. Co-locate it inside `SettingsMobileNav.tsx`.

### Pitfall 3: Modal Focus Trap vs Select Dropdown

**What goes wrong:** Chakra UI Select dropdowns opened from inside a dialog may not position correctly or trap focus incorrectly.

**Not applicable here:** The SettingsMobileNav Select is standalone (not inside a dialog), so this is not a risk for this phase.

### Pitfall 4: onConfigChange Prop Propagation in ModelManagement

**What goes wrong:** ModelManagement currently does not receive `onConfigChange`. Adding it requires updating the prop interface in ModelManagement.tsx AND the usage site in OllamaSection.tsx.

**How to avoid:** The planner should include updating OllamaSection to pass `onConfigChange={handleConfigChange}` to ModelManagement as an explicit task step.

### Pitfall 5: EmptyState Component Not in @/components/ui/

**What goes wrong:** The project has a `components/ui/` directory for Chakra wrapper compositions. The EmptyState component is used from Chakra directly (`EmptyState` from `@chakra-ui/react`), not from a project wrapper. Imports must reference Chakra directly.

**How to avoid:** Import `EmptyState` from `@chakra-ui/react`, not from `@/components/ui/`. Chakra v3's EmptyState is a first-class component, no snippet composition needed.

### Pitfall 6: SettingsPanel bg Token Consistency

**What goes wrong:** GeneralSection uses `bg="bg.panel"` while other sections use `bg="bg.subtle"`. These are different semantic tokens with different visual meanings. SettingsPanel must not silently force all panels to `bg.subtle`.

**How to avoid:** SettingsPanel defaults to `bg="bg.subtle"` but accepts `...rest` props including `bg`. GeneralSection uses `<SettingsPanel bg="bg.panel" borderRadius="lg" p={5}>`.

---

## Code Examples

### CategoryTreeContext Provider setup in CategoriesSection

```typescript
// In CategoriesSection, after creating all handlers:
const contextValue = useMemo<CategoryTreeContextValue>(() => ({
  onWeightChange: handleWeightChange,
  onResetWeight: handleResetWeight,
  onHide: handleHideCategory,
  onBadgeDismiss: handleBadgeDismiss,
  onRename: handleRenameCategory,
  onDelete: handleDeleteCategory,
  onUngroup: handleUngroupParent,
  selectedIds,
  onToggleSelection: toggleSelection,
  newCategoryIds,
}), [/* all stable handlers + selectedIds + newCategoryIds */]);

return (
  <CategoryTreeContext.Provider value={contextValue}>
    <Stack as="section" ...>
      ...
      <CategoryTree
        parents={filteredParents}
        childrenMap={filteredChildrenMap}
        ungroupedCategories={filteredUngrouped}
        expandedParents={expandedParents}
        onToggleParent={toggleParent}
      />
      ...
    </Stack>
  </CategoryTreeContext.Provider>
);
```

### CategoryChildRow after context migration

```typescript
const CategoryChildRowComponent = ({
  category,
  weight,
  isOverridden,
  parentWeight,  // still needed for reset display logic
}: CategoryChildRowProps) => {
  const { onWeightChange, onResetWeight, onHide, onBadgeDismiss, onRename, onDelete, selectedIds, onToggleSelection, newCategoryIds } =
    useCategoryTreeContext();

  const isNew = newCategoryIds.has(category.id);
  const isSelected = selectedIds.has(category.id);

  const handleRename = useCallback((newName: string) => onRename(category.id, newName), [category.id, onRename]);
  // ... other id-bound handlers
};
```

### Chakra EmptyState replacing inline empty states

```tsx
// Before (in CategoriesSection):
<Flex direction="column" alignItems="center" justifyContent="center" gap={4} p={8}
      bg="bg.subtle" borderRadius="md" borderWidth="1px" borderColor="border.subtle">
  <Box color="fg.subtle"><LuTag size={40} /></Box>
  <Text color="fg.muted" textAlign="center">
    Categories will appear here once articles are scored by the LLM
  </Text>
</Flex>

// After:
import { EmptyState, VStack } from "@chakra-ui/react";

<EmptyState.Root>
  <EmptyState.Content>
    <EmptyState.Indicator>
      <Box color="fg.subtle"><LuTag size={40} /></Box>
    </EmptyState.Indicator>
    <EmptyState.Description>
      Categories will appear here once articles are scored by the LLM
    </EmptyState.Description>
  </EmptyState.Content>
</EmptyState.Root>
```

### SettingsPanel replacing inline card wrappers

```tsx
// Before (OllamaSection):
<Box bg="bg.subtle" borderRadius="md" borderWidth="1px" borderColor="border.subtle" p={6}>
  <Text fontSize="lg" fontWeight="semibold" mb={4}>Model Configuration</Text>
  ...
</Box>

// After:
<SettingsPanel>
  <Text fontSize="lg" fontWeight="semibold" mb={4}>Model Configuration</Text>
  ...
</SettingsPanel>
```

---

## File Impact Map

### Plan 01 — Shared Layout Primitives (Themes A + D)

| File | Change |
|------|--------|
| `components/settings/SettingsPanel.tsx` | CREATE — new shared component |
| `components/settings/SettingsPageHeader.tsx` | CREATE — new shared component |
| `components/settings/OllamaSection.tsx` | Replace 3 inline card Boxes with SettingsPanel; replace header Flex with SettingsPageHeader |
| `components/settings/InterestsSection.tsx` | Replace inline card Box with SettingsPanel; replace header Text with SettingsPageHeader |
| `components/settings/GeneralSection.tsx` | Replace inline card Box with SettingsPanel (bg/radius override); replace header Text with SettingsPageHeader |
| `components/settings/FeedsSection.tsx` | Replace empty state Flex with EmptyState; replace header Flex with SettingsPageHeader |
| `components/settings/CategoriesSection.tsx` | Replace empty state Flex with EmptyState; replace header Flex with SettingsPageHeader |
| `components/settings/FeedbackPlaceholder.tsx` | Replace custom Flex with EmptyState (no SettingsPageHeader — no conventional header) |
| `components/settings/OllamaPlaceholder.tsx` | DELETE — confirmed dead code |

### Plan 02 — Category Section Decomposition (Theme B)

| File | Change |
|------|--------|
| `hooks/useCategoryTree.ts` | CREATE — extracted hook |
| `hooks/useCategoryDialogs.ts` | CREATE — extracted hook |
| `contexts/CategoryTreeContext.ts` (or co-located) | CREATE — context + hook |
| `components/settings/CategoriesSection.tsx` | Consume hooks + provide context; ~491 → ~200 lines |
| `components/settings/CategoryTree.tsx` | Props reduced from 15 to ~5; reads context internally for dismissed-children handler |
| `components/settings/CategoryChildRow.tsx` | Props reduced from 12 to ~4; consumes context |
| `components/settings/CategoryParentRow.tsx` | Props reduced; consume context for ungroup/delete/hide |
| `components/settings/CategoryUngroupedRow.tsx` | Props reduced; consume context |

### Plan 03 — Ollama Cleanup + Nav/Consistency Fixes (Themes C + E)

| File | Change |
|------|--------|
| `lib/constants.ts` | ADD — SETTINGS_SECTIONS array, SettingsSection type, SettingsSectionItem interface |
| `components/settings/SettingsSidebar.tsx` | Remove local SIDEBAR_ITEMS + SettingsSection type; import from constants |
| `components/settings/SettingsMobileNav.tsx` | Replace NativeSelect with Select.Root; import SETTINGS_SECTIONS; add "general" |
| `components/settings/ModelManagement.tsx` | Replace Dialog.Root with ConfirmDialog; add onConfigChange prop; enable Remove button for active models |
| `components/settings/ModelSelector.tsx` | Remove 3 progress bar blocks + downloadStatus query |
| `components/settings/OllamaSection.tsx` | Pass onConfigChange to ModelManagement |

---

## Open Questions

1. **Context file location**
   - What we know: Project convention for cross-component state is custom hooks in `hooks/`. There is no `contexts/` directory currently.
   - What's unclear: Where to place `CategoryTreeContext` — a new `contexts/` dir, inside `hooks/`, or co-located in CategoriesSection file.
   - Recommendation: Co-locate in CategoriesSection.tsx initially (it has one consumer: CategoriesSection). If it gains more consumers in future, extract. Rule: "No abstractions for single-use code."

2. **useCategoryDialogs dependency design**
   - What we know: The hook needs access to mutation objects, selectedIds, and clearSelection to implement handlers internally.
   - What's unclear: Whether to pass raw mutation objects or just their `.mutate` functions.
   - Recommendation: Pass `.mutate` stable references only (per project rules: "use `mutation.mutate` not `mutation`"). Type them explicitly.

3. **CategoryParentRow: onDismissNewChildren in context vs computed locally**
   - What we know: Currently `onDismissNewChildren` is passed from CategoriesSection → CategoryTree → CategoryParentRow. With context, `onBadgeDismiss` is in context.
   - Recommendation: Move computation into CategoryTree: `const handleDismissNewChildren = () => children.filter(c => ctx.newCategoryIds.has(c.id)).map(c => c.id).forEach(id => ctx.onBadgeDismiss(id))`. Pass as local prop to CategoryParentRow. This keeps CategoryParentRow simple and avoids it needing to know about newCategoryIds.

---

## Sources

### Primary (HIGH confidence)

- Chakra UI MCP (`mcp__chakra-ui__get_component_example`, `mcp__chakra-ui__get_component_props`) — EmptyState API, Select API, useSelectContext pattern verified
- Direct codebase inspection — all existing component files read and measured
- Phase 09.3 FINDINGS.md — complete audit with line counts, prop counts, pattern inventory

### Secondary (MEDIUM confidence)

- React docs (training data, patterns verified against project's existing context usage in `CategoryTreeContext` patterns from STATE.md decisions)

---

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH — no new libraries; all Chakra primitives verified via MCP
- Architecture (hook/context patterns): HIGH — patterns are well-established React, verified against project's own skill files
- Pitfalls: HIGH — all identified from codebase inspection + project rules, not speculation
- Chakra EmptyState API: HIGH — verified via MCP tool
- Chakra Select + useSelectContext: HIGH — verified via MCP tool

**Research date:** 2026-02-22
**Valid until:** Stable — no time-sensitive API information
