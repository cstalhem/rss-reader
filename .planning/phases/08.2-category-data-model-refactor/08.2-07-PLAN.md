---
phase: 08.2-category-data-model-refactor
plan: 07
type: execute
wave: 2
depends_on: [06]
files_modified:
  - frontend/src/components/settings/CategoryChildRow.tsx
  - frontend/src/components/settings/CategoriesSection.tsx
  - frontend/src/components/article/ArticleReader.tsx
  - frontend/src/components/article/TagChip.tsx
autonomous: true
gap_closure: true
requirements: [CATGRP-02, CATGRP-05]

must_haves:
  truths:
    - "Dragging a child category to the ungroup zone moves it to root level"
    - "Clicking a weight preset on a tag chip in the article reader changes the category weight and the chip updates"
  artifacts:
    - path: "frontend/src/components/settings/CategoryChildRow.tsx"
      provides: "Droppable disabled when this row is being dragged (prevents self-intercept)"
    - path: "frontend/src/components/settings/CategoriesSection.tsx"
      provides: "handleDragEnd correctly processes ungroup-zone drops without self-match early return"
    - path: "frontend/src/components/article/TagChip.tsx"
      provides: "Single event handler path for weight selection (no double-fire)"
    - path: "frontend/src/components/article/ArticleReader.tsx"
      provides: "Weight mutation with optimistic article update or proper refetch feedback"
  key_links:
    - from: "CategoryChildRow useDroppable"
      to: "CategoriesSection handleDragEnd"
      via: "dnd-kit over detection"
      pattern: "disabled.*isDragging"
    - from: "TagChip Menu.Root onSelect"
      to: "ArticleReader updateCategoryWeightMutation"
      via: "onWeightChange callback"
      pattern: "onWeightChange.*weight"
---

<objective>
Fix two UAT-reported gaps: (1) DnD ungroup not working because the dragged child's own droppable intercepts the drop, and (2) article reader tag chip weight change having no visible effect.

Purpose: Ungroup via drag-and-drop and in-reader weight changes are core category management interactions. Both are completely broken.
Output: Working DnD ungroup and immediate visual feedback for weight changes in the article reader.
</objective>

<execution_context>
@./.claude/agents/gsd-executor.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08.2-category-data-model-refactor/08.2-05-SUMMARY.md
@.planning/phases/08.2-category-data-model-refactor/08.2-06-SUMMARY.md
@.planning/phases/08.2-category-data-model-refactor/08.2-UAT.md

Key files:
@frontend/src/components/settings/CategoryChildRow.tsx
@frontend/src/components/settings/CategoriesSection.tsx
@frontend/src/components/article/ArticleReader.tsx
@frontend/src/components/article/TagChip.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix DnD ungroup by disabling droppable on the dragged item</name>
  <files>
    frontend/src/components/settings/CategoryChildRow.tsx
    frontend/src/components/settings/CategoriesSection.tsx
  </files>
  <action>
**Root cause:** CategoryChildRow has a `useDroppable` with id `drop:${category.id}`. When this row is being dragged, its droppable is still active. If the user drags the child over the ungroup zone, dnd-kit detects the child's OWN droppable as the nearest "over" target (since it follows the cursor). The result: `rawOverId = "drop:<id>"`, which after prefix stripping becomes the category's own ID, matching `draggedIdStr` and triggering the early return at line 166 of CategoriesSection.

**Fix in CategoryChildRow.tsx:**

The component needs to know if IT is currently being dragged, and disable its droppable when it is. The `useSortable` hook already provides `isDragging`. Pass this to the `useDroppable` disabled prop:

Change line 58-62:
```typescript
const { setNodeRef: setDroppableRef, isOver } = useDroppable({
  id: `drop:${category.id}`,
  data: { type: "category", categoryId: category.id },
  disabled: !isDndEnabled || isDragging,  // <-- add isDragging
});
```

This ensures that when a child row is being dragged, its own droppable doesn't intercept drops intended for other targets (like the ungroup zone).

**Verify in CategoriesSection.tsx:**

Review `handleDragEnd` (lines 147-203) to confirm the logic correctly handles `ungroup-zone` drops. The flow should be:
1. `rawOverId = "ungroup-zone"` (since dragged item's droppable is now disabled)
2. `overId = "ungroup-zone"` (no `drop:` prefix to strip)
3. Hits the `overId === "ungroup-zone"` branch at line 171
4. Sets `destParentId = null`
5. Calls `updateCategory(draggedCat.id, { parent_id: -1 })`

This should work correctly once the droppable self-intercept is fixed. No changes needed in CategoriesSection.tsx if the flow above is correct. Only modify CategoriesSection.tsx if review reveals additional issues.
  </action>
  <verify>
1. `cd /Users/cstalhem/projects/rss-reader/frontend && npx tsc --noEmit` passes
2. Read CategoryChildRow.tsx to confirm `useDroppable` has `disabled: !isDndEnabled || isDragging`
3. Read CategoriesSection.tsx handleDragEnd to confirm ungroup-zone path is correct
  </verify>
  <done>
CategoryChildRow's droppable is disabled when the row is being dragged. Dragging a child to the ungroup zone now correctly detects "ungroup-zone" as the over target and calls updateCategory with parent_id: -1.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix article reader weight change and TagChip double-fire</name>
  <files>
    frontend/src/components/article/TagChip.tsx
    frontend/src/components/article/ArticleReader.tsx
  </files>
  <action>
**Root cause (TagChip):** TagChip has TWO event paths that both call `onWeightChange`:
1. `Menu.Root onSelect` (line 67-69) calls `onWeightChange?.(details.value)`
2. `Menu.RadioItemGroup onValueChange` (line 84-86) calls `onWeightChange?.(details.value)`

When a user clicks a radio item, BOTH handlers fire, causing the mutation to execute twice. The second call may arrive while the first is still processing, potentially causing issues.

**Fix in TagChip.tsx:** Remove the `onSelect` handler from `Menu.Root` and keep only the `onValueChange` on `RadioItemGroup`. This is the more appropriate handler since we're using radio items (only one can be selected).

Change:
```tsx
<Menu.Root
  onSelect={(details) => {
    onWeightChange?.(details.value);
  }}
>
```
To:
```tsx
<Menu.Root>
```

Keep the `RadioItemGroup onValueChange` handler unchanged -- it correctly fires once per selection.

**Root cause (ArticleReader):** Even after fixing the double-fire, the user won't see immediate visual feedback because:
- The article drawer renders category data from the `article` prop passed by the parent
- The parent gets this from the articles query
- The mutation invalidates `['articles']`, but the refetch + parent re-render takes time
- There's no optimistic update on the article's embedded categories

**Fix in ArticleReader.tsx:** Add a simple optimistic local state for category weights. After the mutation fires successfully, the articles query will refetch and update the parent, which re-renders the drawer with fresh data.

However, the simplest approach that gives immediate feedback: after calling the mutation, also invalidate `['categories', 'new-count']` (for badge consistency), and ensure the mutation's `onSettled` triggers article refetch quickly. The key issue is whether the user sees the weight change reflected on the TagChip.

Actually, the TagChip renders `currentWeight` which comes from `cat.effective_weight` on the article's embedded category. This won't update until the articles query refetches. For immediate feedback, modify ArticleReader to use local optimistic state:

Add local state to track optimistic weight overrides:
```typescript
const [optimisticWeights, setOptimisticWeights] = useState<Record<number, string>>({});

// Reset optimistic state when article changes
useEffect(() => {
  setOptimisticWeights({});
}, [article?.id]);
```

When rendering TagChip, use the optimistic weight if available:
```tsx
<TagChip
  key={cat.id}
  label={cat.display_name}
  size="md"
  interactive={true}
  currentWeight={optimisticWeights[cat.id] ?? cat.effective_weight}
  onWeightChange={(weight) => {
    setOptimisticWeights(prev => ({ ...prev, [cat.id]: weight }));
    updateCategoryWeightMutation.mutate({ categoryId: cat.id, weight });
  }}
/>
```

This gives instant visual feedback. When the articles query refetches (triggered by onSettled), the parent re-renders with server data and the optimistic state is harmless (same value).

Also add `['categories', 'new-count']` invalidation to the mutation's onSuccess for badge consistency.
  </action>
  <verify>
1. `cd /Users/cstalhem/projects/rss-reader/frontend && npx tsc --noEmit` passes
2. Read TagChip.tsx to confirm Menu.Root has no onSelect handler
3. Read ArticleReader.tsx to confirm optimistic weight state and new-count invalidation
4. `cd /Users/cstalhem/projects/rss-reader/frontend && bun run build` succeeds
  </verify>
  <done>
TagChip fires onWeightChange exactly once per selection (via RadioItemGroup only). ArticleReader shows immediate weight change via local optimistic state. Mutation invalidates categories, articles, and new-count queries.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles with zero errors
2. Production build succeeds
3. CategoryChildRow droppable disabled when isDragging
4. TagChip Menu.Root has no onSelect handler
5. ArticleReader uses optimistic local state for weight display
6. ArticleReader mutation invalidates new-count query
</verification>

<success_criteria>
- Dragging a child to the ungroup zone calls updateCategory with parent_id: -1
- Article reader TagChip shows new weight immediately after clicking a preset
- Weight mutation fires exactly once per click (no double-fire)
- Zero TypeScript errors, production build passes
</success_criteria>

<output>
After completion, create `.planning/phases/08.2-category-data-model-refactor/08.2-07-SUMMARY.md`
</output>
