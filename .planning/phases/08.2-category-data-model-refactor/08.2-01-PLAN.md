---
phase: 08.2-category-data-model-refactor
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/backend/models.py
  - backend/src/backend/database.py
autonomous: true
requirements: [CATGRP-01, CATGRP-03, CATGRP-04]
must_haves:
  truths:
    - "Category table exists with id, display_name, slug, parent_id, weight, is_hidden, is_seen, is_manually_created, created_at columns"
    - "ArticleCategoryLink junction table exists with composite PK (article_id, category_id) and CASCADE deletes"
    - "All existing JSON blob data is migrated to relational tables without data loss"
    - "Old JSON columns (Article.categories, UserPreferences.category_groups, UserPreferences.topic_weights) are dropped"
    - "SQLite database backup is created before migration runs"
    - "Migration is idempotent — safe to run on every startup"
  artifacts:
    - path: "backend/src/backend/models.py"
      provides: "Category model, ArticleCategoryLink model, updated Article/UserPreferences models"
      contains: "class Category"
    - path: "backend/src/backend/database.py"
      provides: "Migration functions, backup function, updated create_db_and_tables"
      contains: "def _migrate_json_to_relational"
  key_links:
    - from: "backend/src/backend/models.py"
      to: "backend/src/backend/database.py"
      via: "SQLModel metadata create_all creates tables from model definitions"
      pattern: "SQLModel.metadata.create_all"
---

<objective>
Create the Category and ArticleCategoryLink SQLModel tables, install python-slugify, and implement the idempotent data migration that converts all existing JSON blob data to relational tables, then drops the old columns.

Purpose: This is the foundation for the entire phase. All subsequent plans depend on these tables existing and containing migrated data.
Output: New database schema with Category and ArticleCategoryLink tables, migrated data, old JSON columns dropped.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08.2-category-data-model-refactor/08.2-CONTEXT.md
@.planning/phases/08.2-category-data-model-refactor/08.2-RESEARCH.md
@backend/src/backend/models.py
@backend/src/backend/database.py
@backend/src/backend/prompts.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Category and ArticleCategoryLink models, install python-slugify</name>
  <files>backend/src/backend/models.py</files>
  <action>
Install python-slugify: `cd backend && uv add python-slugify`

Add two new SQLModel table classes to models.py:

1. **ArticleCategoryLink** (link model for many-to-many):
   - `__tablename__ = "article_category_link"`
   - `article_id: int` — FK to `articles.id`, primary_key=True, ondelete="CASCADE"
   - `category_id: int` — FK to `categories.id`, primary_key=True, ondelete="CASCADE"

2. **Category** (table=True):
   - `__tablename__ = "categories"`
   - `id: int | None` — primary key
   - `display_name: str` — Field(index=True)
   - `slug: str` — Field(unique=True, index=True)
   - `parent_id: int | None` — Field(default=None, foreign_key="categories.id")
   - `weight: str | None` — Field(default=None) — NULL means inherit from parent
   - `is_hidden: bool` — Field(default=False)
   - `is_seen: bool` — Field(default=False)
   - `is_manually_created: bool` — Field(default=False)
   - `created_at: datetime` — Field(default_factory=datetime.now)
   - Relationship `articles` back to Article via ArticleCategoryLink link_model
   - Self-referential relationships `parent` and `children` using sa_relationship_kwargs with string-based remote_side and foreign_keys for the self-referential FK

3. **Update Article model**:
   - Remove the `categories: list[str] | None` JSON column field entirely
   - Add relationship `categories_rel: list["Category"]` via ArticleCategoryLink link_model with back_populates="articles"
   - Keep `model_config = {"arbitrary_types_allowed": True}`

4. **Update UserPreferences model**:
   - Remove `topic_weights` JSON column field entirely
   - Remove `category_groups` JSON column field entirely
   - Remove `model_config` since no more JSON columns need it

Important: ArticleCategoryLink must be defined BEFORE Category and Article in the file so the link_model reference resolves. Use `from __future__ import annotations` if needed for forward references, or order classes carefully.
  </action>
  <verify>
`cd backend && uv run python -c "from backend.models import Category, ArticleCategoryLink, Article, UserPreferences; print('Models imported OK')"` succeeds without errors.
  </verify>
  <done>Category and ArticleCategoryLink models defined in models.py. Article.categories JSON field removed, replaced by categories_rel relationship. UserPreferences.topic_weights and category_groups JSON fields removed. python-slugify installed.</done>
</task>

<task type="auto">
  <name>Task 2: Implement idempotent data migration with backup and column drops</name>
  <files>backend/src/backend/database.py</files>
  <action>
Rewrite database.py to add the JSON-to-relational migration. This replaces all the old category-related migration functions.

Add these functions:

1. **`_backup_database()`** — Uses `shutil.copy2` to create a timestamped backup of the SQLite .db file before migration. Extracts the db path from the engine URL. Logs the backup path. Always runs (creates new timestamped file each time, harmless).

2. **Smart casing helpers** (can be in database.py or a new utils module — keep in database.py for simplicity):
   - `SMART_CASE_MAP` dict mapping lowercase terms to their proper casing: ai->AI, ml->ML, ios->iOS, macos->macOS, imac->iMac, api->API, css->CSS, html->HTML, sql->SQL, ui->UI, ux->UX, devops->DevOps, saas->SaaS, llm->LLM, gpu->GPU, cpu->CPU, vpn->VPN
   - `smart_case(display_name: str) -> str` — check full lowercase against map first, then word-by-word with title case fallback
   - `kebab_to_display(kebab: str) -> str` — convert kebab-case to display name using smart_case

3. **`_migrate_json_to_relational()`** — The main migration function. Must be fully idempotent. Steps:

   a. **Guard: Check if migration already done** — `SELECT COUNT(*) FROM categories`. If > 0, skip data migration steps (tables already populated).

   b. **Read all existing JSON data** via raw SQL (the model fields are already removed):
      - `SELECT id, categories FROM articles WHERE categories IS NOT NULL` (if articles.categories column exists)
      - `SELECT topic_weights, category_groups FROM user_preferences LIMIT 1` (if columns exist)
      - Use `inspect(engine)` to check column existence before querying

   c. **Collect unique categories**: Iterate all article.categories JSON arrays. Also collect from category_groups children map (parents + children) and topic_weights keys. Build a set of unique kebab-case slugs.

   d. **Create Category rows**: For each unique slug:
      - `display_name` = `kebab_to_display(slug)`
      - `slug` = the kebab-case string (already URL-safe)
      - `weight` = look up in topic_weights dict, map old names (blocked->block, low->reduce, neutral->normal, medium->boost, high->max), NULL if not in topic_weights
      - `parent_id` = resolve from category_groups["children"] map (look up which parent this slug belongs to)
      - `is_hidden` = check if slug is in category_groups["hidden_categories"]
      - `is_seen` = check if slug is in category_groups["seen_categories"]
      - `is_manually_created` = check if slug is in category_groups["manually_created"]
      - Insert via raw SQL `INSERT INTO categories (display_name, slug, parent_id, weight, is_hidden, is_seen, is_manually_created, created_at)`
      - Handle parent resolution: first pass creates all categories without parent_id, second pass updates parent_id by looking up parent slugs

   e. **Create ArticleCategoryLink rows**: For each article with categories:
      - Parse JSON categories array
      - For each category string, normalize to lowercase slug, look up category_id from categories table
      - Insert `(article_id, category_id)` into article_category_link

   f. **Handle DEFAULT_CATEGORY_HIERARCHY**: If no existing data at all (fresh install), seed categories from DEFAULT_CATEGORY_HIERARCHY in prompts.py, converting to display names. Mark all as is_seen=True.

4. **`_drop_old_json_columns()`** — Drop the old columns after migration:
   - Check inspector for column existence before each DROP
   - `ALTER TABLE articles DROP COLUMN categories` (if exists)
   - `ALTER TABLE user_preferences DROP COLUMN category_groups` (if exists)
   - `ALTER TABLE user_preferences DROP COLUMN topic_weights` (if exists)

5. **Update `create_db_and_tables()`**:
   - Keep `SQLModel.metadata.create_all(engine)` (creates new tables)
   - Keep `_migrate_articles_scoring_columns()` and `_recover_stuck_scoring()`
   - Keep `_migrate_ollama_config_columns()`
   - Add `_backup_database()` BEFORE migration
   - Add `_migrate_json_to_relational()` AFTER table creation
   - Add `_drop_old_json_columns()` AFTER successful migration
   - REMOVE old category migration functions: `_migrate_category_groups_column`, `_migrate_weight_names`, `_migrate_groups_to_children`, `_seed_category_hierarchy`, `_seed_default_topic_weights`
   - REMOVE their calls from `create_db_and_tables()`

Important ordering in `create_db_and_tables()`:
```
SQLModel.metadata.create_all(engine)  # Creates categories + article_category_link tables
_migrate_articles_scoring_columns()    # Legacy column additions
_recover_stuck_scoring()
_migrate_ollama_config_columns()
_backup_database()                     # Backup BEFORE destructive migration
_migrate_json_to_relational()          # Migrate data from JSON to tables
_drop_old_json_columns()               # Drop old columns AFTER migration
```

Use `engine.begin()` for transactional safety within each migration step. Use `text()` for raw SQL. Use `json.loads()` for parsing JSON column values.
  </action>
  <verify>
`cd backend && uv run python -c "from backend.database import create_db_and_tables; print('Migration module OK')"` imports without error. If a test database exists, run `cd backend && uv run pytest -x` to check for import/syntax errors across the codebase (tests may fail due to removed model fields — that's expected at this stage since API endpoints haven't been updated yet).
  </verify>
  <done>Data migration from JSON blobs to Category/ArticleCategoryLink tables is implemented and idempotent. Database backup runs before migration. Old JSON columns are dropped after migration. Old migration functions removed. Fresh install seeds default category hierarchy.</done>
</task>

</tasks>

<verification>
- `cd backend && uv run python -c "from backend.models import Category, ArticleCategoryLink"` succeeds
- `cd backend && uv run python -c "from backend.database import create_db_and_tables"` succeeds
- `cd backend && uv run python -c "from slugify import slugify; print(slugify('AI & ML'))"` prints `ai-ml`
- If running against a real database with existing data, verify: `sqlite3 data/rss.db "SELECT COUNT(*) FROM categories"` returns > 0 and `sqlite3 data/rss.db ".schema articles"` no longer shows a categories column
</verification>

<success_criteria>
- Category and ArticleCategoryLink SQLModel models exist with correct fields and relationships
- python-slugify is installed
- Migration converts all JSON blob data to relational tables
- Migration is idempotent (safe to run multiple times)
- Database backup created before migration
- Old JSON columns dropped after migration
- Fresh install seeds default category hierarchy
</success_criteria>

<output>
After completion, create `.planning/phases/08.2-category-data-model-refactor/08.2-01-SUMMARY.md`
</output>
