# Phase 08.2: Category Data Model Refactor - Context

**Gathered:** 2026-02-17
**Status:** Ready for planning

<domain>
## Phase Boundary

Migrate categories from JSON blobs (Article.categories, UserPreferences.category_groups) to a proper Category table with ArticleCategoryLink junction table. Enables clean relational operations for grouping, renaming, merging, and Phase 9 feedback aggregation. Deferred from 08.1-UAT gap #10 (JSON blob surgery too fragile).

</domain>

<decisions>
## Implementation Decisions

### Category identity model
- Numeric IDs are the canonical reference across API and frontend (not name strings)
- Each category has: `id` (primary key), `display_name` (human-readable, user-editable), `slug` (auto-generated, URL-friendly)
- Slug is auto-generated from display_name: lowercase, spaces to hyphens, strip non-URL-safe chars
- Smart casing for display names: preserve known conventions (AI, iOS, macOS, etc.), user can edit freely
- LLM categorization prompt updated in this phase to output human-readable display names (not kebab-case)
- System slugifies LLM output for matching via get_or_create pattern
- LLM prompt includes existing category display names so it reuses them
- New categories created as unseen (is_seen=false) for badge/notification system
- LLM suggests a parent category for new categories based on existing hierarchy; user can reparent later
- Merge categories via "move all article associations to target, delete source" approach — no alias/synonym system
- Article counts computed via JOIN on query, no cached count column

### API response evolution
- Fixed response shapes per endpoint — no field selection, no expand/include params (single-user app, not worth the complexity)
- Articles embed rich category objects: `{id, display_name, slug, effective_weight, parent_display_name}`
- `/api/categories` returns a flat list with `parent_id` references — frontend builds the tree in `useMemo`
- Full category object on `/api/categories`: `{id, display_name, slug, weight, parent_id, is_hidden, is_seen, is_manually_created, article_count}`
- Hybrid mutation endpoints (standard REST):
  - `PATCH /api/categories/:id` — field updates (rename, reparent, weight change) via partial body
  - `DELETE /api/categories/:id` — delete a category
  - `POST /api/categories/merge` — merge action with `{source_id, target_id}`
  - `POST /api/categories` — create a new category
- Numeric IDs in URL path params — no more request-body workarounds for names with special chars

### Column transition strategy
- `Article.categories` JSON column: drop entirely after data is migrated to junction table
- `UserPreferences.category_groups` JSON blob: drop entirely after data is migrated to Category table columns
- Automatic SQLite database backup (timestamped copy of .db file) before migration runs
- Migration runs automatically on app startup, consistent with existing `database.py` ALTER TABLE pattern
- Single source of truth: all category data lives in Category table and ArticleCategoryLink junction table

### Claude's Discretion
- Exact slugification algorithm and edge case handling
- Migration script ordering and idempotency strategy
- SQLAlchemy relationship configuration and eager loading strategy
- How to handle the LLM suggesting parents for new categories (prompt engineering details)
- Smart casing dictionary for known terms (AI, iOS, etc.) — implementation approach

</decisions>

<specifics>
## Specific Ideas

- "Try to keep to name conventions if those are known (such as AI all caps, iOS, iMac, macOS, etc), but let the user modify these names as they see fit"
- LLM should generate the nice display name for new categories and reuse existing display names for known categories
- The slug is purely for URL-friendly identifiers, not for LLM matching — LLM works with display names

</specifics>

<deferred>
## Deferred Ideas

- Category aliases/synonyms for LLM matching dedup — if the LLM creates duplicates with different phrasings, address it in a future phase if it becomes a real problem
- Process note: any future phase that modifies DB models, types, or data structures should get its own discuss-phase session to surface migration and contract decisions

</deferred>

---

*Phase: 08.2-category-data-model-refactor*
*Context gathered: 2026-02-17*
