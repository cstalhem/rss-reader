# Phase 08.2: Category Data Model Refactor - Research

**Researched:** 2026-02-17
**Domain:** SQLModel data modeling, SQLite schema migration, API contract evolution
**Confidence:** HIGH

## Summary

This phase replaces two JSON blob storage patterns (Article.categories as `list[str]`, UserPreferences.category_groups as `dict`) with a proper relational model: a Category table and ArticleCategoryLink junction table. The codebase currently has ~15 API endpoints touching category data, a scoring pipeline that writes categories, and a frontend tree UI that manages parent-child relationships -- all operating on JSON blobs.

The migration is well-scoped: SQLModel 0.0.32 + SQLAlchemy 2.0.46 provide native many-to-many support via link models. SQLite 3.50.4 (bundled with Python 3.14) supports `ALTER TABLE DROP COLUMN`, enabling clean removal of the old JSON columns post-migration. The existing `database.py` startup migration pattern is the established approach for schema changes.

**Primary recommendation:** Build the new tables and migration in one plan, update the scoring pipeline second, update the API endpoints third, update frontend types/API last. Each layer can be verified independently. The migration must be idempotent (safe to run multiple times) since it executes on every startup.

<user_constraints>

## User Constraints (from CONTEXT.md)

### Locked Decisions
- Numeric IDs are the canonical reference across API and frontend (not name strings)
- Each category has: `id` (primary key), `display_name` (human-readable, user-editable), `slug` (auto-generated, URL-friendly)
- Slug is auto-generated from display_name: lowercase, spaces to hyphens, strip non-URL-safe chars
- Smart casing for display names: preserve known conventions (AI, iOS, macOS, etc.), user can edit freely
- LLM categorization prompt updated in this phase to output human-readable display names (not kebab-case)
- System slugifies LLM output for matching via get_or_create pattern
- LLM prompt includes existing category display names so it reuses them
- New categories created as unseen (is_seen=false) for badge/notification system
- LLM suggests a parent category for new categories based on existing hierarchy; user can reparent later
- Merge categories via "move all article associations to target, delete source" approach -- no alias/synonym system
- Article counts computed via JOIN on query, no cached count column
- Fixed response shapes per endpoint -- no field selection, no expand/include params
- Articles embed rich category objects: `{id, display_name, slug, effective_weight, parent_display_name}`
- `/api/categories` returns a flat list with `parent_id` references -- frontend builds the tree in `useMemo`
- Full category object: `{id, display_name, slug, weight, parent_id, is_hidden, is_seen, is_manually_created, article_count}`
- Hybrid mutation endpoints (standard REST): `PATCH /api/categories/:id`, `DELETE /api/categories/:id`, `POST /api/categories/merge`, `POST /api/categories`
- Numeric IDs in URL path params
- `Article.categories` JSON column: drop entirely after migration
- `UserPreferences.category_groups` JSON blob: drop entirely after migration
- Automatic SQLite database backup (timestamped copy of .db file) before migration runs
- Migration runs automatically on app startup
- Single source of truth: all category data in Category table and ArticleCategoryLink junction table

### Claude's Discretion
- Exact slugification algorithm and edge case handling
- Migration script ordering and idempotency strategy
- SQLAlchemy relationship configuration and eager loading strategy
- How to handle the LLM suggesting parents for new categories (prompt engineering details)
- Smart casing dictionary for known terms (AI, iOS, etc.) -- implementation approach

### Deferred Ideas (OUT OF SCOPE)
- Category aliases/synonyms for LLM matching dedup -- address in a future phase if duplicates become a real problem
- Process note: any future phase that modifies DB models, types, or data structures should get its own discuss-phase session

</user_constraints>

<phase_requirements>

## Phase Requirements

| ID | Description | Research Support |
|----|-------------|-----------------|
| CATGRP-01 | User can create named category groups | Category table with `parent_id` self-referential FK. `POST /api/categories` creates a category. Reparenting via `PATCH /api/categories/:id` with `parent_id` body field. |
| CATGRP-02 | User can drag existing categories into groups via tree UI | Frontend tree already built; this phase changes the data contract from string-based children map to ID-based flat list with parent_id. DnD logic stays in Phase 08.3. |
| CATGRP-03 | User can set a weight on a group that cascades to all child categories | `weight` column on Category table replaces `topic_weights` JSON. Cascade logic: child effective_weight = child.weight if set, else parent.weight, else "normal". |
| CATGRP-04 | User can override the cascaded weight for individual categories within a group | Same weight column per-category. Override = category has explicit weight != NULL. Reset = set weight to NULL (inherit from parent). |
| CATGRP-05 | Scoring pipeline resolves effective weight: explicit override > group default > 1.0 | `compute_composite_score()` reads from Category table relationships instead of JSON blobs. Three-tier resolution preserved, data source changes from JSON to relational. |

</phase_requirements>

## Standard Stack

### Core (already in project)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| SQLModel | 0.0.32 | ORM models, many-to-many via link_model | Already used for all models |
| SQLAlchemy | 2.0.46 | Underlying engine, relationship loading, migrations | Comes with SQLModel |
| FastAPI | 0.128.0+ | API endpoints | Already used |
| Pydantic | v2 | Request/response schemas | Already used via SQLModel |

### New Dependency
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| python-slugify | 8.x | Slug generation from display names | Needed for `display_name -> slug` conversion with unicode support |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| python-slugify | Custom regex slugify | python-slugify handles unicode, transliteration, and edge cases. Custom is simpler but misses non-ASCII handling. Given the LLM may output non-English display names, use the library. |
| selectinload | joinedload | For article->categories (many-to-many), selectinload avoids row explosion. Use joinedload only for category->parent (many-to-one). |

**Installation:**
```bash
cd backend && uv add python-slugify
```

## Architecture Patterns

### New Database Model Structure
```
tables:
  categories          # NEW: replaces category data from both JSON blobs
    id                # INTEGER PRIMARY KEY
    display_name      # TEXT NOT NULL (human-readable, e.g., "AI & ML")
    slug              # TEXT NOT NULL UNIQUE (URL-safe, e.g., "ai-ml")
    parent_id         # INTEGER FK -> categories.id (nullable, self-ref)
    weight            # TEXT (nullable -- "block"|"reduce"|"normal"|"boost"|"max", NULL = inherit)
    is_hidden         # BOOLEAN DEFAULT FALSE
    is_seen           # BOOLEAN DEFAULT FALSE (for new-badge system)
    is_manually_created # BOOLEAN DEFAULT FALSE
    created_at        # TIMESTAMP

  article_category_link  # NEW: junction table
    article_id        # INTEGER FK -> articles.id, PRIMARY KEY (part of composite)
    category_id       # INTEGER FK -> categories.id, PRIMARY KEY (part of composite)

  articles            # MODIFIED: drop categories JSON column after migration
  user_preferences    # MODIFIED: drop category_groups and topic_weights JSON columns after migration
```

### Pattern 1: SQLModel Many-to-Many with Link Model
**What:** Junction table connecting articles to categories
**When to use:** Article has 1-4 categories, category has many articles
**Example:**
```python
# Source: SQLModel official docs - many-to-many/create-models-with-link
from sqlmodel import Field, Relationship, SQLModel

class ArticleCategoryLink(SQLModel, table=True):
    __tablename__ = "article_category_link"
    article_id: int = Field(foreign_key="articles.id", primary_key=True, ondelete="CASCADE")
    category_id: int = Field(foreign_key="categories.id", primary_key=True, ondelete="CASCADE")

class Category(SQLModel, table=True):
    __tablename__ = "categories"
    id: int | None = Field(default=None, primary_key=True)
    display_name: str = Field(index=True)
    slug: str = Field(unique=True, index=True)
    parent_id: int | None = Field(default=None, foreign_key="categories.id")
    weight: str | None = Field(default=None)  # NULL = inherit from parent
    is_hidden: bool = Field(default=False)
    is_seen: bool = Field(default=False)
    is_manually_created: bool = Field(default=False)
    created_at: datetime = Field(default_factory=datetime.now)

    # Relationships
    articles: list["Article"] = Relationship(
        back_populates="categories_rel",
        link_model=ArticleCategoryLink,
    )
    parent: "Category | None" = Relationship(
        sa_relationship_kwargs={
            "remote_side": "Category.id",
            "foreign_keys": "[Category.parent_id]",
        }
    )
    children: list["Category"] = Relationship(
        sa_relationship_kwargs={
            "foreign_keys": "[Category.parent_id]",
        }
    )
```

**Note on self-referential relationships:** SQLModel's `Relationship` needs `sa_relationship_kwargs` for self-referential FKs. The `remote_side` must point to the primary key column, and `foreign_keys` must be strings (not direct references) due to forward-reference resolution.

### Pattern 2: Get-or-Create for Category Matching
**What:** Scoring pipeline looks up categories by slug, creates if missing
**When to use:** Every time the LLM assigns categories to an article
**Example:**
```python
from slugify import slugify

def get_or_create_category(session: Session, display_name: str) -> Category:
    """Find existing category by slug, or create new one."""
    slug = slugify(display_name)
    category = session.exec(
        select(Category).where(Category.slug == slug)
    ).first()
    if not category:
        category = Category(
            display_name=smart_case(display_name),
            slug=slug,
            is_seen=False,  # New categories start unseen
        )
        session.add(category)
        session.flush()  # Get ID without committing
    return category
```

### Pattern 3: Effective Weight Resolution (Relational)
**What:** Three-tier weight resolution using Category table relationships
**When to use:** Computing composite score during scoring pipeline
**Example:**
```python
def get_effective_weight(category: Category) -> str:
    """Resolve weight: explicit override > parent weight > 'normal'."""
    if category.weight is not None:
        return category.weight
    if category.parent_id is not None and category.parent is not None:
        if category.parent.weight is not None:
            return category.parent.weight
    return "normal"
```

### Pattern 4: Eager Loading Strategy for Articles
**What:** Load article categories without N+1 queries
**When to use:** `/api/articles` list endpoint
**Example:**
```python
# Source: SQLAlchemy docs - relationship loading techniques
from sqlalchemy.orm import selectinload

statement = select(Article).options(
    selectinload(Article.categories_rel)
).offset(skip).limit(limit)
```

**Use `selectinload`** for the article->categories many-to-many (avoids row explosion). Use **`joinedload`** only for category->parent single-FK lookups when loading the category list.

### Anti-Patterns to Avoid
- **Lazy loading in API responses:** SQLModel defaults to lazy loading. Without eager loading, accessing `article.categories_rel` in the serialization loop causes N+1 queries. Always use explicit `selectinload`.
- **Mutating link table directly for merge:** Don't try to update `article_category_link.category_id` for merge -- it's a composite PK. Instead, delete old links and create new ones (or use SQLAlchemy's collection operations).
- **Forgetting CASCADE on junction table FKs:** Without `ondelete="CASCADE"`, deleting an article or category leaves orphan rows in the link table.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Slug generation | Custom regex replacer | python-slugify | Handles unicode, transliteration, duplicate separators, leading/trailing cleanup |
| Database backup before migration | Custom file copy logic | `shutil.copy2(db_path, backup_path)` | Standard lib, preserves metadata, one line |
| JSON -> relational migration | Ad-hoc SQL string manipulation | SQLAlchemy `text()` with parameterized queries | Prevents SQL injection, handles types correctly |
| Composite score calculation | Duplicate logic in API and scoring | Single `get_effective_weight()` function used by both | Keep weight resolution in one place |

**Key insight:** The migration is a one-time data transformation. It must be robust but doesn't need to be elegant. Idempotent checks (table exists? data migrated?) are more important than optimization.

## Common Pitfalls

### Pitfall 1: SQLAlchemy JSON Column Mutation Detection
**What goes wrong:** After migration, if any code still mutates the old JSON columns in-place, SQLAlchemy won't detect the change and data is silently lost.
**Why it happens:** This is the existing gotcha documented in AGENTS.md. During migration, both old and new systems may coexist briefly.
**How to avoid:** Drop the old columns entirely once migration is verified. No transition period where both systems operate.
**Warning signs:** Category changes not persisting after restart.

### Pitfall 2: Self-Referential Relationship Configuration
**What goes wrong:** SQLModel/SQLAlchemy can't resolve self-referential foreign keys without explicit `remote_side` and `foreign_keys` configuration.
**Why it happens:** With `parent_id -> categories.id`, SQLAlchemy doesn't know which direction the relationship goes without hints.
**How to avoid:** Use `sa_relationship_kwargs` with string-based column references for the self-referential parent/children relationships.
**Warning signs:** `AmbiguousForeignKeysError` or `NoForeignKeysError` on startup.

### Pitfall 3: Migration Idempotency
**What goes wrong:** Migration runs on every startup. If it's not idempotent, it corrupts data on second run (duplicate categories, duplicate links).
**Why it happens:** The existing migration pattern in `database.py` uses "check if column exists, add if not" guards. The new migration needs similar guards: "check if category table has data, skip data migration if yes."
**How to avoid:** Guard each migration step: (1) check if category table exists, (2) check if data has been migrated (e.g., category count > 0 or a sentinel check), (3) check if old columns still exist before dropping.
**Warning signs:** Duplicate categories after restart, foreign key violations.

### Pitfall 4: SQLite DROP COLUMN Limitations
**What goes wrong:** SQLite's DROP COLUMN fails if the column is referenced by an index, trigger, or view.
**Why it happens:** SQLite 3.35+ supports DROP COLUMN but with restrictions.
**How to avoid:** Drop any indexes on the JSON columns first, then drop the columns. The `categories` column on articles doesn't have an explicit index. The `category_groups` and `topic_weights` columns don't either.
**Warning signs:** `ALTER TABLE DROP COLUMN` error at startup.

### Pitfall 5: Frontend Type Contract Breakage
**What goes wrong:** Frontend expects `article.categories: string[]` but backend now returns rich objects.
**Why it happens:** The API response shape changes from `string[]` to `{id, display_name, slug, effective_weight, parent_display_name}[]`.
**How to avoid:** Update the frontend `Article` type interface and all components that render categories (ArticleRow, ArticleReader, TagChip) in the same plan that changes the backend response.
**Warning signs:** Categories not rendering, runtime type errors in the browser console.

### Pitfall 6: Scoring Pipeline Race Condition During Migration
**What goes wrong:** If the scheduler runs a scoring batch while migration is in progress, it may try to write to the old JSON column that's being removed.
**Why it happens:** Migration runs at startup before the scheduler starts (good), but the migration itself is a multi-step process.
**How to avoid:** The existing startup sequence already runs `create_db_and_tables()` before `start_scheduler()` in the lifespan handler. As long as the migration completes fully in `create_db_and_tables()`, the scheduler will only see the new schema.
**Warning signs:** This should not happen given the current startup order, but verify the migration runs synchronously and completely.

## Code Examples

### Smart Casing Dictionary
```python
# Known acronyms and brand names that should preserve specific casing
SMART_CASE_MAP = {
    "ai": "AI",
    "ml": "ML",
    "ai-ml": "AI & ML",
    "ios": "iOS",
    "macos": "macOS",
    "imac": "iMac",
    "api": "API",
    "css": "CSS",
    "html": "HTML",
    "sql": "SQL",
    "ui": "UI",
    "ux": "UX",
    "devops": "DevOps",
    "saas": "SaaS",
    "llm": "LLM",
    "gpu": "GPU",
    "cpu": "CPU",
    "vpn": "VPN",
}

def smart_case(display_name: str) -> str:
    """Apply smart casing: check known terms, otherwise title-case."""
    lower = display_name.lower().strip()
    if lower in SMART_CASE_MAP:
        return SMART_CASE_MAP[lower]
    # Title case with hyphen-awareness
    return " ".join(
        SMART_CASE_MAP.get(word.lower(), word.capitalize())
        for word in display_name.replace("-", " ").split()
    )
```

### Kebab-to-Display-Name Migration
```python
def kebab_to_display(kebab: str) -> str:
    """Convert existing kebab-case category to display name.

    'ai-ml' -> 'AI & ML'
    'web-development' -> 'Web Development'
    'cybersecurity' -> 'Cybersecurity'
    """
    lower = kebab.lower().strip()
    if lower in SMART_CASE_MAP:
        return SMART_CASE_MAP[lower]
    return " ".join(
        SMART_CASE_MAP.get(word, word.capitalize())
        for word in kebab.split("-")
    )
```

### Database Backup Before Migration
```python
import shutil
from datetime import datetime
from pathlib import Path

def backup_database(db_path: str) -> str | None:
    """Create timestamped backup of SQLite database before migration."""
    db_file = Path(db_path)
    if not db_file.exists():
        return None
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_path = db_file.with_name(f"{db_file.stem}_backup_{timestamp}{db_file.suffix}")
    shutil.copy2(db_file, backup_path)
    logger.info(f"Database backup created: {backup_path}")
    return str(backup_path)
```

### Updated Categorization Prompt (Display Names)
```python
def build_categorization_prompt(
    article_title: str,
    article_text: str,
    existing_categories: list[str],  # Now display names, not kebab-case
    category_hierarchy: dict[str, list[str]] | None = None,
) -> str:
    # Key change: categories are now "AI & ML", "Web Development" etc.
    # LLM outputs human-readable names, system slugifies for matching
    prompt = f"""Categorize this article into 1-4 topic categories.

**Rules (follow strictly):**
1. ONLY categorize the article's PRIMARY topics.
2. REUSE existing categories from the list below. Strongly prefer existing categories.
3. Category names should be human-readable English (e.g., "Artificial Intelligence", "Web Development", "Open Source").
4. Do NOT use kebab-case, underscores, or slashes. Use natural English names.
5. Keep categories BROAD. Use "AI" not "AI-Assisted Programming".
6. Only suggest a new category if NO existing category covers the article's primary topic.
7. Maximum 4 categories per article. Fewer is better.
8. When suggesting a new category, suggest which existing parent it should belong under.

**Existing categories:** {", ".join(sorted(existing_categories))}
...
"""
```

### API Response Models (New)
```python
class CategoryResponse(BaseModel):
    """Category object returned by API."""
    id: int
    display_name: str
    slug: str
    weight: str | None
    parent_id: int | None
    is_hidden: bool
    is_seen: bool
    is_manually_created: bool
    article_count: int

class ArticleCategoryEmbed(BaseModel):
    """Category embedded in article response."""
    id: int
    display_name: str
    slug: str
    effective_weight: str
    parent_display_name: str | None
```

### Frontend Type Updates
```typescript
// New rich category type for article responses
export interface ArticleCategory {
  id: number;
  display_name: string;
  slug: string;
  effective_weight: string;
  parent_display_name: string | null;
}

// Updated Article type
export interface Article {
  // ... existing fields ...
  categories: ArticleCategory[] | null;  // Changed from string[] | null
}

// Full category for settings/management
export interface Category {
  id: number;
  display_name: string;
  slug: string;
  weight: string | null;
  parent_id: number | null;
  is_hidden: boolean;
  is_seen: boolean;
  is_manually_created: boolean;
  article_count: number;
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| `Article.categories` JSON blob | ArticleCategoryLink junction table | This phase | Enables JOINs, article counts, merge operations |
| `UserPreferences.category_groups` JSON blob | Category table columns (parent_id, weight, is_hidden, etc.) | This phase | Eliminates JSON blob surgery, enables clean CRUD |
| `UserPreferences.topic_weights` JSON blob | Category.weight column | This phase | Weight lives on the category row, not a separate JSON dict |
| Kebab-case category names | display_name + slug | This phase | Human-readable names, URL-safe slugs, smart casing |
| String-based category identity | Numeric ID-based identity | This phase | Enables clean URL params, prevents encoding issues |

**Deprecated/outdated after this phase:**
- `Article.categories` JSON column (dropped)
- `UserPreferences.category_groups` JSON blob (dropped)
- `UserPreferences.topic_weights` JSON blob (dropped)
- All category API endpoints that take string names in URL paths
- `CategoryGroupsResponse` / `CategoryGroupsUpdate` Pydantic models
- `_get_category_groups()` helper and related JSON manipulation helpers in main.py
- kebab-case normalization in scoring_queue.py

## Migration Strategy

### Step 1: Backup
- Copy SQLite .db file with timestamp before any schema changes

### Step 2: Create New Tables
- Create `categories` table via SQLModel metadata
- Create `article_category_link` table via SQLModel metadata
- Guard: skip if tables already exist

### Step 3: Migrate Category Data
- Read all unique categories from `Article.categories` JSON across all articles
- Read `UserPreferences.topic_weights` for weight assignments
- Read `UserPreferences.category_groups` for parent-child relationships, hidden/seen/manually_created flags
- For each unique category slug:
  - Convert kebab-case to display_name via smart_case
  - Create Category row with weight, parent_id, is_hidden, is_seen, is_manually_created
- Guard: skip if categories table already has rows

### Step 4: Migrate Article-Category Links
- For each article with non-null categories JSON:
  - Look up each category slug in the new Category table
  - Create ArticleCategoryLink row
- Guard: skip if article_category_link table already has rows

### Step 5: Drop Old Columns
- `ALTER TABLE articles DROP COLUMN categories`
- `ALTER TABLE user_preferences DROP COLUMN category_groups`
- `ALTER TABLE user_preferences DROP COLUMN topic_weights`
- Guard: only drop if columns still exist (check via inspector)

### Idempotency Guards
Each step is independently guarded:
1. Backup: always runs (creates new timestamped file)
2. Table creation: `create_all` is naturally idempotent
3. Data migration: check `SELECT COUNT(*) FROM categories` -- skip if > 0
4. Link migration: check `SELECT COUNT(*) FROM article_category_link` -- skip if > 0
5. Column drops: check inspector for column existence

## Surface Area Analysis

### Backend Files to Modify
| File | Changes |
|------|---------|
| `models.py` | Add Category, ArticleCategoryLink models. Remove JSON columns from Article and UserPreferences. Add relationship attrs. |
| `database.py` | Add migration functions. Add backup function. Update `create_db_and_tables()`. Remove old migration functions that touch dropped columns. |
| `main.py` | Rewrite all `/api/categories/*` endpoints. Update article list/get to include rich categories. Remove JSON manipulation helpers. New Pydantic response models. |
| `scoring.py` | Update `compute_composite_score()` and `is_blocked()` to use Category objects. Update `get_active_categories()` to query Category table. |
| `scoring_queue.py` | Update pipeline to use `get_or_create_category()`. Write to junction table instead of JSON column. Handle LLM parent suggestions. |
| `prompts.py` | Update `build_categorization_prompt()` for display names. Update `CategoryResponse` schema for display name output. Update `DEFAULT_CATEGORIES` and `DEFAULT_CATEGORY_HIERARCHY` to use display names. |

### Frontend Files to Modify
| File | Changes |
|------|---------|
| `lib/types.ts` | New `Category` and `ArticleCategory` interfaces. Update `Article.categories` type. Remove `CategoryGroups`. |
| `lib/api.ts` | Rewrite category API functions for new endpoints. Update return types. |
| `hooks/useCategories.ts` | Update queries/mutations for new API contract. |
| `hooks/usePreferences.ts` | Remove category_groups and topic_weights from preferences type (if they no longer return). |
| `components/settings/CategoriesSection.tsx` | Update to work with Category objects (IDs, display_names) instead of strings. |
| `components/settings/CategoryTree.tsx` | Update props from string-based to Category-object-based. |
| `components/settings/CategoryParentRow.tsx` | Update props. |
| `components/settings/CategoryChildRow.tsx` | Update props. |
| `components/article/ArticleRow.tsx` | Render `category.display_name` instead of raw string. |
| `components/article/ArticleReader.tsx` | Render `category.display_name`, use `category.effective_weight` instead of looking up topic_weights. |
| `components/article/TagChip.tsx` | May need prop updates for weight display. |

## Open Questions

1. **LLM Parent Suggestion Handling**
   - What we know: The LLM should suggest a parent category for new categories based on existing hierarchy.
   - What's unclear: How structured should this be? Add a `suggested_parent` field to `CategoryResponse` schema? Or just include instruction in prompt and parse from reasoning?
   - Recommendation: Add `suggested_parent: str | None` field to the Pydantic `CategoryResponse`. Simpler and more reliable than parsing free text. If the suggested parent matches an existing category slug, auto-assign parent_id.

2. **Transition Period for Frontend**
   - What we know: Backend API changes and frontend type changes must be coordinated.
   - What's unclear: Should there be a compatibility layer, or change both at once?
   - Recommendation: Change both at once. Single-user app, no API versioning needed. One plan updates backend, next plan updates frontend. Brief window where frontend may show errors, but that's acceptable for a personal app.

3. **UserPreferences After Migration**
   - What we know: `category_groups` and `topic_weights` columns will be dropped. But `interests`, `anti_interests`, and ollama config fields remain.
   - What's unclear: Does the `PreferencesResponse` API shape need to change?
   - Recommendation: Yes, remove `topic_weights` and `category_groups` from the preferences response. The frontend currently reads these for the category tree -- that data now comes from `/api/categories`. Update `PreferencesResponse` to exclude them.

## Sources

### Primary (HIGH confidence)
- SQLModel 0.0.32 official docs: many-to-many/create-models-with-link, many-to-many/link-with-extra-fields
- SQLAlchemy 2.0 docs: relationship loading techniques (selectinload vs joinedload)
- SQLite 3.50.4 documentation: ALTER TABLE DROP COLUMN support (added in 3.35.0)
- Codebase inspection: models.py, database.py, main.py, scoring.py, scoring_queue.py, prompts.py, frontend types and components

### Secondary (MEDIUM confidence)
- python-slugify PyPI documentation: feature set and API
- Python 3.14 changelog: bundled SQLite version 3.50.4

### Tertiary (LOW confidence)
- None -- all findings verified against primary sources

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - all libraries already in use, only adding python-slugify
- Architecture: HIGH - SQLModel many-to-many is well-documented, pattern verified against official docs
- Migration: HIGH - SQLite DROP COLUMN verified for version 3.35+, project uses 3.50.4
- Pitfalls: HIGH - based on direct codebase inspection and known SQLAlchemy gotchas
- Frontend surface: HIGH - all affected files identified and inspected

**Research date:** 2026-02-17
**Valid until:** 2026-03-17 (stable domain, no fast-moving dependencies)
