---
phase: 08.2-category-data-model-refactor
plan: 02
type: execute
wave: 2
depends_on: [08.2-01]
files_modified:
  - backend/src/backend/prompts.py
  - backend/src/backend/scoring.py
  - backend/src/backend/scoring_queue.py
autonomous: true
requirements: [CATGRP-05]
must_haves:
  truths:
    - "LLM categorization prompt outputs human-readable display names instead of kebab-case"
    - "LLM prompt includes existing category display names for reuse"
    - "LLM suggests a parent category for new categories"
    - "Scoring pipeline uses get_or_create pattern to write categories to Category table via junction table"
    - "Effective weight resolution reads from Category table relationships: explicit override > parent weight > normal"
    - "Blocked check uses Category.is_hidden and Category.weight instead of JSON blobs"
  artifacts:
    - path: "backend/src/backend/prompts.py"
      provides: "Updated categorization prompt with display names, updated CategoryResponse schema with suggested_parent"
      contains: "suggested_parent"
    - path: "backend/src/backend/scoring.py"
      provides: "Relational weight resolution, get_or_create_category, updated is_blocked"
      contains: "def get_or_create_category"
    - path: "backend/src/backend/scoring_queue.py"
      provides: "Updated scoring pipeline writing to junction table"
      contains: "get_or_create_category"
  key_links:
    - from: "backend/src/backend/scoring_queue.py"
      to: "backend/src/backend/scoring.py"
      via: "Calls get_or_create_category and compute_composite_score"
      pattern: "get_or_create_category|compute_composite_score"
    - from: "backend/src/backend/scoring.py"
      to: "backend/src/backend/models.py"
      via: "Queries Category table for weight resolution"
      pattern: "select\\(Category\\)"
---

<objective>
Update the LLM prompts to output human-readable display names, update the scoring pipeline to write categories via the relational get_or_create pattern, and update weight resolution to use the Category table instead of JSON blobs.

Purpose: The scoring pipeline is the primary writer of category data. It must write to the new relational tables and resolve weights from the Category model.
Output: Working scoring pipeline that creates/reuses categories in the Category table and computes composite scores from relational data.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08.2-category-data-model-refactor/08.2-CONTEXT.md
@.planning/phases/08.2-category-data-model-refactor/08.2-RESEARCH.md
@.planning/phases/08.2-category-data-model-refactor/08.2-01-SUMMARY.md
@backend/src/backend/models.py
@backend/src/backend/prompts.py
@backend/src/backend/scoring.py
@backend/src/backend/scoring_queue.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update prompts and scoring functions for display names and relational weight resolution</name>
  <files>backend/src/backend/prompts.py, backend/src/backend/scoring.py</files>
  <action>
**prompts.py changes:**

1. Update `DEFAULT_CATEGORIES` from kebab-case to display names: "Technology", "Science", "Politics", "Business", "Finance", "Health", "Sports", "Entertainment", "Culture", "Gaming", "Programming", "AI", "Cybersecurity", "Climate", "Space", "Education", "Food", "Travel", "Design", "Music", "Film", "Philosophy", "History", "Law", "Startups"

2. Update `DEFAULT_CATEGORY_HIERARCHY` to use display names as keys and values:
   ```python
   DEFAULT_CATEGORY_HIERARCHY = {
       "Technology": ["Cybersecurity", "AI", "Programming"],
       "Science": ["Climate", "Space"],
       "Business": ["Finance", "Startups"],
       "Entertainment": ["Gaming", "Film", "Music"],
       "Culture": ["Philosophy", "History", "Design"],
       "Health": [],
       "Politics": ["Law"],
       "Education": [],
   }
   ```

3. Remove `get_default_topic_weights()` function — no longer needed (topic_weights column dropped).

4. Update `CategoryResponse` Pydantic schema:
   - Change `categories` field description to say "human-readable display names" instead of "kebab-case"
   - Add `suggested_parent: str | None = Field(default=None, description="Suggested parent category for any new category")` field
   - Update `suggested_new` description to say "human-readable display names"

5. Update `build_categorization_prompt()`:
   - Rules now specify human-readable English names instead of kebab-case
   - Rule 4 changed from "kebab-case format" to: "Category names should be human-readable English (e.g., 'Artificial Intelligence', 'Web Development', 'Open Source'). Do NOT use kebab-case, underscores, or slashes."
   - Rule 8 updated: "When suggesting a new category, suggest which existing parent it should belong under in the suggested_parent field."
   - Keep all other rules the same

**scoring.py changes:**

1. Add import for `Category`, `ArticleCategoryLink` from models, `slugify` from python-slugify, `Session` and `select` from sqlmodel.

2. Add `get_or_create_category(session: Session, display_name: str, suggested_parent: str | None = None) -> Category`:
   - Import smart_case helpers from database.py (or inline them — they were added in Plan 01)
   - Generate slug from display_name using `slugify(display_name)`
   - Query `select(Category).where(Category.slug == slug)` — if found, return it
   - If not found, create new Category with:
     - `display_name = smart_case(display_name)`
     - `slug = slug`
     - `is_seen = False` (new categories start unseen per user decision)
     - If `suggested_parent` is provided, look up parent by `slugify(suggested_parent)` and set `parent_id`
   - `session.add(category)`, `session.flush()` (get ID without committing)
   - Return the category

3. Rewrite `compute_composite_score()` — new signature:
   ```python
   def compute_composite_score(
       interest_score: int,
       quality_score: int,
       categories: list[Category],  # Now Category objects, not strings
   ) -> float:
   ```
   - Weight resolution uses Category objects directly:
     - For each category: call `get_effective_weight(category)` which returns the weight string
     - `get_effective_weight(category)`: if `category.weight is not None` return it, elif `category.parent_id is not None and category.parent is not None and category.parent.weight is not None` return parent weight, else return "normal"
   - Weight map unchanged (block=0.0, reduce=0.5, normal=1.0, boost=1.5, max=2.0, plus old name aliases)
   - Average the weights, multiply with interest_score and quality_multiplier, cap at 20.0
   - Same formula as before, just different data source

4. Add `get_effective_weight(category: Category) -> str` helper:
   - `category.weight` if not None -> return it
   - `category.parent.weight` if parent exists and parent.weight not None -> return it
   - else -> "normal"

5. Rewrite `is_blocked()` — new signature:
   ```python
   def is_blocked(categories: list[Category]) -> bool:
   ```
   - Check if any category `is_hidden` or has effective weight "block"/"blocked"
   - No more JSON blob parameters

6. Rewrite `get_active_categories()` — new signature and return type:
   ```python
   async def get_active_categories(session: Session) -> tuple[list[str], dict[str, list[str]] | None]:
   ```
   - Query all non-hidden categories from Category table: `select(Category).where(Category.is_hidden == False)`
   - Return display names (not slugs) for the LLM prompt
   - Build hierarchy dict from parent-child relationships: `{parent.display_name: [child.display_name, ...]}` for categories with parent_id
   - Return (sorted display_name list, hierarchy dict)
  </action>
  <verify>
`cd backend && uv run python -c "from backend.scoring import get_or_create_category, compute_composite_score, is_blocked, get_active_categories, get_effective_weight; print('Scoring functions OK')"` succeeds. `cd backend && uv run python -c "from backend.prompts import CategoryResponse; print(CategoryResponse.model_json_schema())"` shows suggested_parent field.
  </verify>
  <done>Prompts output display names. CategoryResponse includes suggested_parent. Scoring functions use Category objects for weight resolution. get_or_create_category writes new categories to the table. is_blocked checks Category.is_hidden and effective weight.</done>
</task>

<task type="auto">
  <name>Task 2: Update scoring queue pipeline to use relational writes</name>
  <files>backend/src/backend/scoring_queue.py</files>
  <action>
Update `ScoringQueue.process_next_batch()` to use the new relational pattern:

1. **Remove old imports**: Remove `UserPreferences` from imports (still needed for preferences but not for category data). Keep the import of UserPreferences for interests/anti_interests and ollama config.

2. **Update get_active_categories call**: Still returns `(list[str], dict | None)` — the function was updated in Task 1 to query the Category table.

3. **Update Step 1 (Categorize)**:
   - After getting `categorization` result, instead of storing as JSON `article.categories = [...]`:
     - For each category in `categorization.categories + categorization.suggested_new`:
       - Call `get_or_create_category(session, display_name, suggested_parent=categorization.suggested_parent)` — pass the suggested_parent only for suggested_new categories
       - Create `ArticleCategoryLink(article_id=article.id, category_id=category.id)` if link doesn't already exist
       - Collect the Category objects in a list for later use in scoring
   - Remove the old kebab-case normalization code (`.lower().replace("_", "-").replace(" ", "-").replace("/", "-")`)
   - For score_only rescore: load existing categories from junction table instead of article.categories JSON

4. **Update Step 1.5 (Returned hidden categories)**:
   - Instead of reading from `preferences.category_groups["hidden_categories"]`, query the Category table for categories where `is_hidden == True`
   - If any of the article's categories were hidden, update `Category.is_hidden = False` and mark for notification (set some flag or create a "returned" mechanism)
   - Since the returned_categories list is gone, handle this differently: when a hidden category reappears in scoring, set `is_hidden = False` on the Category row. The frontend can detect this via the categories/new-count endpoint.
   - Actually, simpler approach per user decision: just unhide the category (set is_hidden=False) and the existing "unseen" badge system handles notification. The `returned_categories` concept is replaced by: category goes from hidden to unhidden+unseen.

5. **Update Step 2 (is_blocked check)**:
   - Pass the Category objects list: `is_blocked(article_categories)` — no more topic_weights or category_groups params

6. **Update Step 3 (compute_composite_score)**:
   - Pass Category objects: `compute_composite_score(scoring.interest_score, scoring.quality_score, article_categories)`

7. **Update imports**: Add `get_or_create_category` from scoring. Add `ArticleCategoryLink`, `Category` from models. Add `selectinload` from sqlalchemy.orm if needed for eager loading.

8. **For score_only rescore** (when `skip_categorization` is True): Load existing categories via `select(Category).join(ArticleCategoryLink).where(ArticleCategoryLink.article_id == article.id)` instead of reading article.categories JSON.

9. **Remove** any references to `preferences.topic_weights` and `preferences.category_groups` in the scoring pipeline — these columns no longer exist.
  </action>
  <verify>
`cd backend && uv run python -c "from backend.scoring_queue import ScoringQueue; print('Scoring queue OK')"` succeeds without import errors. `cd backend && uv run ruff check backend/src/backend/scoring_queue.py` passes.
  </verify>
  <done>Scoring pipeline writes category assignments to ArticleCategoryLink junction table via get_or_create. Weight resolution uses Category model. Blocked check uses Category.is_hidden and weight. No more JSON blob reads/writes in the scoring pipeline.</done>
</task>

</tasks>

<verification>
- All three files import cleanly: `cd backend && uv run python -c "from backend.scoring_queue import ScoringQueue; from backend.scoring import compute_composite_score, is_blocked; from backend.prompts import build_categorization_prompt"`
- `cd backend && uv run ruff check backend/src/backend/prompts.py backend/src/backend/scoring.py backend/src/backend/scoring_queue.py` passes
- CategoryResponse schema includes suggested_parent field
</verification>

<success_criteria>
- LLM prompt produces human-readable display names (not kebab-case)
- Scoring pipeline creates Category rows via get_or_create pattern
- Article-category associations written to junction table
- Composite score computed from Category model weights
- Blocked detection uses Category.is_hidden and effective weight
- No references to Article.categories JSON, topic_weights JSON, or category_groups JSON remain in scoring code
</success_criteria>

<output>
After completion, create `.planning/phases/08.2-category-data-model-refactor/08.2-02-SUMMARY.md`
</output>
