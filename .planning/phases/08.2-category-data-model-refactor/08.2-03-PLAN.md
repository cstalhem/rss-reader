---
phase: 08.2-category-data-model-refactor
plan: 03
type: execute
wave: 2
depends_on: [08.2-01]
files_modified:
  - backend/src/backend/main.py
autonomous: true
requirements: [CATGRP-01, CATGRP-02, CATGRP-03, CATGRP-04]
must_haves:
  truths:
    - "GET /api/categories returns flat list of Category objects with article_count computed via JOIN"
    - "POST /api/categories creates a new category with display_name, auto-generated slug, and optional parent_id"
    - "PATCH /api/categories/:id updates category fields (rename, reparent, weight change)"
    - "DELETE /api/categories/:id deletes a category (children released to root)"
    - "POST /api/categories/merge moves all article associations from source to target and deletes source"
    - "GET /api/categories/new-count returns unseen category count from Category table"
    - "POST /api/categories/acknowledge marks categories as seen by ID"
    - "Numeric IDs used in all URL path params"
  artifacts:
    - path: "backend/src/backend/main.py"
      provides: "Rewritten category API endpoints using relational queries, new Pydantic response models"
      contains: "class CategoryResponse"
  key_links:
    - from: "backend/src/backend/main.py"
      to: "backend/src/backend/models.py"
      via: "Queries Category table for all CRUD operations"
      pattern: "select\\(Category\\)|session\\.get\\(Category"
---

<objective>
Rewrite all category API endpoints in main.py to use relational queries against the Category table instead of JSON blob manipulation. Add new Pydantic response models and the merge endpoint.

Purpose: The frontend needs a clean REST API with numeric IDs for all category operations. This replaces ~15 endpoints that manipulate JSON blobs.
Output: Complete set of category CRUD endpoints using the Category table with numeric ID-based routing.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08.2-category-data-model-refactor/08.2-CONTEXT.md
@.planning/phases/08.2-category-data-model-refactor/08.2-RESEARCH.md
@.planning/phases/08.2-category-data-model-refactor/08.2-01-SUMMARY.md
@backend/src/backend/main.py
@backend/src/backend/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add new Pydantic models and rewrite category endpoints</name>
  <files>backend/src/backend/main.py</files>
  <action>
**Remove old Pydantic models:**
- Remove `CategoryGroupsResponse`, `CategoryGroupsUpdate`, `CategoryAcknowledge`, `CategoryCreate` (old string-based), `CategoryDelete`, `CategoryRename`, `NewCategoryCountResponse`
- Remove `_get_category_groups()` helper function
- Remove `_get_or_create_preferences()` helper function (or keep a simplified version that only gets/creates preferences without category logic)

**Add new Pydantic models:**

```python
class CategoryResponse(BaseModel):
    """Category object returned by API."""
    id: int
    display_name: str
    slug: str
    weight: str | None
    parent_id: int | None
    is_hidden: bool
    is_seen: bool
    is_manually_created: bool
    article_count: int

class CategoryCreate(BaseModel):
    display_name: str
    parent_id: int | None = None

class CategoryUpdate(BaseModel):
    display_name: str | None = None
    parent_id: int | None = None  # Use -1 or special sentinel to unparent
    weight: str | None = None
    is_hidden: bool | None = None
    is_seen: bool | None = None

class CategoryMerge(BaseModel):
    source_id: int
    target_id: int

class CategoryAcknowledgeRequest(BaseModel):
    category_ids: list[int]
```

**Add new endpoints (replace old ones):**

1. **GET /api/categories** — Return flat list of all categories with article counts:
   - Query all categories from Category table
   - For each category, compute `article_count` via a LEFT JOIN or subquery on ArticleCategoryLink: `SELECT c.*, COUNT(acl.article_id) as article_count FROM categories c LEFT JOIN article_category_link acl ON c.id = acl.category_id GROUP BY c.id`
   - Or use SQLAlchemy: query Category with func.count and outerjoin
   - Return list of CategoryResponse objects, sorted by display_name
   - Frontend builds tree from parent_id references (per user decision)

2. **POST /api/categories** — Create a new category:
   - Accept `CategoryCreate` body with `display_name` and optional `parent_id`
   - Generate slug from display_name using `slugify(display_name)`
   - Check for duplicate slug — 409 if exists
   - If parent_id provided, verify parent exists — 404 if not
   - Create Category with `is_manually_created=True`, `is_seen=True`
   - Return CategoryResponse with article_count=0

3. **PATCH /api/categories/{category_id}** — Update a category:
   - Accept `CategoryUpdate` body with partial fields
   - Look up category by ID — 404 if not found
   - If `display_name` provided: update display_name and regenerate slug. Check slug uniqueness.
   - If `parent_id` provided: validate parent exists, prevent circular references (can't parent to self or to own child). Use `parent_id: int | None` where None means "move to root".
   - If `weight` provided: validate against allowed values (block, reduce, normal, boost, max). Set to None to clear (inherit from parent). To distinguish "set weight to null" from "don't change weight", use a special value like "inherit" or handle at the Pydantic level.
   - If `is_hidden` provided: update
   - If `is_seen` provided: update
   - Return updated CategoryResponse with article_count

4. **DELETE /api/categories/{category_id}** — Delete a category:
   - Look up by ID — 404 if not found
   - If category has children: release them (set their parent_id to NULL — they become root-level)
   - Delete all ArticleCategoryLink rows for this category (CASCADE handles this, but be explicit)
   - Delete the Category row
   - Return `{"ok": True}`

5. **POST /api/categories/merge** — Merge two categories:
   - Accept `CategoryMerge` body with `source_id` and `target_id`
   - Verify both exist — 404 if either missing
   - Verify source != target — 400
   - Move all article associations: for each ArticleCategoryLink with source_id, check if target_id link already exists for same article. If not, update category_id to target_id. If yes, delete the source link (avoid duplicate PK).
   - If source has children, reparent them to target
   - Delete source Category
   - Return `{"ok": True, "articles_moved": N}`

6. **GET /api/categories/new-count** — Get unseen category count:
   - Count categories where `is_seen == False AND is_hidden == False`
   - Return `{"count": N}`
   - Note: the `returned_count` concept is removed. Hidden categories that reappear become unhidden+unseen, which shows up in the regular new count.

7. **POST /api/categories/acknowledge** — Mark categories as seen:
   - Accept `CategoryAcknowledgeRequest` body with `category_ids: list[int]`
   - Update `is_seen = True` for all provided IDs
   - Return `{"ok": True}`

8. **PATCH /api/categories/{category_id}/hide** — Hide a category:
   - Set `is_hidden = True`
   - Also set `weight = "block"` to ensure scoring blocks this category
   - Return CategoryResponse

9. **PATCH /api/categories/{category_id}/unhide** — Unhide a category:
   - Set `is_hidden = False`
   - If weight was "block", set weight to None (reset to inherit)
   - Return CategoryResponse

**Remove old endpoints:**
- DELETE old `@app.get("/api/categories")` (string-based)
- DELETE `@app.patch("/api/categories/{category_name}/weight")` (name-based)
- DELETE `@app.get("/api/categories/groups")` and `@app.put("/api/categories/groups")`
- DELETE `@app.patch("/api/categories/{name}/hide")` and `unhide`
- DELETE `@app.get("/api/categories/new-count")` (old)
- DELETE `@app.post("/api/categories/acknowledge")` (old)
- DELETE `@app.post("/api/categories/create")` (old)
- DELETE `@app.delete("/api/categories")` (body-based)
- DELETE `@app.patch("/api/categories/rename")`

**Update imports:** Add `Category`, `ArticleCategoryLink` from models. Add `slugify` from python-slugify. Remove old `json` import if no longer needed. Add `func` for count aggregation if not already imported.

**Update PreferencesResponse:** Remove `topic_weights` and `category_groups` fields — this data now comes from `/api/categories`. Keep `interests`, `anti_interests`, `updated_at`, and ollama fields.

**Update PreferencesUpdate:** Remove `topic_weights` field. Keep `interests` and `anti_interests`.

**Update GET /api/preferences:** Remove `topic_weights` and `category_groups` from response construction.

**Update PUT /api/preferences:** Remove `topic_weights` update logic. Keep interests/anti_interests update and re-scoring trigger.

**Keep `_get_or_create_preferences()` simplified** — only creates default preferences with interests/anti_interests/ollama config (no category data).
  </action>
  <verify>
`cd backend && uv run ruff check backend/src/backend/main.py` passes. `cd backend && uv run python -c "from backend.main import app; routes = [r.path for r in app.routes]; print([r for r in routes if 'categories' in r])"` shows the new endpoints with numeric ID params.
  </verify>
  <done>All category endpoints rewritten to use numeric IDs and relational queries. No JSON blob manipulation remains. Merge endpoint added. Preferences response cleaned of category fields. Old string-based endpoints removed.</done>
</task>

<task type="auto">
  <name>Task 2: Update article list and detail endpoints to embed rich category objects</name>
  <files>backend/src/backend/main.py</files>
  <action>
**Add new Pydantic model for article category embedding:**

```python
class ArticleCategoryEmbed(BaseModel):
    """Category embedded in article response."""
    id: int
    display_name: str
    slug: str
    effective_weight: str
    parent_display_name: str | None
```

**Update GET /api/articles:**
- Add `selectinload` to the query: `statement = select(Article).options(selectinload(Article.categories_rel))` to eager-load categories and avoid N+1 queries
- Import `selectinload` from `sqlalchemy.orm`
- After fetching articles, serialize them manually (or use a response model) to include rich category objects:
  - For each article, build `categories` field as list of `ArticleCategoryEmbed` from `article.categories_rel`
  - Each category embed includes `effective_weight` computed via `get_effective_weight(category)` from scoring.py
  - Each category embed includes `parent_display_name` from `category.parent.display_name` if parent exists
- Since the Article SQLModel no longer has a `categories` field, the default serialization won't include categories. Create an `ArticleResponse` Pydantic model or manually construct the response dict.

**Option: Add ArticleResponse model:**
```python
class ArticleResponse(BaseModel):
    id: int
    feed_id: int
    title: str
    url: str
    author: str | None
    published_at: datetime | None
    summary: str | None
    content: str | None
    is_read: bool
    categories: list[ArticleCategoryEmbed] | None
    interest_score: int | None
    quality_score: int | None
    composite_score: float | None
    score_reasoning: str | None
    scoring_state: str
    scored_at: datetime | None
```

Create a helper function `_article_to_response(article: Article) -> dict` that converts an Article with loaded categories_rel into a response dict including the rich category embeds.

**Update GET /api/articles/{article_id}:**
- Add `.options(selectinload(Article.categories_rel))` when loading a single article
- Since `session.get()` doesn't support options, use `select(Article).where(Article.id == article_id).options(selectinload(Article.categories_rel))` instead
- Return the enriched response with category objects

**Update PATCH /api/articles/{article_id}:**
- After updating read status, return the enriched response
- Need to load categories_rel for the response

**Important**: The selectinload for categories_rel also needs to load each category's parent for the `parent_display_name` field. Chain the load: `selectinload(Article.categories_rel).joinedload(Category.parent)` — this loads categories via selectin (good for many-to-many) then joins each category's parent (good for many-to-one).

Import `get_effective_weight` from scoring.py for computing the effective_weight field in the embed.
  </action>
  <verify>
`cd backend && uv run ruff check backend/src/backend/main.py` passes. `cd backend && uv run python -c "from backend.main import app; print('App created OK')"` succeeds.
  </verify>
  <done>Article list and detail endpoints return rich category objects with id, display_name, slug, effective_weight, and parent_display_name. Eager loading prevents N+1 queries. No JSON blob references remain in article serialization.</done>
</task>

</tasks>

<verification>
- `cd backend && uv run ruff check backend/src/backend/main.py` passes
- `cd backend && uv run python -c "from backend.main import app; print('App OK')"` succeeds
- New endpoints exist: GET/POST /api/categories, PATCH/DELETE /api/categories/{id}, POST /api/categories/merge, GET /api/categories/new-count, POST /api/categories/acknowledge
- Old endpoints removed: no more string-based category name URL params
- Article responses include rich category objects instead of string arrays
</verification>

<success_criteria>
- All category CRUD operations use numeric IDs in URL path params
- Categories returned as flat list with parent_id (frontend builds tree)
- Article counts computed via JOIN (no cached column)
- Merge endpoint moves associations and deletes source
- Article list/detail includes rich category embeds with effective_weight
- PreferencesResponse no longer includes topic_weights or category_groups
- No JSON blob manipulation code remains in main.py
</success_criteria>

<output>
After completion, create `.planning/phases/08.2-category-data-model-refactor/08.2-03-SUMMARY.md`
</output>
