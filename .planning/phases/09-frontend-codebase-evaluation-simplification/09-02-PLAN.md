---
phase: 09-frontend-codebase-evaluation-simplification
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - frontend/src/hooks/useCategories.ts
  - frontend/src/hooks/useFeedMutations.ts
  - frontend/src/hooks/usePreferences.ts
  - frontend/src/hooks/useOllamaConfig.ts
  - frontend/src/hooks/useArticles.ts
  - frontend/src/hooks/useScoringStatus.ts
  - frontend/src/hooks/useOllamaHealth.ts
  - frontend/src/hooks/useOllamaModels.ts
  - frontend/src/hooks/useModelPull.ts
  - frontend/src/hooks/useFeeds.ts
  - frontend/src/hooks/useCompletingArticles.ts
  - frontend/src/hooks/useAutoMarkAsRead.ts
  - frontend/src/hooks/useRenameState.ts
autonomous: true
requirements:
  - SUCCESS_CRITERIA_1
  - SUCCESS_CRITERIA_2
  - SUCCESS_CRITERIA_3
  - SUCCESS_CRITERIA_5
  - SUCCESS_CRITERIA_6
  - SUCCESS_CRITERIA_8

must_haves:
  truths:
    - "All hooks use queryKeys.* references instead of inline string literals"
    - "useCategories returns mutation objects directly, not thin wrapper functions"
    - "Mutations without their own error handling get automatic error toasts via MutationCache"
    - "Mutations with optimistic rollback set meta.handlesOwnErrors = true"
    - "useRenameState hook extracts shared rename logic from 4 category row components + FeedRow"
    - "Single-file magic numbers are named constants at top of their respective hook files"
    - "useOllamaConfig no longer exports the redundant savedConfig alias"
    - "Redundant category invalidation calls are removed (prefix matching handles subcategories)"
  artifacts:
    - path: "frontend/src/hooks/useRenameState.ts"
      provides: "Shared rename state hook"
      exports: ["useRenameState"]
    - path: "frontend/src/hooks/useCategories.ts"
      provides: "Category mutations as direct mutation objects"
      contains: "updateCategoryMutation"
  key_links:
    - from: "frontend/src/hooks/useCategories.ts"
      to: "frontend/src/lib/queryKeys.ts"
      via: "import { queryKeys }"
      pattern: "queryKeys\\.categories"
    - from: "frontend/src/hooks/useFeedMutations.ts"
      to: "frontend/src/lib/queryKeys.ts"
      via: "import { queryKeys }"
      pattern: "queryKeys\\.feeds"
---

<objective>
Refactor all hooks to use the infrastructure from Plan 01: replace inline query key strings with queryKeys.* references, remove per-mutation error boilerplate (let MutationCache handle it), expose mutation objects directly, extract useRenameState hook, and name single-file magic numbers.

Purpose: This is the highest-impact plan -- it addresses success criteria 1, 2, 3, 5, 6, and 8. The hook layer is the core of the frontend's data management, and these changes make it consistent, maintainable, and transparent.

Output: All 13 hooks updated, 1 new hook (useRenameState), all query key strings replaced, mutation boilerplate removed.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-frontend-codebase-evaluation-simplification/09-RESEARCH.md
@.planning/phases/09-frontend-codebase-evaluation-simplification/09-01-SUMMARY.md
@frontend/src/hooks/useCategories.ts
@frontend/src/hooks/useFeedMutations.ts
@frontend/src/hooks/usePreferences.ts
@frontend/src/hooks/useOllamaConfig.ts
@frontend/src/hooks/useArticles.ts
@frontend/src/hooks/useScoringStatus.ts
@frontend/src/hooks/useOllamaHealth.ts
@frontend/src/hooks/useOllamaModels.ts
@frontend/src/hooks/useFeeds.ts
@frontend/src/hooks/useModelPull.ts
@frontend/src/hooks/useCompletingArticles.ts
@frontend/src/hooks/useAutoMarkAsRead.ts
@frontend/src/lib/queryKeys.ts
@frontend/src/lib/constants.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor useCategories — mutation exposure, query keys, error handling, redundant invalidation</name>
  <files>
    frontend/src/hooks/useCategories.ts
  </files>
  <action>
This is the largest refactor. Apply all four changes simultaneously to useCategories.ts:

**1. Replace all inline query key strings with queryKeys.* references:**
- Add `import { queryKeys } from "@/lib/queryKeys"` at the top
- Replace every `["categories"]` with `queryKeys.categories.all`
- Replace every `["categories", "new-count"]` with `queryKeys.categories.newCount`
- Replace every `["articles"]` with `queryKeys.articles.all`

**2. Import NEW_COUNT_POLL_INTERVAL:**
- Add `import { NEW_COUNT_POLL_INTERVAL } from "@/lib/constants"`
- Replace `refetchInterval: 30000` with `refetchInterval: NEW_COUNT_POLL_INTERVAL`

**3. Remove per-mutation `onError` toasts — let MutationCache handle them:**
- For `updateCategoryMutation`: This has optimistic rollback in its `onError`. Keep the rollback logic but add `meta: { handlesOwnErrors: true }` to the mutation options. The MutationCache will skip it.
- For ALL other mutations (createCategoryMutation, deleteCategoryMutation, hideMutation, unhideMutation, acknowledgeMutation, mergeMutation, batchMoveMutation, batchHideMutation, batchDeleteMutation, ungroupParentMutation):
  - Remove the entire `onError` callback
  - Add `meta: { errorTitle: "Failed to ..." }` with the appropriate title string that was previously in the toast. This gives the global handler a descriptive title.
  - Convert `onSuccess` to `onSettled` (move invalidation there so it runs on both success and error, matching the pattern established by updateCategoryMutation). This ensures cache stays fresh even if the mutation fails.
- Remove the `import { toaster }` line since the only remaining toast usage is in updateCategoryMutation's onError, which should also be removed — the rollback is sufficient, and MutationCache provides the toast. Actually: keep the rollback in onError for updateCategoryMutation, but remove the `toaster.create()` call inside it. Set `meta: { handlesOwnErrors: true, errorTitle: "Failed to update category" }`. Then in the onError, only do the rollback. Add a **separate** `toaster.create` call in the onError for the rollback to show the user an error message. Wait — the MutationCache skips this mutation because `handlesOwnErrors: true`. So we need to keep the toast in onError for updateCategoryMutation. **Final approach for updateCategoryMutation:** Keep the existing onError exactly as-is (rollback + toast). Add `meta: { handlesOwnErrors: true }` so MutationCache skips it. Keep the `toaster` import for this one remaining usage.

**4. Remove redundant invalidation calls:**
- `queryClient.invalidateQueries({ queryKey: queryKeys.categories.all })` already covers `queryKeys.categories.newCount` (prefix matching). So in every `onSettled`/`onSuccess` block that invalidates BOTH, remove the `queryKeys.categories.newCount` invalidation.
- **Exception:** `acknowledgeMutation` — it should invalidate `queryKeys.categories.newCount` AND `queryKeys.categories.all` (both needed since the mutation only affects the new-count badge and the is_seen flag). Both are still needed here, but since `.all` covers `.newCount` by prefix, the `.newCount` invalidation is still redundant. Keep only `queryKeys.categories.all` for consistency.

**5. Expose mutation objects directly instead of thin wrappers:**
- Change the return statement from wrapper functions to direct mutation object exposure
- Keep the `updateCategory` named helper function that adds auto-acknowledge logic (`is_seen: true` when changing weight). This is the ONE wrapper that adds behavior.
- Everything else becomes direct mutation exposure:

```typescript
return {
  categories: categoriesQuery.data ?? [],
  newCount: newCountQuery.data?.count ?? 0,
  isLoading: categoriesQuery.isLoading,
  // Named helper with auto-acknowledge logic (keeps behavior)
  updateCategory: (id: number, data: ...) => {
    const payload = data.weight !== undefined ? { ...data, is_seen: true } : data;
    updateCategoryMutation.mutate({ id, data: payload });
  },
  updateCategoryMutation, // also expose the raw mutation for isPending etc.
  createCategoryMutation,
  deleteCategoryMutation,
  hideMutation,
  unhideMutation,
  acknowledgeMutation,
  mergeMutation,
  batchMoveMutation,
  batchHideMutation,
  batchDeleteMutation,
  ungroupParentMutation,
};
```

Remove the old wrapper functions: `createCategory`, `deleteCategory`, `hideCategory`, `unhideCategory`, `acknowledge`, `mergeCategories`, `batchMove`, `batchHide`, `batchDelete`, `ungroupParent`.

**NOTE:** This WILL break consuming components. That is expected. Plan 03 Task 1 will update all consumers. The TypeScript compiler will flag every broken callsite, making the migration safe.
  </action>
  <verify>
Run `cd /Users/cstalhem/projects/rss-reader/frontend && npx tsc --noEmit 2>&1 | head -50` to see the expected consumer breakages. Verify that useCategories.ts itself has no internal type errors by checking for errors within that file specifically. The consumer errors are expected and will be fixed in Plan 03.
  </verify>
  <done>
useCategories.ts uses queryKeys.* for all keys, has no per-mutation onError boilerplate (except updateCategoryMutation which has optimistic rollback), no redundant invalidation, returns mutation objects directly, and keeps the updateCategory helper for auto-acknowledge logic. The toaster import is retained for the one remaining usage in updateCategoryMutation.onError.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor all other hooks — query keys, error handling, magic numbers, savedConfig removal</name>
  <files>
    frontend/src/hooks/useFeedMutations.ts
    frontend/src/hooks/usePreferences.ts
    frontend/src/hooks/useOllamaConfig.ts
    frontend/src/hooks/useArticles.ts
    frontend/src/hooks/useScoringStatus.ts
    frontend/src/hooks/useOllamaHealth.ts
    frontend/src/hooks/useOllamaModels.ts
    frontend/src/hooks/useModelPull.ts
    frontend/src/hooks/useFeeds.ts
    frontend/src/hooks/useCompletingArticles.ts
    frontend/src/hooks/useAutoMarkAsRead.ts
  </files>
  <action>
Apply query key replacement and error handling changes to all remaining hooks. For each hook:

1. Add `import { queryKeys } from "@/lib/queryKeys"`
2. Replace all inline `queryKey: [...]` with the appropriate `queryKeys.*` reference
3. For mutations without error handling, add `meta: { errorTitle: "..." }` with a descriptive title

**useFeedMutations.ts:**
- Replace `["feeds"]` with `queryKeys.feeds.all`, `["articles"]` with `queryKeys.articles.all`
- For useAddFeed: add `meta: { errorTitle: "Failed to add feed" }`
- For useDeleteFeed: add `meta: { errorTitle: "Failed to delete feed" }`
- For useUpdateFeed: add `meta: { errorTitle: "Failed to update feed" }`
- For useReorderFeeds: has optimistic rollback in onError — add `meta: { handlesOwnErrors: true }`. The existing onError only does rollback (no toast), so users currently get NO error feedback on reorder failure. The global handler would add a toast, but since we mark handlesOwnErrors, it won't fire. This is fine — reorder failures silently roll back visually, which is sufficient.
- For useMarkAllRead: add `meta: { errorTitle: "Failed to mark feed as read" }`

**usePreferences.ts:**
- Replace `["preferences"]` with `queryKeys.preferences.all`
- The `updatePreferencesMutation` has no error handling — add `meta: { errorTitle: "Failed to save preferences" }`
- **Change the return:** Currently exposes `updatePreferences: updatePreferencesMutation.mutate` and `isUpdating: updatePreferencesMutation.isPending`. Replace with direct mutation object exposure:
```typescript
return {
  preferences: preferencesQuery.data,
  isLoading: preferencesQuery.isLoading,
  updatePreferencesMutation,
};
```
This will break consumers that use `.updatePreferences(data)` or `.isUpdating`. Plan 03 will update them.

**useOllamaConfig.ts:**
- Replace `["ollama-config"]` with `queryKeys.ollama.config`, `["ollama-models"]` with `queryKeys.ollama.models`, `["scoring-status"]` with `queryKeys.scoringStatus.all`
- Remove `savedConfig: query.data` from return (dead alias — `config` already returns the same thing)
- Add `meta: { errorTitle: "Failed to save Ollama config" }` to saveMutation

**useArticles.ts:**
- Replace `["articles"]` and `["articles", ...]` with `queryKeys.articles.all` / `queryKeys.articles.list(...)`
- Replace `["scoring-status"]` with `queryKeys.scoringStatus.all`
- Name single-file magic numbers at top of file:
  ```typescript
  const PAGE_SIZE = 50;
  const SCORING_ACTIVE_POLL_INTERVAL = 10_000;
  const SCORING_TAB_POLL_INTERVAL = 5_000;
  ```
- Add `meta: { errorTitle: "Failed to update article" }` to the read status mutation if present

**useScoringStatus.ts:**
- Replace `["scoring-status"]` with `queryKeys.scoringStatus.all`
- Name magic numbers:
  ```typescript
  const SCORING_STATUS_ACTIVE_INTERVAL = 2_500;
  const SCORING_STATUS_IDLE_INTERVAL = 30_000;
  ```

**useOllamaHealth.ts:**
- Replace query key with `queryKeys.ollama.health`
- Name: `const HEALTH_POLL_INTERVAL = 20_000;`

**useOllamaModels.ts:**
- Replace query key with `queryKeys.ollama.models`

**useModelPull.ts:**
- Replace `["download-status"]` with `queryKeys.ollama.downloadStatus`
- Replace `["ollama-models"]` with `queryKeys.ollama.models`
- Name magic numbers:
  ```typescript
  const DOWNLOAD_STATUS_POLL_INTERVAL = 1_000;
  const SCORE_100_PERCENT_DELAY = 500;
  ```

**useFeeds.ts:**
- Replace `["feeds"]` with `queryKeys.feeds.all`

**useCompletingArticles.ts:**
- Name: `const COMPLETING_ARTICLE_DURATION = 3_000;`

**useAutoMarkAsRead.ts:**
- Name: `const AUTO_MARK_READ_DELAY = 12_000;`
  </action>
  <verify>
Run `cd /Users/cstalhem/projects/rss-reader/frontend && npx tsc --noEmit 2>&1 | head -80` — expect some consumer errors from usePreferences return shape change and useOllamaConfig savedConfig removal. Those are expected and will be fixed in Plan 03. Grep for any remaining inline query key strings: `grep -rn 'queryKey: \[' frontend/src/hooks/` — should return zero matches (all replaced with queryKeys.*).
  </verify>
  <done>
All hooks use queryKeys.* references. No inline query key strings remain in any hook file. Mutations have meta tags for error titles. Optimistic mutations have handlesOwnErrors flag. Single-file magic numbers are named constants. savedConfig alias removed from useOllamaConfig.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create useRenameState hook</name>
  <files>frontend/src/hooks/useRenameState.ts</files>
  <action>
Create `frontend/src/hooks/useRenameState.ts` with the shared rename state logic extracted from CategoryParentRow, CategoryChildRow, CategoryUngroupedRow, and FeedRow.

```typescript
"use client";

import { useState, useRef, useEffect } from "react";

export function useRenameState(currentName: string, onRename: (newName: string) => void) {
  const [isRenaming, setIsRenaming] = useState(false);
  const [renameValue, setRenameValue] = useState(currentName);
  const inputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    if (isRenaming && inputRef.current) {
      inputRef.current.focus();
      inputRef.current.select();
    }
  }, [isRenaming]);

  const startRename = () => {
    setRenameValue(currentName);
    setIsRenaming(true);
  };

  const handleSubmit = () => {
    const trimmed = renameValue.trim();
    if (trimmed && trimmed !== currentName) {
      onRename(trimmed);
    }
    setIsRenaming(false);
    setRenameValue(currentName);
  };

  const handleCancel = () => {
    setIsRenaming(false);
    setRenameValue(currentName);
  };

  return { isRenaming, renameValue, setRenameValue, startRename, handleSubmit, handleCancel, inputRef };
}
```

Verify the hook signature matches the usage pattern in all 4 components by reading them. The `onRename` callback parameter must accept a single string (the new name). Each component currently passes a callback like `(name) => updateCategory(id, { display_name: name })` or `(name) => updateFeed.mutate({ id, data: { title: name } })`.

**Do NOT update the consuming components in this task** — that happens in Plan 03.
  </action>
  <verify>
Run `cd /Users/cstalhem/projects/rss-reader/frontend && npx tsc --noEmit 2>&1 | grep useRenameState` — should show no errors in the new file itself (consumer components don't import it yet).
  </verify>
  <done>
`useRenameState.ts` exists with the full rename state management hook. It handles isRenaming toggle, value state, input ref with auto-focus/select, submit (trim + compare + callback), and cancel (reset). Ready for consumers to adopt in Plan 03.
  </done>
</task>

</tasks>

<verification>
1. Grep for inline query key strings across ALL hook files: `grep -rn "queryKey: \[" frontend/src/hooks/` — expect zero matches
2. Grep for `toaster` imports in hooks other than useCategories: should be zero (error handling delegated to MutationCache)
3. Verify useCategories returns mutation objects (not wrapper functions) by checking the return statement
4. Verify useRenameState.ts exists and exports the hook
5. Verify savedConfig is NOT in useOllamaConfig return
6. `npx tsc --noEmit` — expect only consumer-side errors from return shape changes (not hook-internal errors)
</verification>

<success_criteria>
- Zero inline query key strings in any hook file
- useCategories exposes mutation objects directly (with updateCategory helper preserved for auto-acknowledge)
- All mutations have either meta.errorTitle or meta.handlesOwnErrors
- useRenameState hook created and ready for consumers
- All single-file magic numbers named as constants
- savedConfig alias removed
</success_criteria>

<output>
After completion, create `.planning/phases/09-frontend-codebase-evaluation-simplification/09-02-SUMMARY.md`
</output>
