---
phase: 09-frontend-codebase-evaluation-simplification
plan: 04
type: execute
wave: 4
depends_on: ["09-03"]
files_modified:
  - frontend/src/components/settings/CategoryRow.tsx
  - frontend/src/components/settings/WeightPresets.tsx
  - frontend/src/components/settings/SwipeableRow.tsx
  - frontend/src/components/article/ArticleList.tsx
  - frontend/src/components/article/ArticleRow.tsx
  - frontend/src/components/article/ArticleReader.tsx
  - frontend/src/components/settings/WeightPresetStrip.tsx
  - frontend/src/components/settings/InterestsSection.tsx
autonomous: true
requirements:
  - SUCCESS_CRITERIA_4
  - SUCCESS_CRITERIA_6
  - SUCCESS_CRITERIA_9

must_haves:
  truths:
    - "Dead files CategoryRow.tsx, WeightPresets.tsx, SwipeableRow.tsx are deleted"
    - "Dead filter branch in ArticleList.tsx is simplified"
    - "ArticleReader uses key={article?.id} instead of useEffect for state reset"
    - "WeightPresetStrip is a controlled component (no local state + useEffect sync)"
    - "InterestsSection initializes form state once on mount, uses key prop to reset after save"
    - "Build passes with zero errors"
    - "Lint passes"
  artifacts:
    - path: "frontend/src/components/settings/CategoryRow.tsx"
      provides: "DELETED — confirmed dead file"
    - path: "frontend/src/components/settings/WeightPresets.tsx"
      provides: "DELETED — confirmed dead file"
    - path: "frontend/src/components/settings/SwipeableRow.tsx"
      provides: "DELETED — confirmed dead file"
  key_links:
    - from: "frontend/src/components/article/ArticleReader.tsx"
      to: "parent component"
      via: "key={article?.id} prop"
      pattern: "key=\\{article"
---

<objective>
Delete confirmed dead code, fix the three useEffect anti-patterns, perform a broader codebase sweep (performance, imports, consistency), and verify no regressions.

Purpose: This final plan removes the last of the technical debt and ensures the codebase is clean, consistent, and free of regressions. The useEffect fixes eliminate subtle bugs (form overwrite on refetch, unnecessary re-renders).

Output: 3 dead files deleted, 3 useEffect patterns fixed, broader sweep complete, full build verification.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-frontend-codebase-evaluation-simplification/09-RESEARCH.md
@.planning/phases/09-frontend-codebase-evaluation-simplification/09-01-SUMMARY.md
@.planning/phases/09-frontend-codebase-evaluation-simplification/09-02-SUMMARY.md
@.planning/phases/09-frontend-codebase-evaluation-simplification/09-03-SUMMARY.md
@frontend/src/components/settings/CategoryRow.tsx
@frontend/src/components/settings/WeightPresets.tsx
@frontend/src/components/settings/SwipeableRow.tsx
@frontend/src/components/article/ArticleList.tsx
@frontend/src/components/article/ArticleReader.tsx
@frontend/src/components/settings/WeightPresetStrip.tsx
@frontend/src/components/settings/InterestsSection.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Delete dead files, fix dead code fragments, and fix useEffect anti-patterns</name>
  <files>
    frontend/src/components/settings/CategoryRow.tsx
    frontend/src/components/settings/WeightPresets.tsx
    frontend/src/components/settings/SwipeableRow.tsx
    frontend/src/components/article/ArticleList.tsx
    frontend/src/components/article/ArticleReader.tsx
    frontend/src/components/settings/WeightPresetStrip.tsx
    frontend/src/components/settings/InterestsSection.tsx
  </files>
  <action>
**A. Delete dead files:**

Before deleting, verify each file has zero imports in active (non-dead) files:

1. `grep -rn "from.*CategoryRow" frontend/src/ --include="*.tsx" --include="*.ts"` — expect zero matches in non-dead files
2. `grep -rn "from.*WeightPresets[^S]" frontend/src/ --include="*.tsx" --include="*.ts"` — the `[^S]` excludes WeightPresetStrip. Expect only CategoryRow.tsx (already dead)
3. `grep -rn "from.*SwipeableRow" frontend/src/ --include="*.tsx" --include="*.ts"` — expect zero matches

If verified safe, delete:
- `frontend/src/components/settings/CategoryRow.tsx`
- `frontend/src/components/settings/WeightPresets.tsx`
- `frontend/src/components/settings/SwipeableRow.tsx`

**B. Fix dead filter branch in ArticleList.tsx:**

At approximately line 168, there's a condition:
```
(filter === "unread" || filter === "all") && ... && filter === "unread"
```
The `filter === "all"` branch is dead because the outer condition requires `filter === "unread"` in the same conjunction. Simplify to:
```
filter === "unread" && selectedFeedId && articleCount > 0
```
Read the actual code first to understand the full context and verify this simplification is correct.

**C. Fix useEffect #1 — ArticleReader optimistic state reset:**

Read ArticleReader.tsx and find the `useEffect` that resets `optimisticWeights` (or similar local state) when `article?.id` changes. The fix is to use `key={article?.id}` on the component instead.

The key prop must be applied by the PARENT that renders ArticleReader. Find where ArticleReader is rendered and add `key={article?.id}`. Then in ArticleReader.tsx, remove the useEffect that watches `article?.id` and resets state — the key prop will unmount/remount the component automatically, resetting all useState to initial values.

If the parent already passes article as a prop, the key should be set on the `<ArticleReader>` element at the callsite.

**D. Fix useEffect #2 — WeightPresetStrip controlled component:**

Read WeightPresetStrip.tsx to understand the current pattern. It likely has:
- `const [localValue, setLocalValue] = useState(value)` — local state initialized from prop
- `useEffect(() => { setLocalValue(value) }, [value])` — sync from prop

The fix: Make WeightPresetStrip a fully controlled component. Remove `localValue` state and the sync useEffect entirely. Use the `value` prop directly for rendering which button is active. When a button is clicked, call `onChange(newValue)` immediately — the parent's optimistic cache update (from useCategories) will flow back through the `value` prop.

**Test this assumption:** If the optimistic update in useCategories.updateCategoryMutation.onMutate works correctly, the `value` prop (derived from query cache data) should update immediately when mutate is called, before the server responds. This eliminates the need for local optimistic state in WeightPresetStrip.

If there IS a visible flash (value reverts briefly between mutation and cache update), the fallback approach is: keep `localValue` but initialize it differently — set it from the `onChange` handler instead of from a useEffect. This would be: `setLocalValue(newValue); onChange(newValue);` in the click handler, and `setLocalValue(value)` only when `value` changes from a source other than this component (i.e., external change). But try the fully controlled approach first.

**E. Fix useEffect #3 — InterestsSection form state initialization:**

Read InterestsSection.tsx to understand the current pattern. It likely has:
- `const [interests, setInterests] = useState("")`
- `useEffect(() => { if (preferences) { setInterests(preferences.interests) } }, [preferences])`

This re-syncs on every refetch, potentially overwriting user edits.

Fix:
1. Initialize form state from `preferences` on mount only (not on every refetch). Use a ref or flag to track whether initialization has happened:
```typescript
const [interests, setInterests] = useState("");
const [antiInterests, setAntiInterests] = useState("");
const initialized = useRef(false);

useEffect(() => {
  if (preferences && !initialized.current) {
    setInterests(preferences.interests ?? "");
    setAntiInterests(preferences.anti_interests ?? "");
    initialized.current = true;
  }
}, [preferences]);
```

2. After a successful save, reset the form to reflect the saved values. Use a key prop approach: the parent renders InterestsSection with `key={saveCounter}` where saveCounter increments on successful save. OR: in the onSuccess callback of the save mutation, update the local state to match what was saved. The simplest approach is to set the form values in the save handler's onSuccess.

Read the actual code to determine the best approach. The goal is: form initializes from server data once, user edits are preserved during background refetches, and saving resets the form to the saved values.
  </action>
  <verify>
Run `cd /Users/cstalhem/projects/rss-reader/frontend && npx tsc --noEmit` — zero errors.
Verify dead files are actually deleted: `ls frontend/src/components/settings/CategoryRow.tsx frontend/src/components/settings/WeightPresets.tsx frontend/src/components/settings/SwipeableRow.tsx` — should all fail (files not found).
Run `bun run build` — success.
  </verify>
  <done>
3 dead files deleted. Dead filter branch simplified. ArticleReader uses key prop for state reset. WeightPresetStrip is a controlled component (no local state sync useEffect). InterestsSection initializes form once on mount, doesn't overwrite edits on refetch.
  </done>
</task>

<task type="auto">
  <name>Task 2: Broader sweep — performance, imports, consistency, and final build verification</name>
  <files>
    frontend/src/components/article/ArticleRow.tsx
  </files>
  <action>
**A. Performance sweep — React.memo on ArticleRow:**

Read ArticleRow.tsx. It renders in lists of 50+ items and receives props like `article`, `feedName`, callbacks, `isCompleting`, `scoringPhase`.

Wrap the component export with `React.memo()`:
```typescript
export const ArticleRow = React.memo(function ArticleRow({ ... }: ArticleRowProps) {
  // existing component body
});
```

This is safe because:
- `article` objects come from query cache (referentially stable between renders unless data changes)
- Callback props should be stable if parents use useCallback or pass stable references
- Primitive props (string, boolean) are cheap to compare

**B. Import/export hygiene audit:**

Run `npx tsc --noEmit` one final time. Then run a broader check:

1. Check for unused exports: Grep for each export and verify it has at least one import somewhere. Focus on `lib/` files.
2. Check for circular dependencies: `npx madge --circular frontend/src/` (if madge is available, otherwise skip — this is a nice-to-have). If not available, just verify the build succeeds.
3. Verify no barrel files exist that re-export everything (tree-shaking concern). Check `frontend/src/components/index.ts`, `frontend/src/hooks/index.ts` — these should NOT exist (and likely don't in this codebase).

**C. Consistency check:**

Quickly scan settings sections (FeedsSection, InterestsSection, OllamaSection, CategoriesSection) for:
- Consistent loading state handling (all should show skeletons or loading indicators)
- Consistent error state handling (now covered by MutationCache)
- Consistent section header styling

Note any remaining issues but do NOT fix them in this plan unless they're trivial (< 5 lines). Log non-trivial findings as comments in the SUMMARY.

**D. Final full verification:**

Run the complete verification suite:
```bash
cd /Users/cstalhem/projects/rss-reader/frontend
npx tsc --noEmit
bun run lint
bun run build
```

All three must pass. If lint has new warnings from the changes, fix them.

Also verify that no inline query key strings remain anywhere in the codebase:
```bash
grep -rn "queryKey: \[\"" frontend/src/ --include="*.ts" --include="*.tsx"
```
This should return zero matches (all replaced with queryKeys.* references).

Verify no hardcoded colors remain:
```bash
grep -rn "green\.\(400\|500\|600\)\|orange\.\(400\|500\)\|red\.\(400\|500\)\|oklch" frontend/src/components/ --include="*.tsx"
```

Verify no var(--chakra-colors-*) remain:
```bash
grep -rn "var(--chakra-colors" frontend/src/components/ --include="*.tsx"
```
  </action>
  <verify>
`npx tsc --noEmit` — zero errors.
`bun run lint` — passes.
`bun run build` — succeeds.
Zero inline query key strings.
Zero hardcoded colors in components.
Zero var(--chakra-colors-*) in components.
Dead files are gone.
  </verify>
  <done>
ArticleRow wrapped in React.memo. Import/export hygiene verified. Consistency checked and noted. Full build passes with zero errors, zero warnings. Phase 9 is complete — all success criteria met.
  </done>
</task>

</tasks>

<verification>
**Full Phase 9 verification (cumulative across all plans):**

1. `npx tsc --noEmit` — zero errors
2. `bun run lint` — passes
3. `bun run build` — succeeds (SUCCESS_CRITERIA_9: no regressions)
4. `grep -rn "queryKey: \[\"" frontend/src/` — zero matches (SC3: centralized query keys)
5. `grep -rn "green\.\(400\|500\|600\)\|orange\.\(400\|500\)\|red\.\(400\|500\)\|oklch" frontend/src/components/` — zero matches (SC7: semantic tokens)
6. `grep -rn "var(--chakra-colors" frontend/src/components/` — zero matches (SC7: consistent token usage)
7. Dead files deleted: CategoryRow.tsx, WeightPresets.tsx, SwipeableRow.tsx (SC4)
8. ConfirmDialog exists and is used (SC5)
9. useRenameState exists and is used by 4+ components (SC5)
10. useCategories returns mutation objects (SC2)
11. MutationCache.onError configured (SC1)
12. All magic numbers named (SC8)
</verification>

<success_criteria>
- Dead files deleted, dead code fragments removed
- All three useEffect anti-patterns fixed
- ArticleRow wrapped in React.memo
- Full build passes (tsc, lint, build)
- Phase 9 success criteria 1-9 all satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/09-frontend-codebase-evaluation-simplification/09-04-SUMMARY.md`
</output>
