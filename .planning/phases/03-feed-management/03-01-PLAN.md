---
phase: 03-feed-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/backend/models.py
  - backend/src/backend/main.py
  - backend/src/backend/feeds.py
autonomous: true

must_haves:
  truths:
    - "POST /api/feeds accepts a URL, validates it as RSS, creates feed, fetches initial articles, returns feed with article count"
    - "DELETE /api/feeds/{id} removes feed and all its articles from database"
    - "PATCH /api/feeds/{id} updates feed title and/or display_order"
    - "PATCH /api/feeds/reorder accepts ordered list of feed IDs and updates display_order"
    - "GET /api/feeds returns feeds with per-feed unread_count, ordered by display_order"
    - "GET /api/articles accepts optional feed_id filter parameter"
  artifacts:
    - path: "backend/src/backend/models.py"
      provides: "Feed.display_order field, CASCADE on Article.feed_id"
      contains: "display_order"
    - path: "backend/src/backend/main.py"
      provides: "Feed CRUD endpoints and article feed_id filter"
      contains: "create_feed"
  key_links:
    - from: "POST /api/feeds"
      to: "feeds.fetch_feed + feeds.save_articles"
      via: "endpoint calls fetch_feed then save_articles"
      pattern: "fetch_feed.*save_articles"
    - from: "DELETE /api/feeds/{id}"
      to: "Article table"
      via: "CASCADE delete on feed_id foreign key"
      pattern: "CASCADE"
---

<objective>
Add backend feed CRUD endpoints and update models for feed management.

Purpose: Provide the API foundation for all frontend feed management features. Without these endpoints, no UI interactions can persist.
Output: Working REST API endpoints for creating, listing, deleting, updating, and reordering feeds, plus feed_id filtering on articles.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-feed-management/03-RESEARCH.md
@backend/src/backend/models.py
@backend/src/backend/main.py
@backend/src/backend/feeds.py
@backend/src/backend/database.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Feed model and add CASCADE delete</name>
  <files>backend/src/backend/models.py</files>
  <action>
  Add `display_order: int = Field(default=0)` to the Feed model.

  Update Article model's `feed_id` field to include cascade delete:
  `feed_id: int = Field(foreign_key="feeds.id", index=True, ondelete="CASCADE")`

  This ensures deleting a feed automatically removes all its articles at the database level.

  Note: SQLite requires `PRAGMA foreign_keys = ON` for CASCADE to work. Check database.py — if not already set, add it to the connect_args or engine events. The existing WAL mode event handler in database.py is the right place to also enable foreign keys if needed.
  </action>
  <verify>
  Run: `cd /Users/cstalhem/projects/rss-reader/backend && python -c "from backend.models import Feed, Article; print('display_order' in Feed.model_fields); print(Article.model_fields['feed_id'].metadata)"`

  Confirm Feed has display_order field and Article has ondelete CASCADE metadata.
  </verify>
  <done>Feed model has display_order field. Article.feed_id has ondelete="CASCADE". Foreign keys are enabled in SQLite engine.</done>
</task>

<task type="auto">
  <name>Task 2: Add feed CRUD endpoints and article feed_id filter</name>
  <files>backend/src/backend/main.py, backend/src/backend/feeds.py</files>
  <action>
  Add Pydantic request/response models to main.py:

  ```python
  class FeedCreate(BaseModel):
      url: str

  class FeedUpdate(BaseModel):
      title: str | None = None
      display_order: int | None = None

  class FeedReorder(BaseModel):
      feed_ids: list[int]

  class FeedResponse(BaseModel):
      id: int
      url: str
      title: str
      display_order: int
      last_fetched_at: datetime | None
      unread_count: int
  ```

  Add these endpoints to main.py:

  **GET /api/feeds** — List all feeds ordered by display_order. For each feed, compute unread_count by counting articles where is_read=False. Use a subquery or manual count (SQLite compatible). Return list of FeedResponse.

  **POST /api/feeds** — Accept FeedCreate body. Validate URL starts with http:// or https://. Call `fetch_feed(url)` from feeds.py wrapped in try-except — on httpx error or bozo feed with no entries, raise HTTPException(400) with descriptive detail. Check for duplicate URL — raise 400 if exists. Create Feed with title from parsed feed (fallback "Untitled Feed"), display_order = max existing + 1. Call `save_articles(session, feed.id, parsed_feed.entries)` to fetch initial articles. Return the created feed with article count in response. Import `datetime` if not already imported.

  **DELETE /api/feeds/{feed_id}** — Look up feed by ID, raise 404 if not found. Delete the feed (CASCADE handles articles). Return `{"ok": True}`.

  **PATCH /api/feeds/{feed_id}** — Accept FeedUpdate body. Look up feed, raise 404 if not found. Update only non-None fields. Commit and return updated feed.

  **PATCH /api/feeds/reorder** — Accept FeedReorder body with ordered list of feed IDs. For each ID in order, update that feed's display_order to its index position. Commit. Return `{"ok": True}`.

  **Update GET /api/articles** — Add optional `feed_id: int | None = None` query parameter. If provided, add `.where(Article.feed_id == feed_id)` to the query, same pattern as existing `is_read` filter.

  **POST /api/feeds/{feed_id}/mark-all-read** — Look up feed by ID, raise 404 if not found. Update all articles for this feed to is_read=True. Return count of articles marked.

  Also remove the HARDCODED_FEED_URL constant and the seed logic from the lifespan function — feeds will now be added via the UI. Keep the rest of the lifespan (db init, scheduler).
  </action>
  <verify>
  Run the backend dev server and test with curl:

  ```bash
  cd /Users/cstalhem/projects/rss-reader/backend
  # Start server in background, then:
  # Test list feeds (should return empty or existing feeds)
  curl -s http://localhost:8912/api/feeds | python -m json.tool

  # Test add feed
  curl -s -X POST http://localhost:8912/api/feeds -H "Content-Type: application/json" -d '{"url":"https://simonwillison.net/atom/everything/"}' | python -m json.tool

  # Test list feeds again (should show feed with unread_count)
  curl -s http://localhost:8912/api/feeds | python -m json.tool

  # Test article filter by feed_id
  curl -s "http://localhost:8912/api/articles?feed_id=1&limit=5" | python -m json.tool

  # Test feed update
  curl -s -X PATCH http://localhost:8912/api/feeds/1 -H "Content-Type: application/json" -d '{"title":"Simon W"}' | python -m json.tool

  # Test delete (creates and then deletes a test feed)
  ```

  Also run: `cd /Users/cstalhem/projects/rss-reader/backend && python -m pytest tests/ -x` to ensure existing tests still pass.
  </verify>
  <done>All 6 new endpoints respond correctly. Existing article endpoints still work. feed_id filter works on GET /api/articles. Existing tests pass.</done>
</task>

</tasks>

<verification>
- GET /api/feeds returns feeds ordered by display_order with unread_count
- POST /api/feeds validates URL, fetches feed, saves articles, returns feed
- POST /api/feeds returns 400 for invalid/duplicate URLs
- DELETE /api/feeds/{id} removes feed and cascades to articles
- PATCH /api/feeds/{id} updates title/display_order
- PATCH /api/feeds/reorder updates display_order for all feeds
- GET /api/articles?feed_id=N filters articles to specific feed
- POST /api/feeds/{feed_id}/mark-all-read marks all feed articles as read
- Existing tests pass
</verification>

<success_criteria>
Backend provides complete feed CRUD API. All endpoints return correct responses. CASCADE delete confirmed working. Article feed_id filter working. No regressions in existing functionality.
</success_criteria>

<output>
After completion, create `.planning/phases/03-feed-management/03-01-SUMMARY.md`
</output>
