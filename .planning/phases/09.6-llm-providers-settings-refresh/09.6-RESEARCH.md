# Phase 09.6: LLM Providers Settings Refresh - Research

**Researched:** 2026-02-24
**Domain:** Frontend UI architecture — Chakra UI v3, multi-provider settings, searchable grouped selectors
**Confidence:** HIGH

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions
- Configured providers show as **pills** (logo + name) in a horizontal bar
- An **"Add Provider" button** next to the pills opens a dialog with provider cards
- Add dialog cards show: provider logo, name, 1-line description, and setup hint ("Local -- no API key" for Ollama, "Requires API key" for cloud providers)
- Unimplemented providers (OpenAI, Anthropic, Google, OpenRouter) have a **"Coming soon" badge overlay** on the same card design -- not clickable/selectable
- **Empty state** (no providers configured): EmptyState component with "No providers configured" message and prominent "Add Provider" button
- **Clean slate approach**: Ollama is NOT pre-configured -- users go through the Add Provider flow for all providers, including Ollama
- Click a pill to **toggle its settings panel** below the pill bar (only one open at a time)
- **Disconnect button** lives inside the provider's expanded settings panel (not on the pill itself)
- **Page structure (top to bottom):**
  1. Model selector (top-level): grouped-by-provider searchable dropdown showing "exposed" models from all active providers. Separate-models toggle stays. Mix-and-match allowed. Save & Rescore button stays.
  2. Provider pills + expandable per-provider settings panels (middle)
  3. System prompts (bottom): collapsed, accessible, provider-agnostic
- **Per-provider settings (Ollama):** editable host/port, health status as colored provider icon on pill with tooltip, model library moved into provider panel with light visual refresh
- Provider pills show **brand icon** with optional status indicator (Ollama only: colored icon for health)
- Settings sidebar stays **plain** -- no status indicators on the "LLM Providers" nav item
- **Actual brand SVG logos** for all 5 providers (Ollama, OpenAI, Anthropic, Google, OpenRouter)

### Claude's Discretion
- Exact pill bar styling and spacing
- Settings panel expand/collapse animation
- Model library visual refresh details (within "light refresh" scope)
- Empty state illustration or icon choice
- Tooltip implementation details for health status
- Searchable dropdown component choice (Chakra Combobox or custom)

### Deferred Ideas (OUT OF SCOPE)
- Editable system prompts with variable/template system for category lists -- future phase
- Backend implementation for OpenAI, Anthropic, Google, OpenRouter providers -- separate phases per provider
- Surfacing the `ollama_thinking` toggle -- evaluate if/when to expose
</user_constraints>

## Summary

This phase redesigns the LLM Providers settings page from a monolithic Ollama-only layout into a multi-provider architecture. The backend infrastructure already exists: `LLMProviderConfig` and `LLMTaskRoute` tables, a `provider-as-plugins` registry with `LLMProvider` Protocol, and `OllamaProviderConfig` with validated settings. The frontend work is predominantly a UI reorganization -- breaking `OllamaSection` into composable pieces, adding a provider pill bar with Add Provider dialog, introducing a top-level grouped model selector using Chakra Combobox, and nesting Ollama-specific settings (host/port, health, model library) into an expandable panel under the Ollama pill.

The key architectural challenge is the "clean slate" decision: Ollama is NOT pre-configured, so the page must handle zero-provider state gracefully and the Add Provider flow must create the `LLMProviderConfig` row in the database. The existing `upsert_ollama_provider_config` in `deps.py` already handles this, but the frontend currently bypasses it by assuming Ollama is always present.

**Primary recommendation:** Restructure the `OllamaSection` component into a `LLMProvidersSection` with composable sub-components (ProviderPillBar, AddProviderDialog, ProviderSettingsPanel, ModelSelector), using Chakra Combobox for the grouped searchable model dropdown, and conditional rendering for the per-provider panels. Keep the existing hooks and API layer largely unchanged -- the backend is already multi-provider ready.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| `@chakra-ui/react` | v3 (already installed) | UI primitives, Combobox, Dialog, EmptyState | Project standard |
| `@tanstack/react-query` | v5 (already installed) | Server state, cache, mutations | Project standard |
| `react-icons/lu` | (already installed) | UI icons (lucide set) | Project standard |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| Chakra `Combobox` | v3 built-in | Searchable grouped model dropdown | Top-level model selector |
| Chakra `useFilter` + `useListCollection` | v3 built-in | Client-side filtering for Combobox | Model search by name |
| Chakra `Dialog` | v3 built-in | Add Provider dialog | Provider selection flow |
| Chakra `EmptyState` | v3 built-in | No-providers state | Clean slate UX |
| Chakra `Collapsible` | v3 built-in | Provider panel expand/collapse | Panel toggle below pills |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Chakra Combobox | Chakra Select (current) | Select lacks search/filter -- Combobox provides `onInputValueChange` + `useListCollection` for grouped searchable model lists |
| Chakra Collapsible | Manual conditional render | Collapsible provides built-in animation; acceptable since only 1 panel visible at a time (no list Zag multiplier concern) |

**Installation:** No new dependencies needed. All components are already available in `@chakra-ui/react` v3.

## Architecture Patterns

### Recommended Component Structure
```
components/settings/
├── LLMProvidersSection.tsx      # Top-level orchestrator (replaces OllamaSection)
├── ProviderPillBar.tsx          # Pill bar + Add Provider button
├── AddProviderDialog.tsx        # Dialog with provider cards
├── ProviderSettingsPanel.tsx    # Expandable panel wrapper (per-provider)
├── OllamaProviderPanel.tsx     # Ollama-specific: host/port + model library
├── TopLevelModelSelector.tsx   # Grouped Combobox for all provider models
├── ModelManagement.tsx          # (existing, moved into OllamaProviderPanel)
├── ModelPullProgress.tsx        # (existing, unchanged)
├── ModelSelector.tsx            # DELETE or repurpose as OllamaModelConfig
├── OllamaHealthBadge.tsx        # (existing, adapted for pill icon overlay)
├── SystemPrompts.tsx            # (existing, unchanged)
├── SettingsPanel.tsx            # (existing, reused)
├── SettingsPageHeader.tsx       # (existing, reused)
└── SettingsPanelHeading.tsx     # (existing, reused)
```

### Pattern 1: Provider Pill Bar with Toggle
**What:** Horizontal bar of pills (brand logo + name) for configured providers, with "Add Provider" button. Clicking a pill toggles its settings panel below (only one open at a time).
**When to use:** Multi-provider selection with per-provider configuration.
**Key decisions:**
- Use `useState<string | null>` for `expandedProvider` (null = none open)
- Clicking the currently-expanded pill collapses it (toggle behavior)
- Pill shows colored brand icon as health indicator for Ollama (tooltip on hover)
- Use native `title` for health tooltip (not Chakra Tooltip) to avoid Zag overhead since pills will be few

```tsx
// Pill bar concept
<Flex gap={2} wrap="wrap" alignItems="center">
  {configuredProviders.map((p) => (
    <Button
      key={p.id}
      size="sm"
      variant={expandedProvider === p.id ? "subtle" : "outline"}
      onClick={() => setExpandedProvider(prev => prev === p.id ? null : p.id)}
    >
      <ProviderIcon provider={p.id} health={p.health} />
      {p.label}
    </Button>
  ))}
  <Button size="sm" variant="ghost" onClick={() => setShowAddDialog(true)}>
    <LuPlus size={14} />
    Add Provider
  </Button>
</Flex>
```

### Pattern 2: Add Provider Dialog with Coming-Soon Cards
**What:** Dialog with a grid of provider cards. Ollama is selectable; other 4 show "Coming soon" badge overlay and are not clickable.
**When to use:** Adding a new provider to the configured list.
**Key decisions:**
- Dialog.Root (no Portal wrapper -- Dialog handles its own portal)
- Provider metadata defined as a static array in constants
- "Coming soon" overlay via `position="absolute"` Badge on a dimmed card

```tsx
const PROVIDER_CATALOG = [
  { id: "ollama", label: "Ollama", hint: "Local — no API key", available: true },
  { id: "openai", label: "OpenAI", hint: "Requires API key", available: false },
  { id: "anthropic", label: "Anthropic", hint: "Requires API key", available: false },
  { id: "google", label: "Google", hint: "Requires API key", available: false },
  { id: "openrouter", label: "OpenRouter", hint: "Requires API key", available: false },
];
```

### Pattern 3: Grouped Searchable Model Selector (Combobox)
**What:** Top-level Combobox that groups models by provider, with search filtering.
**When to use:** Selecting categorization/scoring models across all active providers.
**Key decisions:**
- Use `useListCollection` with `groupBy: (item) => item.provider` for grouped display
- Use `useFilter` with `sensitivity: "base"` for case-insensitive search
- `onInputValueChange` calls `filter(e.inputValue)` for live filtering
- Separate-models toggle (`use_separate_models`) stays alongside the Combobox

```tsx
// Grouped Combobox for model selection
const { contains } = useFilter({ sensitivity: "base" });
const { collection, filter } = useListCollection({
  initialItems: allModels, // [{label, value, provider}]
  filter: contains,
  groupBy: (item) => item.provider,
});

<Combobox.Root
  collection={collection}
  onInputValueChange={(e) => filter(e.inputValue)}
  value={[selectedModel]}
  onValueChange={(details) => handleModelChange(details.value[0])}
>
  <Combobox.Control>
    <Combobox.Input placeholder="Search models..." />
    <Combobox.IndicatorGroup>
      <Combobox.ClearTrigger />
      <Combobox.Trigger />
    </Combobox.IndicatorGroup>
  </Combobox.Control>
  <Portal>
    <Combobox.Positioner>
      <Combobox.Content>
        <Combobox.Empty>No models found</Combobox.Empty>
        {collection.group().map(([group, items]) => (
          <Combobox.ItemGroup key={group}>
            <Combobox.ItemGroupLabel>{group}</Combobox.ItemGroupLabel>
            {items.map((item) => (
              <Combobox.Item item={item} key={item.value}>
                {item.label}
                <Combobox.ItemIndicator />
              </Combobox.Item>
            ))}
          </Combobox.ItemGroup>
        ))}
      </Combobox.Content>
    </Combobox.Positioner>
  </Portal>
</Combobox.Root>
```

**Important Combobox notes:**
- `Combobox` requires `Portal > Positioner > Content` (same as Select)
- `useFilter` and `useListCollection` are imported from `@chakra-ui/react`
- Combobox creates Zag machines but only 1-2 instances total (not in a list), so Zag overhead is not a concern here

### Pattern 4: Clean Slate with Add Provider Flow
**What:** When no providers are configured, show EmptyState with "Add Provider" button. Adding Ollama creates the provider config row and opens its settings panel.
**When to use:** First-time setup, or after disconnecting all providers.
**Backend flow:**
1. User clicks "Add Provider" -> selects Ollama in dialog
2. Frontend calls `PUT /api/ollama/config` with default config (this triggers `upsert_ollama_provider_config` which creates the `LLMProviderConfig` row)
3. Provider appears as a pill, settings panel auto-expands

### Pattern 5: Provider Brand SVG Logos
**What:** Inline SVG components for each provider's brand mark.
**When to use:** Pill bar icons, Add Provider dialog cards.
**Key decisions:**
- Create a `ProviderLogo` component that maps provider ID to an SVG component
- SVGs should be small (16-20px), monochrome (inheriting `currentColor`), stored as React components
- For Ollama: use the llama head mark. For others: use their standard brand marks
- Store in a `components/settings/provider-logos/` directory or as a single file with all logos

### Anti-Patterns to Avoid
- **Don't wrap Dialog in Portal** — Dialog handles its own portal. Wrapping causes double-render or broken focus trapping.
- **Don't use Tooltip for pill health indicator** — Use native `title` attribute. The pill bar is small, but future providers could add more pills. Keep Zag machines at zero for the pill bar.
- **Don't pre-configure Ollama** — The clean-slate decision means no auto-creation of the provider config row. The Add Provider flow handles creation.
- **Don't render hidden provider panels** — Use conditional rendering (`{expandedProvider === "ollama" && <OllamaPanel />}`), not `display: none`. Per project pattern, inactive sections should unmount (Quick 13 learnings).
- **Don't split the model selector per-provider** — The top-level selector shows ALL models from ALL active providers. Individual provider panels show model library (install/delete), not model selection.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Searchable grouped dropdown | Custom input + popover + filter | Chakra `Combobox` with `useListCollection` + `useFilter` | Handles keyboard nav, accessibility, positioning, filtering out of the box |
| Expand/collapse animation | Manual height/opacity transitions | Chakra `Collapsible` | Consistent with SystemPrompts pattern, handles animation states |
| Provider config CRUD | New API endpoints | Existing `PUT /api/ollama/config` + `upsert_ollama_provider_config` | Backend already handles create-or-update; the LLMProviderConfig table + LLMTaskRoute syncing are in place |
| Health polling | Custom setInterval | Existing `useOllamaHealth` hook with TanStack Query `refetchInterval` | Already battle-tested, polls every 20s |

**Key insight:** The backend is already multi-provider ready. The `LLMProviderConfig` table, `LLMTaskRoute` table, `LLMProvider` Protocol, and provider registry are all in place. This phase is 95% frontend restructuring.

## Common Pitfalls

### Pitfall 1: Clean Slate vs Legacy Data
**What goes wrong:** Existing users already have Ollama configured in `LLMProviderConfig`. The clean-slate approach (Ollama not pre-configured) only applies to brand-new installations. The UI must handle BOTH cases: existing config row present (show pill immediately) and no config row (show empty state).
**Why it happens:** The clean-slate decision is about the UX flow, not the database state. Existing users have their data migrated by the Alembic migration.
**How to avoid:** Query the provider configs on mount. If any exist, render pills. If none, render empty state. Don't assume either state.
**Warning signs:** Empty state flashing on page load for existing users (query loading state not handled).

### Pitfall 2: Combobox Value vs Display
**What goes wrong:** Combobox `value` is a `string[]` (even for single selection). The model name (e.g., "qwen3:4b") is both the value and part of the label. If the collection doesn't include the current value as an item, the Combobox shows nothing.
**Why it happens:** Models can be deleted while still selected as the active model. The Combobox needs the item in the collection to display it.
**How to avoid:** Always include the current selected model in the collection, even if it's not in the installed models list (mark it as unavailable/missing).
**Warning signs:** Save button shows but model name is blank in the selector.

### Pitfall 3: useListCollection Reactivity (RESOLVED)
**What goes wrong:** `useListCollection` takes `initialItems` -- if the items array changes (models installed/deleted), the collection does NOT update automatically.
**Why it happens:** Verified from Ark UI source (`@ark-ui/react/dist/components/collection/use-list-collection.js`): `initialItems` is passed directly to `useState(initialItems)`, so it's only read on mount. Changes to the prop are ignored.
**How to avoid:** Use the `set()` function from the hook's return value to imperatively sync the items when the source data changes: `useEffect(() => { set(buildModelItems(models ?? [])); }, [models, set]);`. The `set` function is stable (wrapped in Ark's `useEvent`). This preserves Combobox open/search state — no `key` prop remounting needed.
**Warning signs:** Newly downloaded models don't appear in the model selector without page reload.

### Pitfall 4: Provider Config Row Lifecycle
**What goes wrong:** Adding Ollama via the Add Provider dialog needs to create a `LLMProviderConfig` row, but the current `PUT /api/ollama/config` expects a full config payload. Sending defaults (localhost:11434, no model) is correct but might trigger health check failures or unclear states.
**Why it happens:** The "add provider" action and "configure provider" action map to the same API call.
**How to avoid:** When adding Ollama, immediately expand its settings panel so the user can verify/change connection settings. The save can happen with default values -- the health badge on the pill provides feedback.
**Warning signs:** User adds Ollama, sees a red health indicator, doesn't understand why.

### Pitfall 5: Stale Config After Provider Disconnect
**What goes wrong:** "Disconnect" button removes the provider, but `LLMTaskRoute` rows still reference it. Scoring queue tries to use a disconnected provider.
**Why it happens:** Disconnect must clean up both `LLMProviderConfig` and `LLMTaskRoute` atomically.
**How to avoid:** Backend disconnect endpoint should delete the provider config row AND clear task routes referencing it. Or: "disconnect" sets `enabled: false` rather than deleting the row, preserving the config for re-connection.
**Warning signs:** Scoring fails silently after disconnecting a provider.

### Pitfall 6: SVG Logo Licensing
**What goes wrong:** Using brand logos without proper sourcing.
**Why it happens:** Brand marks are typically trademarked.
**How to avoid:** Use simple, recognizable icons that suggest the brand. For Ollama: a llama icon. For others: their well-known marks sourced from official brand guidelines or the `simple-icons` package (MIT licensed). The context note says "to be sourced collaboratively during implementation."
**Warning signs:** N/A -- this is a compliance note, not a runtime issue.

## Code Examples

### Existing Pattern: OllamaSection (current structure to refactor)
```tsx
// Current: frontend/src/components/settings/OllamaSection.tsx
// This is the monolith to decompose:
// - SettingsPageHeader with OllamaHealthBadge
// - ModelSelector (config + save)
// - ModelManagement (install/delete)
// - SystemPrompts (read-only)
```

### Existing Pattern: Provider Config Backend
```python
# backend/src/backend/deps.py - already handles multi-provider
def get_ollama_provider_config(session) -> OllamaProviderConfig:
    row = get_provider_config_row(session, "ollama")
    if row:
        return OllamaProviderConfig.model_validate_json(row.config_json)
    return _build_legacy_ollama_config(session)  # fallback

def upsert_ollama_provider_config(session, config) -> LLMProviderConfig:
    row = get_provider_config_row(session, "ollama")
    if not row:
        row = LLMProviderConfig(provider="ollama", enabled=True, config_json="{}")
    row.config_json = config.model_dump_json()
    session.add(row)
    return row
```

### Existing Pattern: Query Keys for Ollama
```typescript
// frontend/src/lib/queryKeys.ts
ollama: {
  health: ["ollama-health"] as const,
  models: ["ollama-models"] as const,
  config: ["ollama-config"] as const,
  prompts: ["ollama-prompts"] as const,
  downloadStatus: ["download-status"] as const,
},
```

### New Pattern: Provider Catalog Constant
```typescript
// frontend/src/lib/constants.ts (addition)
export interface ProviderInfo {
  id: string;
  label: string;
  hint: string;
  available: boolean;
}

export const PROVIDER_CATALOG: ProviderInfo[] = [
  { id: "ollama", label: "Ollama", hint: "Local — no API key", available: true },
  { id: "openai", label: "OpenAI", hint: "Requires API key", available: false },
  { id: "anthropic", label: "Anthropic", hint: "Requires API key", available: false },
  { id: "google", label: "Google", hint: "Requires API key", available: false },
  { id: "openrouter", label: "OpenRouter", hint: "Requires API key", available: false },
];
```

### New Pattern: Combobox with Grouped Models
```tsx
// Verified Chakra v3 pattern from official Combobox docs
import {
  Combobox,
  Portal,
  useFilter,
  useListCollection,
} from "@chakra-ui/react";

const { contains } = useFilter({ sensitivity: "base" });
const { collection, filter } = useListCollection({
  initialItems: models, // [{label: "qwen3:4b — 2.5 GB", value: "ollama:qwen3:4b", provider: "Ollama"}]
  filter: contains,
  groupBy: (item) => item.provider,
});

// collection.group() returns [["Ollama", items[]], ["OpenAI", items[]], ...]
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Single Select dropdowns | Combobox with search + grouping | Chakra v3 | Models grow with providers; search is essential for discoverability |
| Monolithic OllamaSection | Composable provider panels | This phase | Enables adding providers without rewriting the page |
| Config in UserPreferences columns | LLMProviderConfig table + LLMTaskRoute | Phase 09.5 (dev branch) | Multi-provider config already in DB schema |

**Deprecated/outdated:**
- `OllamaSection` as the sole orchestrator component -- being decomposed
- `ModelSelector` with inline Select dropdowns -- being replaced by top-level Combobox
- `ollama_categorization_model` / `ollama_scoring_model` columns in UserPreferences -- legacy, superseded by LLMProviderConfig + LLMTaskRoute (but still present for backward compatibility)

## Open Questions

1. **~~`useListCollection` reactivity with changing `initialItems`~~** (RESOLVED)
   - Verified from Ark UI source: `initialItems` is passed to `useState()` — only read on mount, not reactive to prop changes.
   - Solution: Use the `set()` function from the hook's return value in a `useEffect` to sync when source data changes. This is surgical and preserves Combobox internal state (search text, open/closed).

2. **Disconnect semantics: delete row vs disable**
   - What we know: The LLMProviderConfig table has an `enabled` boolean column. LLMTaskRoute has a foreign key to provider.
   - What's unclear: Should "Disconnect" delete the row (losing config) or set `enabled: false` (preserving config for easy reconnect)?
   - Recommendation: Use `enabled: false` for disconnect. This preserves host/port settings and makes "reconnect" trivial. The empty state only shows when zero providers have `enabled: true`. The Add Provider flow re-enables rather than recreating.

3. **Provider logos sourcing**
   - What we know: Context says "to be sourced collaboratively during implementation." Need SVGs for Ollama, OpenAI, Anthropic, Google, OpenRouter.
   - What's unclear: Exact source -- `simple-icons` npm package, manual SVG extraction, or AI-generated approximations.
   - Recommendation: Use `simple-icons` package (MIT licensed, has all 5 brands) or manually create minimal SVG components. Defer to implementation-time collaboration per the context decision.

4. **Backend: "list configured providers" endpoint**
   - What we know: Currently there's no endpoint that returns the list of configured providers with their enabled status. The frontend would need to know which providers are configured to render pills.
   - What's unclear: Whether to add a new endpoint or have the frontend derive this from existing data (e.g., Ollama health check success implies configured).
   - Recommendation: Add a lightweight `GET /api/providers` endpoint that returns `[{provider: "ollama", enabled: true}]` from the `LLMProviderConfig` table. Minimal backend work, clean separation. Alternatively, the frontend can call `GET /api/ollama/config` and check for a 404 to determine if Ollama is configured -- but a dedicated endpoint is cleaner.

## Sources

### Primary (HIGH confidence)
- Chakra UI v3 Combobox MCP — component props, `useFilter`, `useListCollection`, `groupBy`, `collection.group()` pattern
- Chakra UI v3 Dialog MCP — component props, portal handling (no Portal wrapper needed)
- Codebase analysis — `OllamaSection.tsx`, `ModelSelector.tsx`, `ModelManagement.tsx`, `SystemPrompts.tsx`, `OllamaHealthBadge.tsx`, `FeedsSection.tsx`
- Backend analysis — `models.py` (LLMProviderConfig, LLMTaskRoute), `deps.py` (upsert/resolve patterns), `routers/ollama.py`, `llm_providers/` directory
- Project skills — `chakra-ui-v3/SKILL.md`, `tanstack-query/SKILL.md`, `react-hooks/SKILL.md`, `frontend-reference/SKILL.md`

### Secondary (now HIGH confidence)
- `useListCollection` reactivity behavior — verified from Ark UI source: `initialItems` is initial-only (`useState`), use `set()` to sync dynamically

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH — all libraries already installed and in use
- Architecture: HIGH — decomposition follows established project patterns (FeedsSection pill-like cards, conditional rendering, TanStack Query hooks)
- Pitfalls: HIGH — identified from codebase analysis and existing project decisions/history
- Combobox grouping: HIGH — verified API via MCP, `useListCollection` reactivity verified from Ark UI source (use `set()` to sync)

**Research date:** 2026-02-24
**Valid until:** 2026-03-24 (stable domain, project-internal refactoring)
