# Phase 9.1: Backend Codebase Evaluation & Simplification - Context

**Gathered:** 2026-02-19
**Status:** Ready for planning

<domain>
## Phase Boundary

Evaluate and simplify the backend codebase (`backend/src/backend/`) — resource leaks, dead code, error handling, query efficiency, code organization, type safety, async correctness, magic numbers, and testing. Frontend is out of scope.

**Critical framing:** The specific items listed in ROADMAP.md's "Specific items to evaluate" are *examples and indicators* of the kinds of problems to find and fix — NOT a closed checklist. The researcher should generalize from these patterns and audit the full backend codebase for similar issues, following best practices for this specific context (single-user FastAPI + SQLModel + SQLite app).

</domain>

<decisions>
## Implementation Decisions

### Router split strategy
- Split main.py into **one APIRouter module per domain**: articles.py, feeds.py, categories.py, preferences.py, ollama.py, scoring.py
- **Separate schemas.py** for all Pydantic request/response models — standard FastAPI convention, avoids circular imports between routers
- **deps.py** for shared helpers and FastAPI dependencies (_get_or_create_preferences, Ollama model selection, session management) — standard FastAPI pattern, breaks circular import cycles
- **Keep main.py as entry point** with global `app = FastAPI()` — no factory pattern (overkill for single-user app, easy to add later if needed)
- **Lifespan events stay in main.py** — central orchestration of startup order (DB init → scoring queue → scheduler) is clearer than distributed module registration for 3 subsystems
- **Consistent internal layout** per router module: imports → router instance → private helpers → endpoints (REST order: GET list, GET detail, POST, PATCH, DELETE)

### Claude's Discretion: File layout
- Claude decides whether to use flat structure (all modules at backend/src/backend/) or a routers/ subdirectory — based on project size and conventions

### Dead code policy
- **Remove aggressively** — if it's dead (no callers, no imports, unreachable), delete it. Git history is the archive.
- **Full audit** of all backend files for dead code — the roadmap items are examples, not exhaustive. Systematic scan for unreachable code, unused imports, unreferenced functions.
- **Separate seeding from migration** — extract "seed default categories if DB is empty" into its own function. Remove all completed migration functions (ALTER TABLE, data reshaping).
- **Add simple schema versioning** — schema_version table with single integer. Migrations check version and only run if needed. Replaces the current "run all migrations on every startup with idempotency checks" pattern.
- **Keep POST /api/feeds/refresh endpoint** — not dead, just unwired. Will be connected to a manual refresh UI button (captured as deferred idea).
- **Separate rescoring from config endpoint** — Move rescoring logic OUT of update_ollama_config and INTO the standalone POST /api/scoring/rescore endpoint. Config endpoint saves config only. Frontend orchestrates: save config → on success → trigger rescore if models changed. (Current pattern violates single responsibility: CRUD operation mixed with action/command.)

### Error handling approach
- **Context-dependent strategy**: API endpoints return clear HTTP errors to the caller. Background tasks (scoring, feed refresh) degrade gracefully — log errors, continue processing, don't crash.
- **All paths log** with consistent levels and enough context to trace:
  - ERROR: Something failed that should work (Ollama unreachable, DB write failed)
  - WARNING: Handled gracefully but noteworthy (config file missing → defaults, feed unreachable → skipping)
  - INFO: Normal operations (feed refreshed, scoring batch complete, config loaded)
- **Plain text logging with context fields** — human-readable, greppable via `docker compose logs`. Format: `[LEVEL] [module] message: key=value key=value`. No structured JSON (no log aggregation infrastructure to consume it).
- **Transient-only retries** for Ollama calls — retry on ConnectionError, TimeoutError, HTTP 503/429. Fail immediately on ValidationError, parsing errors, logic errors. (Current: retries on ALL exceptions including ValidationError.)
- **httpx.Timeout for Ollama client** — separate connection timeout (10s, fail fast if Ollama down) from read timeout (120s, per-chunk in streaming mode). Replaces current `timeout=None`. Read timeout resets per chunk, so streaming stays open as long as tokens flow.
- **Specific catches replace broad except** — create_feed should catch network/parse errors specifically, let HTTPException propagate. No more `except Exception` swallowing.
- Full audit: researcher should generalize from listed examples and find all inconsistent error handling patterns.

### Testing strategy
- **Pragmatic, targeted approach** — test the decisions, not the plumbing:
  - **Unit tests** for pure business logic: scoring functions, weight resolution, category operations. These are the riskiest areas (most complex, most impactful if wrong).
  - **Integration smoke tests** after router split: hit each router's main endpoint with real SQLite test DB, verify response shape and status codes. Catches wiring issues from the refactoring.
  - **Reproduce-first for bug fixes**: write a test that fails, fix the bug, test passes.
- **Tests written alongside refactoring** — not as a separate phase. Before splitting a router, write a smoke test. Split. Verify.
- **Minimal pytest fixtures**: `db_session` and `client` in conftest.py for integration tests. Pure function tests need no fixtures.
- **Researcher directive**: Investigate pragmatic testing patterns from FastAPI, SQLModel, and similar small-to-medium Python projects. Document findings and chosen patterns in the learning system (`.learning/testing-strategy.md`).
- **Generalizable going forward**: New business logic → unit test pure functions. New endpoint → smoke test. Bug fix → reproduce first. Refactoring → test before changing.

### Scope approach
- Roadmap items are examples/indicators, not a closed list
- Researcher should generalize from listed patterns and do a full backend audit
- Follow best practices appropriate for a single-user FastAPI + SQLModel + SQLite app
- Don't over-engineer — minimum complexity for the current context

</decisions>

<specifics>
## Specific Ideas

- "I want logs to be structured where it matters" — informative enough to trace issues and troubleshoot problems
- Ollama timeout has been a recurring pain point — the httpx.Timeout split (connect vs read) specifically addresses the "connection stuck open" vs "slow streaming" distinction
- The rescoring-in-config-endpoint pattern felt wrong to the user ("it does not sit right with me") — validated as a real SRP violation worth fixing
- Testing strategy should be captured in the learning system for long-term reference

</specifics>

<deferred>
## Deferred Ideas

- **Manual refresh UI button** — wire up the existing POST /api/feeds/refresh endpoint to a "refresh now" button in the frontend feed management UI
- **Async SQLAlchemy migration** — correct but high-effort, low-impact for single-user app. Add to pending todos if not already there.

</deferred>

---

*Phase: 09.1-backend-codebase-evaluation-simplification*
*Context gathered: 2026-02-19*
