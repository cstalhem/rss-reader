---
phase: 09.1-backend-codebase-evaluation-simplification
plan: 04
type: execute
wave: 3
depends_on: ["09.1-02", "09.1-03"]
files_modified:
  - backend/src/backend/routers/articles.py
  - backend/src/backend/routers/feeds.py
  - backend/src/backend/routers/scoring.py
  - backend/src/backend/routers/ollama.py
  - backend/src/backend/routers/categories.py
  - backend/src/backend/schemas.py
  - backend/src/backend/models.py
  - backend/tests/test_scoring.py
  - backend/tests/test_router_smoke.py
  - frontend/src/lib/api.ts
  - frontend/src/lib/types.ts
  - frontend/src/hooks/useOllamaConfig.ts
  - frontend/src/components/settings/OllamaSection.tsx
  - frontend/src/components/settings/ModelSelector.tsx
autonomous: true
requirements: []

must_haves:
  truths:
    - "list_feeds N+1 query replaced with single JOIN+GROUP BY query"
    - "get_scoring_status N+1 replaced with single GROUP BY query"
    - "get_active_categories N+1 replaced with selectinload"
    - "mark_feed_read uses bulk UPDATE instead of materializing all articles"
    - "scoring_state and composite_score columns are indexed"
    - "list_articles has response_model=list[ArticleResponse]"
    - "sort_by and order parameters use Literal types"
    - "Rescoring logic separated: PUT /api/ollama/config saves only, POST /api/scoring triggers rescore"
    - "Frontend orchestrates config save then rescore as two separate calls"
    - "unread_count only counts scored non-blocked articles"
    - "Pure function tests pass for compute_composite_score, is_blocked, get_effective_weight"
    - "Router smoke tests pass for all 6 domains"
  artifacts:
    - path: "backend/tests/test_scoring.py"
      provides: "Unit tests for scoring pure functions"
      contains: "test_compute_composite_score"
    - path: "backend/tests/test_router_smoke.py"
      provides: "Smoke tests for all router endpoints"
      contains: "test_articles_list"
  key_links:
    - from: "backend/tests/test_router_smoke.py"
      to: "backend/src/backend/main.py"
      via: "TestClient(app)"
      pattern: "TestClient"
    - from: "backend/tests/test_scoring.py"
      to: "backend/src/backend/scoring.py"
      via: "direct function imports"
      pattern: "from backend\\.scoring import"
    - from: "backend/src/backend/routers/feeds.py"
      to: "database query"
      via: "single JOIN+GROUP BY for unread counts"
      pattern: "outerjoin|group_by"
    - from: "frontend/src/components/settings/OllamaSection.tsx"
      to: "frontend/src/lib/api.ts"
      via: "separate config save + rescore trigger calls"
---

<objective>
Apply query efficiency fixes, type safety improvements, and SRP separation in router modules. Coordinate the frontend to use two separate calls (save config, then trigger rescore). Write unit tests for scoring pure functions and smoke tests for all routers.

Purpose: Final quality improvements and test coverage. N+1 queries are the biggest performance issues. The SRP fix (rescoring out of config endpoint) addresses a user-identified design concern and is coordinated with the frontend in the same plan to avoid a broken intermediate state. Tests provide safety net for the entire refactoring.

Output: Optimized router queries, typed parameters, separated rescoring with coordinated frontend, test suite.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09.1-backend-codebase-evaluation-simplification/09.1-CONTEXT.md
@.planning/phases/09.1-backend-codebase-evaluation-simplification/09.1-RESEARCH.md
@.planning/phases/09.1-backend-codebase-evaluation-simplification/09.1-02-SUMMARY.md
@.planning/phases/09.1-backend-codebase-evaluation-simplification/09.1-03-SUMMARY.md
@backend/src/backend/routers/articles.py
@backend/src/backend/routers/feeds.py
@backend/src/backend/routers/categories.py
@backend/src/backend/routers/scoring.py
@backend/src/backend/routers/ollama.py
@backend/src/backend/schemas.py
@backend/src/backend/models.py
@backend/src/backend/scoring.py
@backend/tests/conftest.py
@frontend/src/lib/api.ts
@frontend/src/lib/types.ts
@frontend/src/hooks/useOllamaConfig.ts
@frontend/src/components/settings/OllamaSection.tsx
@frontend/src/components/settings/ModelSelector.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Query efficiency, type safety, SRP separation (backend + frontend), and index additions</name>
  <files>
    backend/src/backend/routers/articles.py
    backend/src/backend/routers/feeds.py
    backend/src/backend/routers/scoring.py
    backend/src/backend/routers/ollama.py
    backend/src/backend/schemas.py
    backend/src/backend/models.py
    frontend/src/lib/api.ts
    frontend/src/lib/types.ts
    frontend/src/hooks/useOllamaConfig.ts
    frontend/src/components/settings/OllamaSection.tsx
    frontend/src/components/settings/ModelSelector.tsx
  </files>
  <action>
**routers/feeds.py -- N+1 fix, bulk UPDATE, and error handling:**

1. **list_feeds N+1 fix**: Replace the per-feed COUNT query loop with a single query using LEFT JOIN + GROUP BY. See research Example 2 for the exact pattern. The fixed query should join Feed with Article, filter unread (`Article.is_read.is_(False)`), and count per feed. Use `outerjoin` so feeds with no articles still appear. Also fix unread_count per roadmap success criteria #6: only count articles where `scoring_state == 'scored'` AND `composite_score > 0` AND `is_read == False` -- this matches what the frontend displays (scored, non-blocked, unread).

2. **mark_feed_read bulk UPDATE**: Replace the pattern that materializes all articles into Python objects and updates them one by one with a single `UPDATE Article SET is_read = True WHERE feed_id = :id AND is_read = False` statement. Use `session.exec(update(Article).where(...).values(is_read=True))` and get `result.rowcount` for the count. See research Example 4.

3. **create_feed exception specificity**: The endpoint raises HTTPException for duplicate URL check, then has a broad `except Exception` that catches the HTTPException it just raised. Fix: move the duplicate URL check BEFORE the try block so the HTTPException is raised outside the try/except. Then catch specific feed-related errors inside the try block: `except (httpx.HTTPError, ValueError, OSError) as e:` instead of `except Exception`.

**routers/scoring.py -- N+1 fix and SRP (backend side):**

1. **get_scoring_status N+1 fix**: Replace the 5 separate COUNT queries with a single `GROUP BY scoring_state` query. See research Example 3. Keep the separate blocked_count query (scored articles with composite_score == 0).

2. **SRP: Move rescoring into POST /api/scoring**: The `POST /api/scoring` endpoint (renamed from `/api/scoring/rescore` in Plan 02) should be enhanced to:
   - Accept an optional `rescore_mode` body or query parameter (default "full")
   - Contain the rescoring logic currently in `PUT /api/ollama/config`: get preferences, resolve models, call `scoring_queue.enqueue_recent_for_rescoring()`
   - Return `{"ok": True, "rescore_queued": count}` with the number of articles queued

**routers/ollama.py -- SRP (strip rescoring):**

1. **Strip rescoring from PUT /api/ollama/config**: Remove all rescoring logic from this endpoint. It should only: validate input, update UserPreferences fields, commit, return saved config. Remove the `rescore` field handling. Remove `rescore_queued` from the response. Remove the scoring_queue import if no longer needed.

2. **Update OllamaConfigUpdate schema** (in schemas.py): Remove the `rescore: bool` field from OllamaConfigUpdate since the config endpoint no longer handles rescoring.

**Frontend SRP coordination (config save + rescore as two calls):**

The current flow sends `{...config, rescore: true}` in a single PUT. The new flow splits this into two sequential calls.

1. **api.ts**:
   - Update `saveOllamaConfig` signature: remove `rescore` from the data parameter. Change from `data: OllamaConfig & { rescore: boolean }` to `data: OllamaConfig`. Return type changes to just the saved config (no `rescore_queued`).
   - Add new function `triggerRescore(mode: string = "full"): Promise<{ ok: boolean; rescore_queued: number }>` that calls `POST ${API_BASE_URL}/api/scoring` with `{rescore_mode: mode}` in the body.

2. **types.ts**:
   - If `OllamaConfigSaveResult` type includes `rescore_queued`, remove that field (it now comes from the scoring endpoint response).
   - Add or verify a `RescoreResult` type: `{ ok: boolean; rescore_queued: number }`.

3. **useOllamaConfig.ts**:
   - Update the save mutation type to match new `saveOllamaConfig` signature (no `rescore` in input, no `rescore_queued` in output).
   - Add a rescore mutation: `useMutation({ mutationFn: triggerRescore })` or expose `triggerRescore` for direct use.

4. **OllamaSection.tsx** -- Orchestrate the two-step flow:
   - `handleSave(rescore: boolean)` becomes:
     1. Call `saveMutation.mutate({...config})` (no rescore field)
     2. In `onSuccess`: if `rescore` is true, call `triggerRescore("full")` (or the rescore mutation). On rescore success, show the "N articles queued" toast. On rescore error, show error toast.
     3. If `rescore` is false, show "Model configuration saved" toast as before.
   - The `rescore` boolean still flows from `ModelSelector.onSave(rescore)` -- that interface is unchanged. Only the internal implementation changes.

5. **ModelSelector.tsx** -- No changes needed. It already calls `onSave(rescore: boolean)` which OllamaSection handles.

**routers/articles.py -- Type safety and response_model:**

1. **Add response_model**: `list_articles` endpoint is missing `response_model=list[ArticleResponse]`. Add it to the decorator.

2. **Literal types for sort_by/order**: Change `sort_by: str = "composite_score"` to `sort_by: Literal["composite_score", "published_at"] = "composite_score"` and `order: str = "desc"` to `order: Literal["asc", "desc"] = "desc"`. Import `Literal` from `typing`. FastAPI will auto-validate and return 422 on invalid values instead of silently returning unsorted results.

**models.py -- Index additions:**

1. Add `index=True` to `scoring_state` Field definition on Article model
2. Add `index=True` to `composite_score` Field definition on Article model
These are the most-filtered columns in article queries.
  </action>
  <verify>
    Run `cd /Users/cstalhem/projects/rss-reader/backend && uv run python -c "from typing import get_type_hints; from backend.routers.articles import list_articles; print('articles OK')"` -- imports succeed.
    Run `cd /Users/cstalhem/projects/rss-reader/backend && uv run ruff check backend/src/backend/routers/ backend/src/backend/models.py backend/src/backend/schemas.py` -- no lint errors.
    Run `cd /Users/cstalhem/projects/rss-reader/backend && uv run pytest backend/tests/test_api.py -v` -- existing tests still pass.
    Run `cd /Users/cstalhem/projects/rss-reader/frontend && bun run build` -- frontend compiles with SRP changes.
  </verify>
  <done>
    N+1 queries fixed in list_feeds (JOIN+GROUP BY), get_scoring_status (GROUP BY), mark_feed_read (bulk UPDATE). scoring_state and composite_score indexed. list_articles has response_model and Literal types. Rescoring separated from config endpoint into POST /api/scoring with frontend coordinated to use two-step flow (save config, then trigger rescore). create_feed catches specific exceptions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for scoring functions and router smoke tests</name>
  <files>
    backend/tests/test_scoring.py
    backend/tests/test_router_smoke.py
  </files>
  <action>
**test_scoring.py** -- Unit tests for pure scoring functions (no DB needed):

Create test file per research Example 5. Test the following:

1. **get_effective_weight** tests:
   - Explicit weight on category returns that weight
   - No explicit weight, parent has weight -> returns parent weight
   - No explicit weight, no parent -> returns "normal"
   - No explicit weight, parent has no weight -> returns "normal"

2. **compute_composite_score** tests:
   - Normal weight: interest(8) * category(1.0) * quality_mult -> expected value
   - Block weight: returns 0.0 regardless of scores
   - Max weight: high scores capped at MAX_COMPOSITE_SCORE (20.0)
   - Multiple categories: uses minimum weight multiplier (worst category wins)
   - No categories: returns 0.0 or uses default -- check actual behavior
   - Boost weight: interest * 1.5 * quality_mult

3. **is_blocked** tests:
   - Category with weight="block" -> True
   - Category with is_hidden=True -> True
   - Category with weight="normal" -> False
   - Empty category list -> check actual behavior
   - Mixed: one blocked, one normal -> True (any blocked = blocked)

Use a `_make_category` helper that creates Category objects without DB. Set parent relationship manually where needed for inheritance tests. See research Example 5 for the pattern.

**test_router_smoke.py** -- Integration smoke tests for all routers:

Create test file per research Example 6. Use the `test_client` fixture from conftest.py (which already overrides get_session with test DB).

Test each router's primary endpoint:
1. `GET /health` -> 200, has "status" key
2. `GET /api/articles` -> 200, returns list
3. `GET /api/feeds` -> 200, returns list
4. `GET /api/categories` -> 200, returns list
5. `GET /api/preferences` -> 200, has "interests" key
6. `GET /api/scoring/status` -> 200, has expected keys
7. `POST /api/feeds` with valid URL -> test that it accepts the request shape (may fail on actual fetch but validates routing)
8. `GET /api/ollama/health` -> 200 (returns connected=false if Ollama not running, which is fine)

Each test is minimal: hit the endpoint, check status code and basic response shape. These catch wiring issues from the router split, not business logic.

Use the existing `test_client` fixture. For tests that need seed data, use `sample_feed` and `sample_articles` fixtures from conftest.py.
  </action>
  <verify>
    Run `cd /Users/cstalhem/projects/rss-reader/backend && uv run pytest backend/tests/test_scoring.py -v` -- all scoring unit tests pass.
    Run `cd /Users/cstalhem/projects/rss-reader/backend && uv run pytest backend/tests/test_router_smoke.py -v` -- all smoke tests pass.
    Run `cd /Users/cstalhem/projects/rss-reader/backend && uv run pytest backend/tests/ -v` -- entire test suite passes.
  </verify>
  <done>
    test_scoring.py has 8+ unit tests for compute_composite_score, is_blocked, get_effective_weight. test_router_smoke.py has 6+ smoke tests covering all router domains. Entire test suite passes.
  </done>
</task>

</tasks>

<verification>
- `uv run pytest backend/tests/ -v` -- full test suite green
- `uv run ruff check backend/src/backend/` -- entire backend lint-clean
- `uv run ruff format --check backend/src/backend/` -- formatting clean
- `cd frontend && bun run build` -- frontend compiles cleanly
- Manual: start server with `uv run uvicorn backend.main:app --port 8912`, verify endpoints respond correctly
- Manual: test config save flow in UI -- save config without rescore (toast: "saved"), save with model change and rescore (toast: "N articles queued")
</verification>

<success_criteria>
1. N+1 queries eliminated (list_feeds, get_scoring_status, mark_feed_read bulk UPDATE)
2. Article model has indexed scoring_state and composite_score
3. list_articles has response_model and Literal-typed sort/order params
4. Rescoring logic separated: PUT /api/ollama/config saves only, POST /api/scoring triggers rescore
5. Frontend orchestrates two-step flow: save config -> on success -> trigger rescore if models changed
6. create_feed catches specific exceptions (not broad except Exception)
7. unread_count matches frontend visibility (scored, non-blocked, unread)
8. test_scoring.py: 8+ passing unit tests
9. test_router_smoke.py: 6+ passing smoke tests
10. Entire test suite green
11. Frontend builds and config save flow works end-to-end
12. No functional regressions
</success_criteria>

<knowledge_updates>
After completing all tasks, review what was learned during execution and update project knowledge:

1. **Update `.claude/skills/backend-reference/SKILL.md`** to reflect the new backend structure: router modules in `routers/`, `schemas.py`, `deps.py`, schema versioning in `database.py`, and any other architectural changes from this phase. The current skill still references "scoring queue in `main.py`" which is no longer accurate.

2. **Update `.claude/rules/backend.md`** — the schema migrations rule currently says "Schema migrations are manual — `database.py` runs `ALTER TABLE ADD COLUMN` checks on startup." After Plan 01, this changes to schema versioning with a `schema_version` table. Update the rule to match.

3. **General**: If any unexpected patterns, gotchas, or useful techniques were discovered during execution, capture them in the appropriate tier:
   - Gotchas/mistakes → one-line rule in `.claude/rules/backend.md`
   - Patterns/examples → update relevant skill in `.claude/skills/`
   - Unvalidated observations → note in `MEMORY.md`
</knowledge_updates>

<output>
After completion, create `.planning/phases/09.1-backend-codebase-evaluation-simplification/09.1-04-SUMMARY.md`
</output>
