# Phase 09.1: Backend Codebase Evaluation & Simplification - Research

**Researched:** 2026-02-19
**Domain:** FastAPI + SQLModel backend refactoring, code organization, error handling, testing
**Confidence:** HIGH

## Summary

This research covers a comprehensive audit of the backend codebase (`backend/src/backend/`) with ~3,100 lines across 10 source files. The primary focus areas are: splitting the 1,426-line `main.py` into APIRouter modules, fixing resource leaks in Ollama client usage, removing ~350 lines of dead migration code, standardizing error handling with transient-only retries, improving query efficiency (N+1 patterns), adding basic tests for pure scoring functions, and implementing simple schema versioning.

The codebase is in reasonably good shape for a rapidly-developed single-user app. The most impactful changes are the router split (code organization), Ollama client resource management (correctness), and dead migration removal (simplicity). The testing additions are surgical -- pure function unit tests for scoring logic and smoke tests for router wiring after the split.

**Primary recommendation:** Split `main.py` into APIRouter modules first (biggest organizational win), then layer in fixes (resource leaks, error handling, dead code) per-module, with tests written alongside each change.

<user_constraints>

## User Constraints (from CONTEXT.md)

### Locked Decisions

#### Router split strategy
- Split main.py into **one APIRouter module per domain**: articles.py, feeds.py, categories.py, preferences.py, ollama.py, scoring.py
- **Separate schemas.py** for all Pydantic request/response models -- standard FastAPI convention, avoids circular imports between routers
- **deps.py** for shared helpers and FastAPI dependencies (_get_or_create_preferences, Ollama model selection, session management) -- standard FastAPI pattern, breaks circular import cycles
- **Keep main.py as entry point** with global `app = FastAPI()` -- no factory pattern (overkill for single-user app, easy to add later if needed)
- **Lifespan events stay in main.py** -- central orchestration of startup order (DB init -> scoring queue -> scheduler) is clearer than distributed module registration for 3 subsystems
- **Consistent internal layout** per router module: imports -> router instance -> private helpers -> endpoints (REST order: GET list, GET detail, POST, PATCH, DELETE)

#### Dead code policy
- **Remove aggressively** -- if it's dead (no callers, no imports, unreachable), delete it. Git history is the archive.
- **Full audit** of all backend files for dead code
- **Separate seeding from migration** -- extract "seed default categories if DB is empty" into its own function. Remove all completed migration functions.
- **Add simple schema versioning** -- schema_version table with single integer. Migrations check version and only run if needed.
- **Keep POST /api/feeds/refresh endpoint** -- not dead, just unwired
- **Separate rescoring from config endpoint** -- Move rescoring logic OUT of update_ollama_config and INTO the standalone POST /api/scoring/rescore

#### Error handling approach
- **Context-dependent strategy**: API endpoints return clear HTTP errors; background tasks degrade gracefully
- **All paths log** with consistent levels: ERROR/WARNING/INFO
- **Plain text logging with context fields** -- format: `[LEVEL] [module] message: key=value key=value`
- **Transient-only retries** for Ollama calls -- retry on ConnectionError, TimeoutError, HTTP 503/429. Fail immediately on ValidationError, parsing errors, logic errors
- **httpx.Timeout for Ollama client** -- separate connection timeout (10s) from read timeout (120s)
- **Specific catches replace broad except** -- create_feed should catch network/parse errors specifically

#### Testing strategy
- **Pragmatic, targeted approach**: unit tests for pure business logic, integration smoke tests after router split
- **Tests written alongside refactoring** -- not as a separate phase
- **Minimal pytest fixtures**: `db_session` and `client` in conftest.py

#### Scope approach
- Roadmap items are examples/indicators, not a closed list
- Follow best practices appropriate for a single-user FastAPI + SQLModel + SQLite app
- Don't over-engineer

### Claude's Discretion

#### File layout
- Claude decides whether to use flat structure (all modules at backend/src/backend/) or a routers/ subdirectory

### Deferred Ideas (OUT OF SCOPE)
- **Manual refresh UI button** -- wire up POST /api/feeds/refresh to frontend
- **Async SQLAlchemy migration** -- correct but high-effort, low-impact for single-user app

</user_constraints>

## Standard Stack

### Core (already installed, no new dependencies)
| Library | Version | Purpose | Notes |
|---------|---------|---------|-------|
| FastAPI | >=0.128.0 | Web framework | APIRouter for module split |
| SQLModel | >=0.0.32 | ORM models | Already used for all models |
| Pydantic | (via SQLModel) | Request/response schemas | Separate schemas.py |
| httpx | >=0.28.1 | HTTP client for Ollama | `httpx.Timeout` for split timeouts |
| ollama | 0.6.1 | Ollama Python client | Supports `async with` context manager |
| tenacity | >=9.1.4 | Retry logic | `retry_if_exception_type` with specific errors |
| pytest | >=9.0.2 | Testing | Already in dev dependencies |
| ruff | >=0.15.0 | Linting/formatting | Already in dev dependencies |

### No New Dependencies Needed
The entire phase uses existing libraries. No `pip install` or `uv add` needed.

## Architecture Patterns

### Recommended: `routers/` Subdirectory (Claude's Discretion)

**Recommendation: Use a `routers/` subdirectory.** With 6 router modules + schemas.py + deps.py, a flat layout would put ~18 files in the package root. A `routers/` subdirectory groups the API layer cleanly and keeps the package root for infrastructure (database, models, config, scoring).

```
backend/src/backend/
  __init__.py
  main.py               # App creation, CORS, lifespan, router registration
  config.py             # Settings (unchanged)
  database.py           # Engine, session, smart_case, schema versioning
  models.py             # SQLModel table definitions (unchanged)
  feeds.py              # Feed fetching/parsing (unchanged)
  ollama_service.py     # Ollama API wrapper (unchanged structure)
  prompts.py            # LLM prompts and response schemas (unchanged)
  scoring.py            # Scoring logic (unchanged structure)
  scoring_queue.py      # Queue manager (unchanged structure)
  scheduler.py          # APScheduler jobs (unchanged structure)
  schemas.py            # All Pydantic request/response models (NEW)
  deps.py               # Shared dependencies and helpers (NEW)
  routers/
    __init__.py          # Router registration helper (optional)
    articles.py          # Article CRUD
    feeds.py             # Feed CRUD + refresh
    categories.py        # Category CRUD + batch ops
    preferences.py       # User preferences
    ollama.py            # Ollama health, models, config
    scoring.py           # Scoring status, rescore trigger
```

**Why routers/ subdirectory over flat:**
- 6 router files + `__init__.py` is a natural subdirectory (a package, not a pile of files)
- The package root stays clean: infrastructure modules (database, models, config, scoring pipeline) vs API layer (routers)
- Standard FastAPI convention per official docs (app/routers/ directory)
- Imports are clear: `from backend.routers.articles import router as articles_router`

### Pattern 1: APIRouter Module Layout

Each router module follows this consistent structure:

```python
# backend/routers/articles.py
"""Article API endpoints."""
import logging

from fastapi import APIRouter, Depends, HTTPException
from sqlmodel import Session

from backend.deps import get_session
from backend.schemas import ArticleResponse, ArticleUpdate

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/articles", tags=["articles"])


# --- Private helpers ---

def _article_to_response(article) -> ArticleResponse:
    ...


# --- Endpoints (REST order: GET list, GET detail, POST, PATCH, DELETE) ---

@router.get("", response_model=list[ArticleResponse])
def list_articles(...):
    ...

@router.get("/{article_id}", response_model=ArticleResponse)
def get_article(...):
    ...

@router.patch("/{article_id}", response_model=ArticleResponse)
def update_article(...):
    ...
```

### Pattern 2: Router Registration in main.py

```python
# backend/main.py
from fastapi import FastAPI
from backend.routers import articles, feeds, categories, preferences, ollama, scoring

app = FastAPI(title="RSS Reader API", version="0.1.0", lifespan=lifespan)

# Register routers
app.include_router(articles.router)
app.include_router(feeds.router)
app.include_router(categories.router)
app.include_router(preferences.router)
app.include_router(ollama.router)
app.include_router(scoring.router)
```

### Pattern 3: Shared Dependencies (deps.py)

```python
# backend/deps.py
"""Shared FastAPI dependencies and helper functions."""
from datetime import datetime

from sqlmodel import Session, select

from backend.config import get_settings
from backend.database import engine
from backend.models import UserPreferences

settings = get_settings()


def get_session():
    """FastAPI dependency for database sessions."""
    with Session(engine) as session:
        yield session


def get_or_create_preferences(session: Session) -> UserPreferences:
    """Get existing preferences or create defaults. Used by multiple routers."""
    preferences = session.exec(select(UserPreferences)).first()
    if not preferences:
        preferences = UserPreferences(
            interests="",
            anti_interests="",
            updated_at=datetime.now(),
        )
        session.add(preferences)
        session.commit()
        session.refresh(preferences)
    return preferences


def resolve_ollama_models(preferences: UserPreferences) -> tuple[str, str]:
    """Resolve categorization and scoring model names from preferences + config fallback.

    Returns:
        Tuple of (categorization_model, scoring_model)
    """
    categorization_model = (
        preferences.ollama_categorization_model
        or settings.ollama.categorization_model
    )
    if preferences.ollama_use_separate_models:
        scoring_model = (
            preferences.ollama_scoring_model or settings.ollama.scoring_model
        )
    else:
        scoring_model = categorization_model
    return categorization_model, scoring_model
```

### Pattern 4: Ollama Client with Proper Resource Management

```python
# Source: ollama-python 0.6.1, httpx docs
import httpx
from ollama import AsyncClient

OLLAMA_CONNECT_TIMEOUT = 10.0   # Fail fast if Ollama is down
OLLAMA_READ_TIMEOUT = 120.0     # Per-chunk in streaming mode

async def categorize_article(...):
    timeout = httpx.Timeout(
        connect=OLLAMA_CONNECT_TIMEOUT,
        read=OLLAMA_READ_TIMEOUT,
        write=30.0,
        pool=10.0,
    )
    async with AsyncClient(host=settings.ollama.host, timeout=timeout) as client:
        content = ""
        async for chunk in await client.chat(..., stream=True):
            content += chunk["message"].get("content") or ""
        return CategoryResponse.model_validate_json(content)
```

### Pattern 5: Transient-Only Retry

```python
# Source: tenacity docs
from tenacity import retry, retry_if_exception_type, stop_after_attempt, wait_exponential
import httpx

# Transient errors worth retrying
TRANSIENT_ERRORS = (
    ConnectionError,
    TimeoutError,
    httpx.ConnectError,
    httpx.ReadTimeout,
    httpx.ConnectTimeout,
)

@retry(
    retry=retry_if_exception_type(TRANSIENT_ERRORS),
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=2, max=10),
)
async def categorize_article(...):
    ...
```

### Pattern 6: Simple Schema Versioning

```python
# In database.py
CURRENT_SCHEMA_VERSION = 1  # Increment when adding migrations

def _get_schema_version(conn) -> int:
    """Get current schema version, creating table if needed."""
    conn.execute(text(
        "CREATE TABLE IF NOT EXISTS schema_version (version INTEGER NOT NULL)"
    ))
    row = conn.execute(text("SELECT version FROM schema_version")).first()
    if row is None:
        conn.execute(text("INSERT INTO schema_version (version) VALUES (0)"))
        return 0
    return row[0]

def _set_schema_version(conn, version: int):
    conn.execute(text("UPDATE schema_version SET version = :v"), {"v": version})

def create_db_and_tables():
    """Initialize database tables and run versioned migrations."""
    SQLModel.metadata.create_all(engine)
    with engine.begin() as conn:
        version = _get_schema_version(conn)
        if version < 1:
            _seed_default_categories(conn)
            _recover_stuck_scoring(conn)
            _set_schema_version(conn, 1)
    logger.info(f"Database ready at schema version {CURRENT_SCHEMA_VERSION}")
```

### Anti-Patterns to Avoid

- **Don't use `next(get_session())`**: The scheduler currently uses `with next(get_session()) as session:` which doesn't properly finalize the generator. Use `with Session(engine) as session:` directly in non-FastAPI contexts.
- **Don't create AsyncClient without closing**: Always use `async with AsyncClient() as client:` -- the ollama 0.6.1 client supports this.
- **Don't retry on all exceptions**: `retry_if_exception_type(Exception)` retries ValidationError pointlessly. Use specific transient error types.
- **Don't declare `async def` without `await`**: Functions like `get_active_categories`, `enqueue_articles`, `enqueue_recent_for_rescoring` are `async` but don't await anything. Remove `async` declaration.
- **Don't use broad `except Exception` that swallows specific exceptions**: In `create_feed`, the broad except catches HTTPException which was already raised intentionally.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Retry logic | Custom retry loops | `tenacity` with `retry_if_exception_type` | Already installed, handles backoff, jitter, specific exception filtering |
| Schema versioning | Complex migration framework | Single `schema_version` table + version integer | App is single-user, migrations are rare, Alembic is overkill |
| Request validation | Manual string checking | Pydantic `Literal` types on query params | `sort_by: Literal["composite_score", "published_at"]` auto-validates |
| Timeout management | Manual asyncio timeouts | `httpx.Timeout` with per-phase values | Granular connect/read/write/pool, resets per chunk in streaming |
| Test fixtures | Custom DB setup code | `conftest.py` with `StaticPool` + `dependency_overrides` | Standard FastAPI/SQLModel testing pattern, already partially in place |

## Common Pitfalls

### Pitfall 1: Circular Imports During Router Split
**What goes wrong:** Moving endpoints to router modules creates import cycles (e.g., router imports `scoring_queue` which imports `scheduler` which imports `get_session` which lives in... where?)
**Why it happens:** The current code has deferred imports in 7+ places specifically to avoid circular deps.
**How to avoid:** The `deps.py` module breaks all cycles. `get_session` moves from `database.py` to `deps.py`. `get_or_create_preferences` moves to `deps.py`. Router modules import from `deps.py`, never from each other. The scoring pipeline (`scoring.py`, `scoring_queue.py`, `scheduler.py`) stays independent -- it imports from `models.py` and `config.py`, not from routers.
**Warning signs:** `ImportError: cannot import name 'X' from partially initialized module`.

### Pitfall 2: Test Isolation After Router Split
**What goes wrong:** Tests break because `app.dependency_overrides[get_session]` no longer matches the import path after `get_session` moves from `database.py` to `deps.py`.
**Why it happens:** `dependency_overrides` keys are the actual function objects. If routers import `get_session` from `deps.py` but tests override the one from `database.py`, the override doesn't apply.
**How to avoid:** Update conftest.py to import `get_session` from the same module as the routers do (i.e., `from backend.deps import get_session`). Write a smoke test BEFORE the split, verify it passes, then do the split, then verify it still passes.
**Warning signs:** Tests pass individually but get wrong data; endpoints return production DB data in tests.

### Pitfall 3: Ollama Timeout in Streaming Mode
**What goes wrong:** Setting `read=120.0` makes people think the entire streaming response must complete in 120 seconds. Actually, httpx read timeout resets per chunk.
**Why it happens:** Confusion between "total response time" and "time between chunks."
**How to avoid:** Understand that `read` timeout is per-chunk (inter-chunk deadline). For streaming Ollama responses, 120s per chunk is extremely generous -- if no chunk arrives in 120s, the model is truly stuck. The connect timeout (10s) is the one that catches "Ollama is down" fast.
**Warning signs:** Legitimate long-running generations getting killed. (With 120s per-chunk, this is very unlikely.)

### Pitfall 4: Removing Migration Code Breaks Existing DBs
**What goes wrong:** Removing `_migrate_articles_scoring_columns()` etc. means existing databases that somehow missed a migration won't get fixed.
**Why it happens:** Fear that migrations are still needed.
**How to avoid:** The schema versioning approach handles this. Set initial schema version to 1 only if the database already has all expected columns (the new `create_db_and_tables` checks this). For truly old databases, the user would need to recreate -- but this is a single-user app with git-managed config, and all current users have run the migrations already.

### Pitfall 5: Breaking the Frontend API Contract
**What goes wrong:** Changing response shapes, removing fields, or altering status codes during refactoring.
**Why it happens:** Refactoring changes behavior inadvertently.
**How to avoid:** This is a reorganization phase, not a feature change. Every endpoint must return the same response shape. The `response_model` additions (e.g., adding `response_model=list[ArticleResponse]` to `list_articles`) are additive -- they add validation, not behavioral change. Run smoke tests before and after each router extraction. Keep the frontend running and test manually.

### Pitfall 6: `expire_on_commit = False` Removal
**What goes wrong:** Someone sees `session.expire_on_commit = False` without a comment and removes it as "unnecessary."
**Why it happens:** Without comment, it looks like cargo-cult code.
**How to avoid:** This setting is intentional in `process_scoring_queue`. The scoring queue reads an article, commits state changes, then continues using the article object. Without `expire_on_commit = False`, accessing `article.title` after commit would trigger a lazy load -- which fails because the session was created outside the normal request cycle. Add an explanatory comment.

## Code Examples

### Example 1: Proper Ollama Client Usage with Timeout

```python
# Source: ollama-python 0.6.1 docs + httpx.Timeout docs
import httpx
from ollama import AsyncClient

OLLAMA_CONNECT_TIMEOUT = 10.0
OLLAMA_READ_TIMEOUT = 120.0

async def categorize_article(
    article_title: str,
    article_text: str,
    existing_categories: list[str],
    settings: "Settings",  # Typed!
    model: str,
    category_hierarchy: dict[str, list[str]] | None = None,
    hidden_categories: list[str] | None = None,
) -> CategoryResponse:
    prompt = build_categorization_prompt(...)

    timeout = httpx.Timeout(
        connect=OLLAMA_CONNECT_TIMEOUT,
        read=OLLAMA_READ_TIMEOUT,
        write=30.0,
        pool=10.0,
    )

    async with AsyncClient(host=settings.ollama.host, timeout=timeout) as client:
        content = ""
        async for chunk in await client.chat(
            model=model,
            messages=[{"role": "user", "content": prompt}],
            format=CategoryResponse.model_json_schema(),
            options={"temperature": 0},
            stream=True,
            think=True if settings.ollama.thinking else None,
        ):
            if chunk["message"].get("thinking"):
                _scoring_activity["phase"] = "thinking"
            if chunk["message"].get("content"):
                _scoring_activity["phase"] = "categorizing"
            content += chunk["message"].get("content") or ""

    return CategoryResponse.model_validate_json(content)
```

### Example 2: N+1 Fix for list_feeds

```python
# Current (N+1): one COUNT query per feed
for feed in feeds:
    unread_count = session.exec(
        select(func.count(Article.id))
        .where(Article.feed_id == feed.id)
        .where(Article.is_read.is_(False))
    ).one()

# Fixed: single query with subquery
from sqlalchemy import func as sa_func
from sqlmodel import select

statement = (
    select(
        Feed,
        sa_func.count(Article.id).filter(
            Article.is_read.is_(False)
        ).label("unread_count"),
    )
    .outerjoin(Article, Feed.id == Article.feed_id)
    .group_by(Feed.id)
    .order_by(Feed.display_order, Feed.id)
)
results = session.exec(statement).all()
return [
    FeedResponse(
        id=feed.id, url=feed.url, title=feed.title,
        display_order=feed.display_order,
        last_fetched_at=feed.last_fetched_at,
        unread_count=count or 0,
    )
    for feed, count in results
]
```

### Example 3: N+1 Fix for get_scoring_status

```python
# Current (N+1): 5 separate COUNT queries + 1 for blocked
for state in states:
    count = session.exec(
        select(func.count(Article.id)).where(Article.scoring_state == state)
    ).one()

# Fixed: single GROUP BY query
from sqlalchemy import case, func as sa_func

results = session.exec(
    select(
        Article.scoring_state,
        sa_func.count(Article.id),
    )
    .group_by(Article.scoring_state)
).all()

counts = {state: 0 for state in ["unscored", "queued", "scoring", "scored", "failed"]}
for state, count in results:
    counts[state] = count

# Blocked count: scored with composite_score == 0
blocked_count = session.exec(
    select(sa_func.count(Article.id))
    .where(Article.scoring_state == "scored")
    .where(Article.composite_score == 0)
).one()
counts["blocked"] = blocked_count
```

### Example 4: mark_feed_read Bulk UPDATE

```python
# Current: materializes all articles, updates one by one
articles = session.exec(
    select(Article).where(Article.feed_id == feed_id).where(Article.is_read.is_(False))
).all()
count = len(articles)
for article in articles:
    article.is_read = True
    session.add(article)

# Fixed: single UPDATE statement
from sqlalchemy import update

result = session.exec(
    update(Article)
    .where(Article.feed_id == feed_id)
    .where(Article.is_read.is_(False))
    .values(is_read=True)
)
count = result.rowcount
session.commit()
```

### Example 5: Testing Pattern for Pure Scoring Functions

```python
# tests/test_scoring.py
"""Unit tests for scoring pure functions."""
import pytest

from backend.models import Category
from backend.scoring import compute_composite_score, get_effective_weight, is_blocked


def _make_category(weight=None, parent_weight=None, is_hidden=False):
    """Create a Category object for testing (no DB needed)."""
    cat = Category(
        id=1, display_name="Test", slug="test",
        weight=weight, is_hidden=is_hidden,
    )
    if parent_weight is not None:
        cat.parent = Category(
            id=2, display_name="Parent", slug="parent",
            weight=parent_weight,
        )
        cat.parent_id = 2
    return cat


def test_get_effective_weight_explicit():
    cat = _make_category(weight="boost")
    assert get_effective_weight(cat) == "boost"


def test_get_effective_weight_inherited():
    cat = _make_category(parent_weight="reduce")
    assert get_effective_weight(cat) == "reduce"


def test_get_effective_weight_default():
    cat = _make_category()
    assert get_effective_weight(cat) == "normal"


def test_compute_composite_score_normal():
    cat = _make_category(weight="normal")
    score = compute_composite_score(8, 7, [cat])
    # interest(8) * category(1.0) * quality_mult(0.5 + 0.7*0.5 = 0.85) = 6.8
    assert score == pytest.approx(6.8)


def test_compute_composite_score_blocked():
    cat = _make_category(weight="block")
    score = compute_composite_score(8, 7, [cat])
    assert score == 0.0


def test_compute_composite_score_capped():
    cat = _make_category(weight="max")
    score = compute_composite_score(10, 10, [cat])
    assert score == 20.0  # Capped


def test_is_blocked_hidden():
    cat = _make_category(is_hidden=True)
    assert is_blocked([cat]) is True


def test_is_blocked_weight():
    cat = _make_category(weight="block")
    assert is_blocked([cat]) is True


def test_is_blocked_normal():
    cat = _make_category(weight="normal")
    assert is_blocked([cat]) is False
```

### Example 6: Integration Smoke Test After Router Split

```python
# tests/test_router_smoke.py
"""Smoke tests to verify router wiring after split."""


def test_health(test_client):
    resp = test_client.get("/health")
    assert resp.status_code == 200


def test_articles_list(test_client):
    resp = test_client.get("/api/articles")
    assert resp.status_code == 200
    assert isinstance(resp.json(), list)


def test_feeds_list(test_client):
    resp = test_client.get("/api/feeds")
    assert resp.status_code == 200
    assert isinstance(resp.json(), list)


def test_categories_list(test_client):
    resp = test_client.get("/api/categories")
    assert resp.status_code == 200
    assert isinstance(resp.json(), list)


def test_preferences_get(test_client):
    resp = test_client.get("/api/preferences")
    assert resp.status_code == 200
    assert "interests" in resp.json()


def test_scoring_status(test_client):
    resp = test_client.get("/api/scoring/status")
    assert resp.status_code == 200
```

### Example 7: Logging Format

```python
# In main.py at startup
import logging

logging.basicConfig(
    level=getattr(logging, settings.logging.level),
    format="%(levelname)s [%(name)s] %(message)s",
)

# Usage in modules -- context as key=value in the message string
logger.info(f"Created feed: title={feed.title} articles={article_count}")
logger.error(f"Failed to score article: id={article.id} error={e}")
logger.warning(f"Feed unreachable, skipping: url={feed.url}")
```

Note: The decision was plain text logging with `[LEVEL] [module] message: key=value`. Python's `logging.basicConfig` format string `%(levelname)s [%(name)s] %(message)s` achieves this without any external library. The key=value context goes into the message string itself via f-strings. No need for structlog or custom formatters for this use case.

## Full Codebase Audit Findings

This section generalizes from the roadmap's specific items and documents ALL issues found during the full backend audit.

### Resource Lifecycle Issues

| File | Line(s) | Issue | Fix |
|------|---------|-------|-----|
| `scoring.py` | 121-124, 186-189 | `AsyncClient` created per call, never closed | Use `async with AsyncClient(...) as client:` |
| `scoring.py` | 122, 188 | `timeout=None` -- no protection against hung LLM | Use `httpx.Timeout(connect=10, read=120)` |
| `ollama_service.py` | 59, 103, 170 | `AsyncClient` created without closing | Use `async with` or explicit `await client.close()` |
| `scheduler.py` | 24, 47 | `with next(get_session()) as session:` -- generator not finalized | Use `with Session(engine) as session:` directly |

### Dead Code (~350 lines to remove)

| File | Item | Lines | Reason Dead |
|------|------|-------|-------------|
| `database.py` | `_migrate_articles_scoring_columns()` | ~20 | Completed migration; columns exist in all DBs |
| `database.py` | `_migrate_ollama_config_columns()` | ~25 | Completed migration |
| `database.py` | `_migrate_json_to_relational()` | ~120 | Completed migration (JSON -> relational) |
| `database.py` | `_drop_old_json_columns()` | ~20 | Completed migration |
| `database.py` | `_backup_database()` | ~10 | Only used by migration |
| `database.py` | `_seed_categories_from_hierarchy()` | ~45 | Only called from migration; keep seeding but rewrite |
| `scoring.py` | Old weight aliases in `weight_map` | ~6 | `"blocked"`, `"low"`, `"neutral"`, `"medium"`, `"high"` -- migration already remapped all data |
| `prompts.py` | `DEFAULT_CATEGORIES` | ~25 | Defined but never imported anywhere |
| `main.py` | `if rescore_mode:` guard (line 1380) | 2 | `rescore_mode` is always set to `"full"` on line 1378, so this is always True |
| `models.py` | `model_config = {"arbitrary_types_allowed": True}` | 1 | Article has no non-standard types; leftover from when JSON column existed |
| `database.py` | `import json`, `import shutil` | 2 | Only used by migration functions being removed |

### Error Handling Issues

| File | Location | Issue | Fix |
|------|----------|-------|-----|
| `main.py` | `create_feed` L443 | Broad `except Exception` catches HTTPException already raised at L438-441 | Catch `(httpx.HTTPError, feedparser.FeedParserError)` specifically |
| `config.py` | L123-125 | Silent YAML config parse failure -- no logging | Add `logger.warning(f"Failed to parse config: {e}")` |
| `scoring.py` | L85-88, L153-156 | `retry_if_exception_type(Exception)` retries ValidationError | Use `retry_if_exception_type(TRANSIENT_ERRORS)` tuple |
| `main.py` | `list_articles` L243 | Missing `response_model=list[ArticleResponse]` | Add response_model declaration |
| `main.py` | `update_ollama_config` L1319 | Returns untyped dict | Add response model or type annotation |
| `ollama_service.py` | `check_health` L45 | Broad `except Exception` catches everything | Catch `(httpx.HTTPError, httpx.TimeoutException, ConnectionError)` |
| `ollama_service.py` | `delete_model` L170 | Broad `except Exception` in caller | Let specific errors propagate |

### Query Efficiency Issues

| File | Location | Issue | Fix |
|------|----------|-------|-----|
| `main.py` | `list_feeds` L386-405 | N+1: separate COUNT per feed | Single query with LEFT JOIN + GROUP BY |
| `main.py` | `get_scoring_status` L1209-1224 | N+1: 5 separate COUNTs | Single GROUP BY query |
| `scoring.py` | `get_active_categories` L320-333 | N+1: lazy `.parent` access | Add `selectinload(Category.parent)` to query |
| `main.py` | `mark_feed_read` L574-586 | Materializes all articles to count | Bulk UPDATE returning rowcount |
| `models.py` | Article model | `scoring_state` and `composite_score` not indexed | Add `index=True` to both Field definitions |

### Type Safety Issues

| File | Location | Issue | Fix |
|------|----------|-------|-----|
| `scoring.py` | `categorize_article`, `score_article` | `settings` parameter untyped | Type as `Settings` from `backend.config` |
| `main.py` | `list_articles` | `sort_by`/`order` accept any string | Use `Literal["composite_score", "published_at"]` / `Literal["asc", "desc"]` |
| `models.py` | `Article.rescore_mode` | Stringly-typed (any string or None) | Use `Literal["full", "score_only"]` or keep str but document |
| `scoring.py` | `_scoring_activity` L28 | Untyped dict | Add `TypedDict` or comment documenting shape |
| `main.py` | `VALID_WEIGHTS` L746 | Set literal -- not discoverable | Move to shared constants or schemas |

### Async Correctness Issues

| File | Location | Issue | Fix |
|------|----------|-------|-----|
| `scoring.py` | `get_active_categories` L308 | `async def` but no `await` | Remove `async` -- it's a sync function |
| `scoring_queue.py` | `enqueue_articles` L27 | `async def` but no `await` | Remove `async` |
| `scoring_queue.py` | `enqueue_recent_for_rescoring` L49 | `async def` but no `await` | Remove `async` |
| `scheduler.py` | L24, L47 | `next(get_session())` bypasses generator cleanup | Use `Session(engine)` directly |
| `scheduler.py` | L48 | `expire_on_commit = False` without comment | Add explaining comment |

### Magic Numbers

| File | Location | Value | Replace With |
|------|----------|-------|-------------|
| `scheduler.py` | L50 | `batch_size=5` | `SCORING_BATCH_SIZE = 5` constant |
| `scheduler.py` | L73 | `seconds=30` | `SCORING_INTERVAL_SECONDS = 30` constant |
| `scoring.py` | L122, L188 | `timeout=None` | `OLLAMA_CONNECT_TIMEOUT`, `OLLAMA_READ_TIMEOUT` |
| `scoring_queue.py` | L54 | `days=7` | `RESCORE_LOOKBACK_DAYS = 7` |
| `scoring_queue.py` | L55 | `max_articles=100` | `RESCORE_MAX_ARTICLES = 100` |
| `scoring.py` | L283 | `20.0` | `MAX_COMPOSITE_SCORE = 20.0` |
| `prompts.py` | L99 | `2000` | `CATEGORIZATION_TEXT_LIMIT = 2000` |
| `prompts.py` | L166 | `3000` | `SCORING_TEXT_LIMIT = 3000` |

### Code Organization Issues

| Issue | Current | Fix |
|-------|---------|-----|
| `main.py` is 1,426 lines with 6 resource domains | Everything in one file | Split into APIRouter modules per locked decision |
| 159 lines of Pydantic schemas in `main.py` | Mixed with endpoints | Extract to `schemas.py` |
| `_get_or_create_preferences` duplicated in 3 places | main.py, scoring_queue.py, update_ollama_config | Move to `deps.py` |
| Ollama model resolution logic duplicated in 3 places | main.py get_ollama_config, update_ollama_config, scoring_queue.py | Extract to `deps.py` as `resolve_ollama_models()` |
| 7+ deferred imports to avoid circular deps | `from backend.scheduler import scoring_queue` scattered | `deps.py` breaks cycles |
| `get_session` in `database.py` | Imported by both routers and scheduler | Move to `deps.py`; scheduler uses `Session(engine)` directly |

### SRP Violation: Rescoring in Config Endpoint

The `update_ollama_config` endpoint (L1319-1405) both saves config AND enqueues articles for rescoring. Per user decision, this should be split:
- `PUT /api/ollama/config` -- save config only, return saved config
- `POST /api/scoring/rescore` -- already exists, enhance to accept optional `rescore_mode` parameter
- Frontend orchestrates: save config -> on success -> trigger rescore if needed

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| `ollama.AsyncClient()` without close | `async with AsyncClient() as client:` | ollama-python 0.6.x (2024) | Prevents fd leaks, suppresses ResourceWarning |
| `retry_if_exception_type(Exception)` | `retry_if_exception_type((ConnectionError, TimeoutError, ...))` | Always was best practice | Prevents pointless retries on parse/validation errors |
| `timeout=None` on httpx | `httpx.Timeout(connect=X, read=Y)` | Always available in httpx | Prevents indefinite hangs |
| Run all migrations every startup | Schema version check, run only needed | Common pattern | Faster startup, clearer intent |

**Deprecated/outdated:**
- `DEFAULT_CATEGORIES` list in `prompts.py` -- superseded by `DEFAULT_CATEGORY_HIERARCHY` dict. Remove.
- Old weight names (`"blocked"`, `"low"`, `"neutral"`, `"medium"`, `"high"`) -- data migration already ran, aliases can be removed from `compute_composite_score`.

## Open Questions

1. **Scheduler session pattern**
   - What we know: `next(get_session())` is problematic but currently works because there's nothing after yield
   - What's unclear: Whether `Session(engine)` directly needs any of the SQLite pragma settings from the engine event listener
   - Recommendation: Use `Session(engine)` directly -- the engine-level connect event listener (`set_sqlite_pragma`) fires on every connection from the engine's pool, so sessions created directly still get the pragmas. **Confirmed: safe to use.**

2. **Test fixture compatibility with lifespan events**
   - What we know: The existing `TestClient(app)` activates the lifespan, which calls `create_db_and_tables()` and `start_scheduler()`
   - What's unclear: Whether scheduler jobs interfere with tests
   - Recommendation: Override just `get_session` (already done). The scheduler uses `next(get_session())` which creates sessions from the production engine, not the test engine, so scheduler jobs won't affect test data. But after migration to `Session(engine)`, consider adding a test-mode flag or mocking the scheduler start. For now, keep simple -- the scheduler runs every 30s, tests finish fast.

3. **`unread_count` consistency**
   - What we know: `list_feeds` counts ALL unread articles including unscored ones; frontend hides unscored articles
   - What's unclear: Whether fixing this is in scope (it changes API behavior)
   - Recommendation: Per roadmap success criteria #6, this should be fixed. The unread count should match what the user sees (scored, non-blocked, unread). This is a bugfix, not a contract change.

## Sources

### Primary (HIGH confidence)
- Full codebase audit of all 10 backend source files (direct reading)
- [FastAPI Bigger Applications docs](https://fastapi.tiangolo.com/tutorial/bigger-applications/) -- APIRouter patterns
- [httpx Timeout docs](https://www.python-httpx.org/advanced/timeouts/) -- per-phase timeout configuration
- [ollama-python GitHub](https://github.com/ollama/ollama-python) -- AsyncClient context manager support (issue #532, source code)
- [SQLModel Testing docs](https://sqlmodel.tiangolo.com/tutorial/fastapi/tests/) -- TestClient + dependency override pattern
- [tenacity docs](https://tenacity.readthedocs.io/en/stable/) -- retry_if_exception_type patterns

### Secondary (MEDIUM confidence)
- [FastAPI Best Practices (zhanymkanov)](https://github.com/zhanymkanov/fastapi-best-practices) -- project structure conventions
- [FastAPI Testing Dependencies](https://fastapi.tiangolo.com/advanced/testing-dependencies/) -- dependency override patterns
- [Python logging docs](https://docs.python.org/3/library/logging.html) -- format string patterns

### Tertiary (LOW confidence)
- None -- all findings verified against source code or official docs

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH -- no new dependencies, all existing libraries verified
- Architecture: HIGH -- APIRouter patterns from official FastAPI docs, codebase audit comprehensive
- Pitfalls: HIGH -- based on direct code reading + known FastAPI patterns
- Testing: HIGH -- patterns from official SQLModel docs, existing conftest.py already 80% correct
- Dead code identification: HIGH -- every item traced via import analysis of all 10 files
- Query efficiency: HIGH -- N+1 patterns verified by reading actual code

**Research date:** 2026-02-19
**Valid until:** 2026-03-19 (stable -- no fast-moving dependencies)
