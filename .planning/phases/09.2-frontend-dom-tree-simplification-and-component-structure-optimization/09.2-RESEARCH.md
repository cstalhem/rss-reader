# Phase 09.2: Frontend DOM Tree Simplification - Research

**Researched:** 2026-02-20
**Domain:** Frontend DOM optimization, semantic HTML, component structure
**Confidence:** HIGH

## Summary

This phase simplifies the frontend DOM by addressing five distinct workstreams: (1) route-based settings navigation, (2) CategoryRowShell extraction, (3) WeightPresetStrip tooltip/dedup optimization, (4) ScoreBadge and ArticleRow cleanup, and (5) semantic HTML audit. The core technical patterns are well-established Next.js App Router nested routes, Chakra UI responsive utilities, and standard HTML semantics.

The codebase is in good shape post-Phase 9/9.1. The main DOM waste comes from responsive duplication (WeightPresetStrip rendered twice per category row, settings mobile/desktop stacks), Tooltip wrapper nodes on ScoreBadge (2 extra DOM nodes per article row), and non-semantic div-heavy markup. Route-based settings navigation eliminates the mobile stacked-sections pattern entirely and replaces client-side section state with URL segments.

**Primary recommendation:** Start with settings route restructuring (largest structural change, eliminates mobile/desktop duplication), then CategoryRowShell (biggest per-node savings in category tree), then remaining cleanup (WeightPresetStrip, ScoreBadge, semantic audit).

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

- **Settings Navigation:** Nested route segments (`app/settings/feeds/page.tsx`, etc.). `/settings` redirects to first section. Desktop: persistent left sidebar nav at md+. Mobile: dropdown at top replaces sidebar below md. Sidebar uses `<nav>` with proper links. Only active section mounted in DOM.
- **Category Row Shared Shell:** Extract `CategoryRowShell` for common wrapper, responsive strip placement, rename state, and context menu logic. All three row types use shared shell. Keep tree connector lines. Single `WeightPresetStrip` per row that adapts responsively.
- **WeightPresetStrip Tooltips:** Tooltip wraps each weight button with `disabled` prop tied to breakpoint. At md+: Tooltip active. Below md: Tooltip disabled (no-op, no extra wrapper nodes). `aria-label` on Button in all cases. Keep hover-expand on desktop, mobile shows all buttons always.
- **Responsive Dedup Strategy:** Per-case: CSS `display: none` for lightweight elements (~1-3 nodes), conditional rendering for heavy subtrees (category row strips, settings stacks). Claude's discretion for borderline cases (CategoryActionBar).
- **Semantic HTML Audit:** Full systematic audit. App shell landmarks: Header -> `<header>`, Sidebar -> `<nav>`/`<aside>`, main content -> `<main>`. Article lists use `<article>`. Replace divs with semantic elements wherever appropriate.
- **Article List Cleanup:** ScoreBadge: replace Tooltip wrapper with `aria-label` (saves 2 DOM nodes per article row). No empty containers when content is absent.
- **Before/after DOM snapshots** via Rodney to verify reduction.

### Claude's Discretion

- Workstream ordering and plan grouping
- CategoryActionBar responsive dedup approach (conditional render vs CSS hide)
- Exact CategoryRowShell interface design
- Specific semantic HTML element choices per component
- Any additional wrapper node removal discovered during audit

### Deferred Ideas (OUT OF SCOPE)

None -- discussion stayed within phase scope.
</user_constraints>

## Standard Stack

### Core

No new libraries needed. This phase uses existing stack components.

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Next.js App Router | 15.x | Nested route segments for settings | Already in use; file-system routing is zero-config |
| Chakra UI v3 | 3.x | `useBreakpointValue`, `as` prop, responsive props | Already in use; provides breakpoint hooks and semantic element support |

### Supporting

| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| `next/navigation` | 15.x | `redirect()` for `/settings` -> `/settings/feeds` | Settings index page redirect |
| `next/link` | 15.x | `<Link>` for settings sidebar nav items | Replace onClick handlers with real links |

### Alternatives Considered

None -- all work uses existing project dependencies.

**Installation:**
No new packages needed.

## Architecture Patterns

### Recommended Project Structure (Settings Routes)

```
frontend/src/app/settings/
├── layout.tsx           # Settings shell: Header + sidebar/dropdown + {children}
├── page.tsx             # Redirect to /settings/feeds
├── feeds/
│   └── page.tsx         # <FeedsSection />
├── interests/
│   └── page.tsx         # <InterestsSection />
├── categories/
│   └── page.tsx         # <CategoriesSection />
├── ollama/
│   └── page.tsx         # <OllamaSection />
└── feedback/
    └── page.tsx         # <FeedbackPlaceholder />
```

### Pattern 1: Settings Layout with Nested Routes

**What:** Shared layout wrapping all settings pages with sidebar/dropdown nav
**When to use:** Settings page restructuring

The current `settings/page.tsx` manages section state via `useState`. Convert to a layout that wraps child route segments.

```typescript
// app/settings/layout.tsx ("use client" - needs usePathname for active link)
import { redirect } from "next/navigation"; // Not needed here - see page.tsx
import { Header } from "@/components/layout/Header";
import { SettingsSidebar } from "@/components/settings/SettingsSidebar";

export default function SettingsLayout({ children }: { children: React.ReactNode }) {
  return (
    <Box minHeight="100vh" bg="bg">
      <Header />
      <Container maxW="5xl" py={8} px={6} pt="88px">
        <Flex gap={8}>
          {/* Desktop sidebar */}
          <Box as="nav" display={{ base: "none", md: "block" }} width="200px" flexShrink={0}>
            <SettingsSidebar />
          </Box>
          {/* Content area */}
          <Box flex={1} minW={0} overflowY="auto" maxH="calc(100vh - 88px - 64px)" css={{ scrollbarGutter: "stable" }}>
            {/* Mobile dropdown (visible < md) */}
            <Box display={{ base: "block", md: "none" }} mb={4}>
              <SettingsMobileNav />
            </Box>
            {children}
          </Box>
        </Flex>
      </Container>
    </Box>
  );
}
```

```typescript
// app/settings/page.tsx (Server Component)
import { redirect } from "next/navigation";

export default function SettingsIndex() {
  redirect("/settings/feeds");
}
```

**Confidence: HIGH** -- Standard Next.js App Router pattern. Verified via Context7: layouts nest by default, `redirect()` works in Server Components.

### Pattern 2: SettingsSidebar Refactored to Link-Based Nav

**What:** Replace onClick section switching with `<Link>` elements and `usePathname()` for active state
**When to use:** SettingsSidebar component update

```typescript
// SettingsSidebar now reads active state from URL, not props
import { usePathname } from "next/navigation";
import Link from "next/link";

const SIDEBAR_ITEMS = [
  { id: "feeds", href: "/settings/feeds", icon: LuRss, label: "Feeds" },
  // ...
];

export function SettingsSidebar() {
  const pathname = usePathname();
  // ...
  return (
    <Stack as="nav" gap={1}>
      {SIDEBAR_ITEMS.map((item) => {
        const isActive = pathname === item.href;
        return (
          <Link key={item.id} href={item.href}>
            <Flex as="span" /* ...styles... */>{/* ... */}</Flex>
          </Link>
        );
      })}
    </Stack>
  );
}
```

**Confidence: HIGH** -- `usePathname()` is the standard App Router hook for reading current path. Link-based nav is idiomatic.

### Pattern 3: Mobile Settings Dropdown

**What:** `<NativeSelect>` that navigates to the selected section on change
**When to use:** Mobile settings nav (below md breakpoint)

```typescript
import { usePathname, useRouter } from "next/navigation";
import { NativeSelect } from "@chakra-ui/react";

function SettingsMobileNav() {
  const pathname = usePathname();
  const router = useRouter();
  const currentSection = pathname.split("/").pop() || "feeds";

  return (
    <NativeSelect.Root size="sm">
      <NativeSelect.Field
        value={currentSection}
        onChange={(e) => router.push(`/settings/${e.target.value}`)}
      >
        <option value="feeds">Feeds</option>
        <option value="interests">Interests</option>
        <option value="categories">Categories</option>
        <option value="ollama">Ollama</option>
        <option value="feedback">Feedback</option>
      </NativeSelect.Field>
      <NativeSelect.Indicator />
    </NativeSelect.Root>
  );
}
```

**Confidence: HIGH** -- NativeSelect is a lightweight Chakra component (1 select + 1 indicator = 2 nodes). Much lighter than rendering all 5 sections stacked.

### Pattern 4: CategoryRowShell Extraction

**What:** Shared wrapper component for all three category row types
**When to use:** CategoryParentRow, CategoryChildRow, CategoryUngroupedRow refactoring

The three row types share 80%+ of their structure:
- Outer Box wrapper with responsive border/radius
- Inner Flex with role="group", hover state
- Rename input (via `useRenameState`)
- WeightPresetStrip (currently duplicated mobile/desktop)
- CategoryContextMenu in a min-height wrapper
- Responsive styling (mobile card, desktop row)

**Shell interface design:**

```typescript
interface CategoryRowShellProps {
  // Layout
  children: React.ReactNode;        // Left-side unique content (chevron+folder, checkbox, etc.)
  category: Category;
  weight: string;
  isOverridden?: boolean;           // For child rows
  onReset?: () => void;             // For child rows

  // Actions
  onWeightChange: (weight: string) => void;
  onRename: (newName: string) => void;
  contextMenu: React.ReactNode;     // Pre-built CategoryContextMenu

  // Optional badges
  badge?: React.ReactNode;          // "New" badge, "N new" badge
  trailingContent?: React.ReactNode; // Child count text, spacers

  // Hover state (needed for badge animation on child/ungrouped)
  onHoverChange?: (isHovered: boolean) => void;
}
```

The shell handles:
1. Outer wrapper (responsive border, bg, hover)
2. Inner flex row
3. Rename state and input
4. Single WeightPresetStrip that adapts via breakpoint (NOT duplicated)
5. Context menu wrapper

Each row type becomes a thin wrapper:
- **ParentRow:** Passes chevron + folder icon + name + child count as `children`
- **ChildRow:** Passes checkbox as `children`
- **UngroupedRow:** Passes checkbox as `children`

**Confidence: HIGH** -- Straightforward component extraction. The current duplication is clearly visible in the three row files.

### Pattern 5: Single Responsive WeightPresetStrip

**What:** One WeightPresetStrip per row instead of two (mobile + desktop)
**When to use:** Category row restructuring via shell

Currently each row renders TWO WeightPresetStrip instances:
- Desktop: `display={{ base: "none", sm: "block" }}` -- hover-expand, icon-only
- Mobile: `display={{ base: "block", sm: "none" }}` -- always expanded, icon + text

**New approach:** Single strip placed inside the shell. The strip already handles responsive behavior internally via `display={{ base: "inline", md: "none" }}` on the text label span and `maxW` animation for desktop collapse. The placement logic becomes:
- At sm+: strip sits inline in the row (current desktop position)
- Below sm: strip sits below the row (current mobile position)

This can be achieved by the shell's layout logic without duplicating the component.

**DOM savings estimate:** Each WeightPresetStrip contains ~13 nodes (5 buttons with tooltip wrappers + container flexes + reset button placeholder). Eliminating one duplicate per row saves ~13 nodes per category row. With ~50 categories, that is ~650 nodes.

**Confidence: HIGH** -- The strip already has internal responsive logic. Deduplication is mechanical.

### Pattern 6: Tooltip `disabled` Prop for Breakpoint-Aware Tooltips

**What:** Use Chakra Tooltip's `disabled` prop with `useBreakpointValue` to disable tooltips on mobile
**When to use:** WeightPresetStrip buttons

```typescript
import { useBreakpointValue } from "@chakra-ui/react";

// Inside WeightPresetStrip
const tooltipDisabled = !useBreakpointValue({ base: false, md: true });

// In the map:
<Tooltip content={option.label} openDelay={300} disabled={tooltipDisabled}>
  <Button /* ... */>
    <Icon size={12} />
    <Box as="span" display={{ base: "inline", md: "none" }}>{option.label}</Box>
  </Button>
</Tooltip>
```

**Confidence: HIGH** -- Verified via Context7: Chakra UI Tooltip supports `disabled` prop. When disabled, the wrapper returns `children` directly (no extra DOM nodes). The project's tooltip wrapper (`components/ui/tooltip.tsx`) already has this: `if (disabled) return children`.

### Pattern 7: ScoreBadge aria-label Instead of Tooltip

**What:** Replace Tooltip wrapper with `aria-label` on Badge
**When to use:** ScoreBadge component

Current ScoreBadge wraps Badge in Tooltip, adding Tooltip.Root > Tooltip.Trigger nodes per article row. Since the score is already visible as text in the Badge, the tooltip is redundant -- `aria-label` provides the same accessibility.

```typescript
// Before: Tooltip wrapping Badge = 2+ extra nodes per article row
<Tooltip content={`Score: ${scoreDisplay}`}>
  <Badge /* ... */>{scoreDisplay}</Badge>
</Tooltip>

// After: aria-label on Badge = 0 extra nodes
<Badge aria-label={`Score: ${scoreDisplay}`} /* ... */>
  {scoreDisplay}
</Badge>
```

**DOM savings:** ~2 nodes per scored article row. With 50 articles visible, ~100 nodes saved.

**Confidence: HIGH** -- The score text is already displayed visually. The tooltip adds no information the user cannot already see.

### Pattern 8: Semantic HTML Elements via `as` Prop

**What:** Replace generic `<div>` (Box/Flex) with semantic HTML elements using Chakra's `as` prop
**When to use:** Semantic HTML audit across all pages

Current state:
- AppShell: `<Box as="main">` -- already semantic
- Header: `<Box as="header">` -- already semantic
- Sidebar: `<Box as="aside">` -- already semantic
- Settings sidebar: `<Stack>` -- should be `<Stack as="nav">`
- Article rows: `<Flex>` -- should be `<Flex as="article">`
- Settings sections: no section landmarks
- Article list container: `<Box>` -- could be `<Box as="section">`

Key conversions:
| Current | Semantic | Where |
|---------|----------|-------|
| `<Stack>` in SettingsSidebar | `<Stack as="nav">` | SettingsSidebar.tsx |
| `<Flex>` wrapping article row | `<Flex as="article">` or `<Box as="article">` | ArticleRow.tsx |
| `<Box>` wrapping article list | `<Box as="section">` | ArticleList.tsx |
| `<Box>` around settings form | `<Box as="section">` | Each settings section component |
| `<Container>` in settings layout | Could add `aria-label` | settings/layout.tsx |

**Confidence: HIGH** -- Standard HTML semantics. Chakra's `as` prop simply changes the rendered element tag without changing styling behavior.

### Anti-Patterns to Avoid

- **Over-abstracting the shell:** CategoryRowShell should be a layout component, not a config-driven factory. Each row type's unique elements (chevron, checkbox, folder icon) must be clearly visible in the thin wrapper JSX, not buried in prop objects.
- **Breaking memo boundaries:** CategoryRowShell must support `React.memo` on the thin wrappers. If the shell accepts `children` as ReactNode, ensure the parent doesn't create new inline elements on each render (use stable callbacks, avoid inline JSX in props that change identity).
- **FOUC from conditional rendering:** For lightweight elements (1-3 nodes like the header hamburger button), prefer CSS `display: none` over conditional rendering to avoid flash of unstyled content.
- **Forgetting `"use client"` on layout:** The settings layout uses `usePathname` and interactive sidebar, so `layout.tsx` needs `"use client"`.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Breakpoint detection | Custom resize listener + state | `useBreakpointValue` from Chakra | SSR-safe, debounced, uses Chakra's breakpoint tokens |
| Route-based nav state | Custom URL parser + state sync | `usePathname()` from `next/navigation` | Standard App Router hook, SSR-compatible |
| Settings redirect | Client-side `useEffect` + `router.push` | `redirect()` from `next/navigation` in Server Component | Runs at request time, no flash of empty page |
| Semantic elements | Custom HTML element components | Chakra `as` prop | Zero-cost element swap, preserves all Chakra styling |

**Key insight:** All DOM simplification in this phase uses existing APIs and patterns. No new abstractions or libraries needed.

## Common Pitfalls

### Pitfall 1: Settings Navigation State Loss on Route Change

**What goes wrong:** User navigates to `/settings/categories`, expands parent groups, navigates to `/settings/feeds`, navigates back -- all expand/collapse state is lost.
**Why it happens:** CategoriesSection unmounts when navigating away, resetting `useState` to defaults.
**How to avoid:** The expand/collapse state is already persisted via `useLocalStorage("category-expanded-parents", {})`. Selection state and search query will reset on navigation, which is acceptable behavior (fresh context on each visit).
**Warning signs:** Test that localStorage-backed state survives section navigation.

### Pitfall 2: Mobile Dropdown vs Link-Based Navigation

**What goes wrong:** On mobile, the dropdown `<select>` triggers a full page navigation for each section change, which may feel slower than the current instant client-side section switching.
**Why it happens:** Route navigation involves fetching the new page chunk and rendering.
**How to avoid:** Next.js prefetches `<Link>` targets by default. Each section page component is small (just imports the section component). The transition should be near-instant. If not, consider `loading.tsx` with a skeleton in the settings layout.
**Warning signs:** Noticeable flash or delay when switching sections on mobile.

### Pitfall 3: CategoryRowShell Prop Explosion

**What goes wrong:** Shell tries to handle every row variation via props, becoming harder to read than the original duplicated code.
**Why it happens:** Over-abstracting to avoid all duplication.
**How to avoid:** The shell handles the COMMON parts (wrapper, rename, weight strip, context menu layout). Each row type's UNIQUE parts are passed as `children` or a small number of dedicated slots. If the shell interface grows beyond ~10 props, it is too complex.
**Warning signs:** More than 3 render-prop or slot-based props on the shell.

### Pitfall 4: WeightPresetStrip `useBreakpointValue` Causes Hydration Mismatch

**What goes wrong:** `useBreakpointValue` returns a default value during SSR that differs from the client value, causing a hydration mismatch warning.
**Why it happens:** Server cannot detect viewport width. Hook returns the `base` value during SSR.
**How to avoid:** WeightPresetStrip is already inside `"use client"` components. Chakra's `useBreakpointValue` is designed for client-side use and suppresses hydration warnings internally. The `base` value (tooltip disabled / mobile mode) is the safe default for SSR.
**Warning signs:** React hydration warnings in the console referencing tooltip state.

### Pitfall 5: OllamaSection `isVisible` Prop Becomes Unnecessary

**What goes wrong:** OllamaSection currently receives `isVisible` to control health polling. With route-based nav, it mounts/unmounts when the user navigates to/from the ollama section.
**Why it happens:** `isVisible` was needed when all sections were rendered simultaneously (mobile stacked view).
**How to avoid:** Remove the `isVisible` prop. Use component mount/unmount as the visibility signal. `useOllamaHealth(true)` -- always poll when mounted, since mounting = the section is active.
**Warning signs:** Health polling continues when user is on a different settings section.

## Code Examples

### Settings Redirect (Server Component)

```typescript
// Source: Next.js App Router docs (Context7)
// app/settings/page.tsx
import { redirect } from "next/navigation";

export default function SettingsIndex() {
  redirect("/settings/feeds");
}
```

### Breakpoint-Disabled Tooltip

```typescript
// Source: Chakra UI docs (Context7) - Tooltip disabled prop
// Verified: components/ui/tooltip.tsx line 26: `if (disabled) return children`
import { useBreakpointValue } from "@chakra-ui/react";
import { Tooltip } from "@/components/ui/tooltip";

const tooltipDisabled = useBreakpointValue({ base: true, md: false });

<Tooltip content="Label" disabled={tooltipDisabled}>
  <Button aria-label="Label">{/* icon */}</Button>
</Tooltip>
```

### Semantic `as` Prop Usage

```typescript
// Source: Chakra UI docs (Context7) - Composition / `as` prop
<Flex as="article" py={3} px={4} gap={3}>
  {/* ArticleRow content */}
</Flex>

<Stack as="nav" gap={1}>
  {/* SettingsSidebar links */}
</Stack>
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| `useState` section switching | Route segments with `layout.tsx` | Next.js 13+ App Router (2023) | URL-driven navigation, shareable links, better code splitting |
| CSS `display: none` for responsive | Conditional render for heavy subtrees | Ongoing best practice | Fewer mounted DOM nodes |
| Wrapper divs everywhere | Semantic HTML5 elements | HTML5 standard (2014), but adoption lags | Better accessibility, screen reader navigation |

## Open Questions

1. **CategoryActionBar dedup approach**
   - What we know: Desktop is a static Flex header (~14 nodes), mobile is ActionBar.Root with Portal/Positioner/Content (~8 nodes). Combined ~22 nodes when both are in DOM.
   - What's unclear: Is the mobile ActionBar portalled (renders outside normal DOM flow)? If so, it adds minimal cost when hidden via `display: none`.
   - Recommendation: Check whether ActionBar.Root renders portal nodes when `open={false}`. If it does not render portal content when closed (likely since `selectedCount === 0` means `open={false}`), keep both with CSS hide -- the desktop Flex is only ~14 static nodes and the mobile ActionBar renders nothing when closed. If it does mount portal content regardless, conditionally render the mobile version only when `selectedCount > 0` AND below sm breakpoint.

2. **Settings loading.tsx**
   - What we know: Route changes between settings sections will briefly unmount/remount section components.
   - What's unclear: Whether transitions are fast enough without an explicit loading state.
   - Recommendation: Omit `loading.tsx` initially. If testing reveals noticeable flicker, add a simple skeleton loading state in the settings layout.

## Sources

### Primary (HIGH confidence)
- Context7 `/llmstxt/nextjs_llms_txt` -- Nested layouts, route segments, redirect(), layout.tsx patterns
- Context7 `/websites/chakra-ui` -- Tooltip disabled prop, useBreakpointValue, NativeSelect, as prop
- Project codebase direct inspection -- All current component files read and analyzed

### Secondary (MEDIUM confidence)
- Project MEMORY.md -- Performance patterns from Quick-16 (responsive duplication is O(2N))

### Tertiary (LOW confidence)
- None

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH -- No new libraries; all patterns use existing project dependencies
- Architecture: HIGH -- Settings nested routes, CategoryRowShell extraction, and semantic audit are well-understood patterns
- Pitfalls: HIGH -- All pitfalls are based on direct codebase inspection and known framework behavior

**Research date:** 2026-02-20
**Valid until:** 2026-03-20 (stable patterns, no fast-moving dependencies)
