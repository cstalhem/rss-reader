---
phase: 08.1-categories-settings-ui-redesign
plan: 03
type: execute
wave: 3
depends_on: ["08.1-02"]
files_modified:
  - frontend/src/components/settings/CategoriesSection.tsx
  - frontend/src/components/settings/CategoryTree.tsx
  - frontend/src/components/settings/CategoryParentRow.tsx
  - frontend/src/components/settings/CategoryChildRow.tsx
  - frontend/src/components/settings/CreateCategoryPopover.tsx
  - frontend/src/components/settings/DeleteCategoryDialog.tsx
autonomous: true
requirements:
  - CATGRP-01
  - CATGRP-02

must_haves:
  truths:
    - "User can drag a category onto a root-level category to make it a parent"
    - "User can drag a child between parents"
    - "User can drag a child to the root area to ungroup it"
    - "Cannot drop onto a leaf category that is already a child"
    - "Drop targets highlight when valid, ghost preview shows landing position"
    - "User can create a new category via popover at root level"
    - "User can delete a category (parent deletion releases children)"
    - "User can rename a category via hover-reveal edit button"
    - "Search bar filters tree by name and disables DnD when active"
  artifacts:
    - path: "frontend/src/components/settings/CategoriesSection.tsx"
      provides: "DndContext, search state, CRUD handler wiring"
      contains: "DndContext"
    - path: "frontend/src/components/settings/CreateCategoryPopover.tsx"
      provides: "Popover for naming new categories"
      contains: "Popover"
    - path: "frontend/src/components/settings/DeleteCategoryDialog.tsx"
      provides: "Confirmation dialog for category deletion"
      contains: "Dialog"
  key_links:
    - from: "frontend/src/components/settings/CategoriesSection.tsx"
      to: "@dnd-kit/core"
      via: "DndContext wrapping CategoryTree"
      pattern: "DndContext"
    - from: "CategoriesSection handleDragEnd"
      to: "useCategories saveGroups"
      via: "mutation on drop"
      pattern: "saveGroups"
    - from: "CreateCategoryPopover"
      to: "useCategories createCategory"
      via: "mutation on form submit"
      pattern: "createCategory"
---

<objective>
Add drag-and-drop, search filtering, and category CRUD (create, rename, delete) to the tree view.

Purpose: This plan makes the tree interactive. Users can reorganize categories by dragging them between parents, create new categories manually, rename/delete existing ones, and filter the tree by search. These are the core interactions that make the parent-child model usable.

Output: Fully interactive category tree with DnD, search, and CRUD operations. All requirement IDs CATGRP-01 and CATGRP-02 are satisfied.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08.1-categories-settings-ui-redesign/08.1-RESEARCH.md
@.planning/phases/08.1-categories-settings-ui-redesign/08.1-01-SUMMARY.md
@.planning/phases/08.1-categories-settings-ui-redesign/08.1-02-SUMMARY.md

@frontend/src/components/settings/CategoriesSection.tsx
@frontend/src/components/settings/CategoryTree.tsx
@frontend/src/components/settings/CategoryParentRow.tsx
@frontend/src/components/settings/CategoryChildRow.tsx
@frontend/src/hooks/useCategories.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: DnD integration and search filtering</name>
  <files>
    frontend/src/components/settings/CategoriesSection.tsx
    frontend/src/components/settings/CategoryTree.tsx
    frontend/src/components/settings/CategoryParentRow.tsx
    frontend/src/components/settings/CategoryChildRow.tsx
  </files>
  <action>
**CategoriesSection.tsx:**

Add DnD context wrapping the tree. Import from @dnd-kit/core:
```typescript
import {
  DndContext,
  DragOverlay,
  DragStartEvent,
  DragEndEvent,
  PointerSensor,
  useSensor,
  useSensors,
  useDroppable,
} from "@dnd-kit/core";
```

Add DnD state:
```typescript
const [activeId, setActiveId] = useState<string | null>(null);
const [searchQuery, setSearchQuery] = useState("");
const isDndDisabled = searchQuery.length > 0;
```

Add sensors:
```typescript
const sensors = useSensors(
  useSensor(PointerSensor, { activationConstraint: { distance: 5 } })
);
```

Add search input above the tree:
```typescript
<Input
  placeholder="Filter categories..."
  size="sm"
  value={searchQuery}
  onChange={(e) => setSearchQuery(e.target.value)}
  mb={3}
/>
```

When searchQuery is non-empty, filter the tree data passed to CategoryTree:
- Filter parents: include parent if parent name matches OR any child name matches
- Filter children: within a matching parent, only show children that match
- Filter ungrouped: only show matching ungrouped categories
- Use case-insensitive `includes()` for matching

Add droppable root zone for ungrouped area. Use `useDroppable({ id: "root" })` on a Box wrapping the ungrouped categories section.

DnD handler — `handleDragEnd`:
```typescript
const handleDragEnd = useCallback((event: DragEndEvent) => {
  const { active, over } = event;
  setActiveId(null);
  if (!over || !categoryGroups) return;

  const draggedCategory = active.id as string;
  const overId = over.id as string;

  // Determine destination
  // over.id can be: "root", "parent:{name}", or a category name
  let destParent: string | null = null;  // null = root level

  if (overId === "root") {
    destParent = null;
  } else if (overId.startsWith("parent:")) {
    destParent = overId.replace("parent:", "");
  } else {
    // Dropped onto a category — check if it's a root-level ungrouped category
    // (which becomes a parent) or a parent that already has children
    const children = categoryGroups.children;
    if (overId in children) {
      // Dropped onto an existing parent
      destParent = overId;
    } else {
      // Check if it's an ungrouped root-level category
      const isChild = Object.values(children).flat().includes(overId);
      if (!isChild) {
        // It's a root-level ungrouped category — it becomes a parent
        destParent = overId;
      } else {
        // Dropped onto a child of a parent — invalid target, no-op
        return;
      }
    }
  }

  // Build updated children map
  const newChildren = { ...categoryGroups.children };

  // Remove dragged category from current parent (if it's a child)
  for (const [parent, childList] of Object.entries(newChildren)) {
    newChildren[parent] = childList.filter(c => c !== draggedCategory);
  }
  // Remove dragged category as a parent (if it was a parent with no children, or moving a parent)
  // Only remove if it's being moved into another parent (not staying at root)
  if (destParent !== null && draggedCategory in newChildren) {
    // Moving a parent into another parent — release its children to root first
    // Actually per locked decision: max 2 levels. A parent cannot become a child.
    // But a root-level non-parent CAN become a child.
    // If draggedCategory is a parent (has children key), skip the drop.
    if (newChildren[draggedCategory] && newChildren[draggedCategory].length > 0) {
      return; // Can't nest a parent with children under another parent
    }
    delete newChildren[draggedCategory];
  }

  if (destParent === null) {
    // Moving to root — already removed from parent above, nothing more to do
  } else {
    // Add to destination parent
    if (!newChildren[destParent]) {
      newChildren[destParent] = [];
    }
    if (!newChildren[destParent].includes(draggedCategory)) {
      newChildren[destParent].push(draggedCategory);
      newChildren[destParent].sort();
    }
  }

  // Clean up empty parents that were auto-created (only if they have no children and are not manually_created or in the hierarchy)
  // Actually, keep all parents even if empty — user might want to keep a parent category
  // The only cleanup: remove parent entries with empty arrays IF the parent was only created by drag
  // For simplicity, don't auto-cleanup — user can delete empty parents explicitly

  saveGroups({
    ...categoryGroups,
    children: newChildren,
  });
}, [categoryGroups, saveGroups]);
```

Wrap the tree with DndContext:
```tsx
<DndContext
  sensors={isDndDisabled ? undefined : sensors}
  onDragStart={(e) => !isDndDisabled && setActiveId(e.active.id as string)}
  onDragEnd={handleDragEnd}
>
  <CategoryTree ... isDndEnabled={!isDndDisabled} activeId={activeId} />
  <DragOverlay>
    {activeId && (
      <Box bg="bg.subtle" borderWidth="1px" borderColor="border.subtle" borderRadius="sm" p={2} shadow="md">
        <Text fontSize="sm">{toTitleCase(activeId)}</Text>
      </Box>
    )}
  </DragOverlay>
</DndContext>
```

**CategoryTree.tsx:**

Add props for DnD state:
```typescript
isDndEnabled?: boolean;
activeId?: string | null;
```

Pass DnD state to child components. For each parent row, wrap with `useDroppable({ id: `parent:${parentName}` })` to make parents valid drop targets. The drop highlight should show `bg="bg.muted"` when `isOver` is true.

For the ungrouped/root section, also add a droppable zone (pass from CategoriesSection via a wrapper).

**CategoryParentRow.tsx:**

Add droppable behavior:
```typescript
import { useDroppable } from "@dnd-kit/core";

// Inside component:
const { setNodeRef, isOver } = useDroppable({
  id: `parent:${category}`,
  disabled: !isDndEnabled,
});
```

Apply `ref={setNodeRef}` and `bg={isOver ? "bg.muted" : undefined}` for drop feedback.

Show a dashed placeholder at the bottom of children when hovering:
```tsx
{isOver && activeId && activeId !== category && (
  <Box p={2} mt={1} bg="bg.muted" borderRadius="sm"
    borderWidth="1px" borderStyle="dashed" borderColor="border.subtle" opacity={0.5}>
    <Text fontSize="sm" color="fg.muted">{toTitleCase(activeId)}</Text>
  </Box>
)}
```

**CategoryChildRow.tsx:**

Make child rows draggable using `useSortable`:
```typescript
import { useSortable } from "@dnd-kit/sortable";
import { CSS } from "@dnd-kit/utilities";

const { attributes, listeners, setNodeRef, transform, transition, isDragging } = useSortable({
  id: category,
  disabled: !isDndEnabled,
});

const style = {
  transform: CSS.Transform.toString(transform),
  transition,
  opacity: isDragging ? 0.5 : 1,
};
```

Apply `ref={setNodeRef}`, `style={style}`, and spread `{...attributes}` `{...listeners}` on the drag handle.

Also make ungrouped root-level categories draggable (they should also be valid drop targets if they are ungrouped root-level categories, since dropping onto them makes them a parent).
  </action>
  <verify>
Run `cd /Users/cstalhem/projects/rss-reader/frontend && npx tsc --noEmit 2>&1 | head -40` to check for TypeScript errors.

Run `cd /Users/cstalhem/projects/rss-reader/frontend && bun run build 2>&1 | tail -20` to verify build.

Manual test: Start dev server, navigate to Categories settings:
1. Drag a child category from one parent to another — verify it moves
2. Drag a child to the root area — verify it becomes ungrouped
3. Drag an ungrouped category onto a parent — verify it becomes a child
4. Drag an ungrouped category onto another ungrouped category — verify the target becomes a parent
5. Try dragging a parent with children onto another parent — verify it's blocked
6. Type in the search box — verify tree filters and drag handles disappear
  </verify>
  <done>
DnD works for moving categories between parents and root level. Drop targets highlight. Search filtering works and disables DnD. Invalid drops (onto child, nesting parents) are prevented.
  </done>
</task>

<task type="auto">
  <name>Task 2: Category CRUD — create, rename, delete</name>
  <files>
    frontend/src/components/settings/CategoriesSection.tsx
    frontend/src/components/settings/CreateCategoryPopover.tsx
    frontend/src/components/settings/DeleteCategoryDialog.tsx
    frontend/src/components/settings/CategoryParentRow.tsx
    frontend/src/components/settings/CategoryChildRow.tsx
  </files>
  <action>
**CreateCategoryPopover.tsx** (NEW FILE, replaces GroupNamePopover.tsx):

Adapt the existing GroupNamePopover pattern for creating categories instead of groups:

```typescript
"use client";

import { useState } from "react";
import { Button, Input, Popover, Portal, Stack } from "@chakra-ui/react";
import { LuPlus } from "react-icons/lu";
import { Field } from "@/components/ui/field";
```

Props:
```typescript
interface CreateCategoryPopoverProps {
  onCreateCategory: (name: string) => void;
  existingCategories: string[];  // for duplicate detection
}
```

Behavior:
- Trigger button: "Add Category" with LuPlus icon, `size="sm"`, `variant="outline"`
- Popover with input field for category name
- Validation: non-empty, no duplicate (case-insensitive match against existingCategories)
- On create: calls `onCreateCategory(name)` which triggers the `createCategory` mutation
- Input placeholder: "e.g., machine-learning"
- Auto-focus on open, clear on close

**DeleteCategoryDialog.tsx** (REWRITE of DeleteGroupDialog.tsx):

Adapt for deleting categories (parents or leaves):

Props:
```typescript
interface DeleteCategoryDialogProps {
  categoryName: string | null;
  childCount: number;          // > 0 means it's a parent
  isParent: boolean;
  onConfirm: () => void;
  onCancel: () => void;
}
```

Dialog text:
- If parent with children: "Delete parent category **{name}**? The {N} child categories will be released to the root level. Their individual weight overrides will be preserved."
- If leaf/ungrouped: "Delete category **{name}**? If the LLM discovers this category again, it will reappear."

Same Dialog.Root structure as existing DeleteGroupDialog.

**CategoriesSection.tsx:**

Wire up CRUD:

1. Add `createCategory` and `deleteCategory` from `useCategories()` destructuring
2. Wire CreateCategoryPopover in the header:
   ```tsx
   <CreateCategoryPopover
     onCreateCategory={(name) => createCategory(name)}
     existingCategories={allCategories}
   />
   ```
3. Add delete state:
   ```typescript
   const [deletingCategory, setDeletingCategory] = useState<{
     name: string;
     childCount: number;
     isParent: boolean;
   } | null>(null);
   ```
4. Add handlers:
   ```typescript
   const handleDeleteCategory = useCallback((name: string) => {
     const children = categoryGroups?.children ?? {};
     const isParent = name in children;
     const childCount = isParent ? children[name].length : 0;
     setDeletingCategory({ name, childCount, isParent });
   }, [categoryGroups]);

   const handleDeleteConfirm = useCallback(() => {
     if (deletingCategory) {
       deleteCategory(deletingCategory.name);
       setDeletingCategory(null);
     }
   }, [deletingCategory, deleteCategory]);
   ```
5. Render DeleteCategoryDialog at bottom of component

**CategoryParentRow.tsx and CategoryChildRow.tsx:**

Add hover-reveal edit and delete buttons (same pattern as existing CategoryGroupAccordion):

```tsx
// State
const [isHovered, setIsHovered] = useState(false);
const [isRenaming, setIsRenaming] = useState(false);
const [renameValue, setRenameValue] = useState(toTitleCase(category));
const inputRef = useRef<HTMLInputElement>(null);

// Handlers
const handleRenameSubmit = () => {
  const trimmed = renameValue.trim().toLowerCase().replace(/\s+/g, "-");
  if (trimmed && trimmed !== category) {
    onRename(category, trimmed);
  }
  setIsRenaming(false);
};
```

Add props: `onRename: (oldName: string, newName: string) => void` and `onDelete: (name: string) => void`

Desktop: hover reveals pencil (LuPencil) and trash (LuTrash2) buttons using the established pattern:
```tsx
opacity={{ base: 1, md: isHovered ? 1 : 0 }}
transition="opacity 0.15s"
```

When rename is active, replace the name text with an inline input (same pattern as CategoryGroupAccordion rename). Enter submits, Escape cancels, blur submits.

Pass `onRename` and `onDelete` through CategoryTree from CategoriesSection, which wires them to `renameCategory` and `handleDeleteCategory` respectively.
  </action>
  <verify>
Run `cd /Users/cstalhem/projects/rss-reader/frontend && npx tsc --noEmit 2>&1 | head -40` to check for TypeScript errors.

Run `cd /Users/cstalhem/projects/rss-reader/frontend && bun run build 2>&1 | tail -20` to verify build.

Manual test:
1. Click "Add Category" → enter name → verify category appears at root level
2. Hover a parent → click pencil → rename → verify name updates
3. Hover a parent with children → click trash → verify confirmation dialog shows child count → confirm → children released to root
4. Hover a leaf category → click trash → confirm → category deleted
  </verify>
  <done>
CreateCategoryPopover creates categories at root level. DeleteCategoryDialog handles parent and leaf deletion with confirmation. Inline rename works on hover-reveal pencil button. All CRUD operations persist via API mutations.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `bun run build` succeeds
3. DnD moves categories between parents and root
4. Search filters the tree and disables DnD
5. Create, rename, delete operations work via UI
6. Drop targets highlight with valid/invalid feedback
</verification>

<success_criteria>
- Drag-and-drop reorganizes categories between parents and root level
- Search bar filters tree by name, disables DnD when active
- Create category popover adds new categories at root level
- Rename and delete work via hover-reveal buttons
- Parent deletion releases children to root with confirmation dialog
- All operations persist via API and reflect after query invalidation
</success_criteria>

<output>
After completion, create `.planning/phases/08.1-categories-settings-ui-redesign/08.1-03-SUMMARY.md`
</output>
