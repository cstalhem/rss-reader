---
phase: 08.1-categories-settings-ui-redesign
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/backend/prompts.py
  - backend/src/backend/database.py
  - backend/src/backend/scoring.py
  - backend/src/backend/main.py
  - backend/src/backend/scoring_queue.py
autonomous: true
requirements:
  - CATGRP-03
  - CATGRP-05

must_haves:
  truths:
    - "category_groups JSON uses children map (keyed by parent name) instead of groups array"
    - "Existing users with groups data are migrated to children map format on startup"
    - "Fresh installs get 8 seeded parent categories with default children"
    - "compute_composite_score resolves weight: explicit override > parent weight > 1.0"
    - "is_blocked checks hidden_categories using new data structure"
    - "All API endpoints work with the new category_groups structure"
    - "LLM categorization prompt includes hierarchy info for auto-assignment"
  artifacts:
    - path: "backend/src/backend/prompts.py"
      provides: "DEFAULT_CATEGORY_HIERARCHY dict and updated categorization prompt"
      contains: "DEFAULT_CATEGORY_HIERARCHY"
    - path: "backend/src/backend/database.py"
      provides: "Migration from groups to children map, seeded hierarchy on fresh install"
      contains: "_migrate_groups_to_children"
    - path: "backend/src/backend/scoring.py"
      provides: "Updated weight resolution using children map"
      contains: "children"
    - path: "backend/src/backend/main.py"
      provides: "Updated API endpoints and response models for children-based structure"
      contains: "children"
  key_links:
    - from: "backend/src/backend/scoring.py"
      to: "category_groups.children"
      via: "weight lookup in compute_composite_score"
      pattern: "children"
    - from: "backend/src/backend/database.py"
      to: "category_groups JSON column"
      via: "migration function"
      pattern: "_migrate_groups_to_children"
---

<objective>
Migrate the backend data model from accordion-based groups to parent-child category hierarchy using a children map.

Purpose: The accordion-based group model (array of group objects with UUID ids) is being replaced by a parent-child model where categories can contain other categories. This is the foundational data layer change that all frontend work depends on.

Output: Updated backend with children-map data model, migration for existing data, seeded hierarchy for new installs, updated weight resolution, updated API endpoints, and hierarchy-aware LLM categorization prompt.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08.1-categories-settings-ui-redesign/08.1-RESEARCH.md

@backend/src/backend/prompts.py
@backend/src/backend/database.py
@backend/src/backend/scoring.py
@backend/src/backend/scoring_queue.py
@backend/src/backend/main.py
@backend/src/backend/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Data model change, migration, seeded hierarchy</name>
  <files>
    backend/src/backend/prompts.py
    backend/src/backend/database.py
  </files>
  <action>
**prompts.py:**

Add `DEFAULT_CATEGORY_HIERARCHY` dict after `DEFAULT_CATEGORIES`. This defines the seeded parent-child relationships for new installs:

```python
DEFAULT_CATEGORY_HIERARCHY: dict[str, list[str]] = {
    "technology": ["cybersecurity", "ai-ml", "programming"],
    "science": ["climate", "space"],
    "business": ["finance", "startups"],
    "entertainment": ["gaming", "film", "music"],
    "culture": ["philosophy", "history", "design"],
    "health": [],
    "politics": ["law"],
    "education": [],
}
```

Note: categories not assigned as children (sports, food, travel) remain ungrouped at root level. Children listed here are already in `DEFAULT_CATEGORIES`.

Update `build_categorization_prompt()` to accept an optional `category_hierarchy: dict[str, list[str]] | None = None` parameter. When provided, format the hierarchy in the prompt after the existing categories list:

```
**Category hierarchy (assign new categories as children of these parents when appropriate):**
technology > cybersecurity, ai-ml, programming
science > climate, space
...
```

Add instruction to the prompt: "8. When suggesting a new category, if it fits under an existing parent category, note which parent it belongs to." This helps the LLM assign new categories to parents automatically.

**database.py:**

Add `_migrate_groups_to_children()` function. This converts the old `groups` array format to the new `children` map format:

1. Read the current `category_groups` JSON from user_preferences
2. If `category_groups` is None or already has a `children` key, skip (already migrated or fresh)
3. If `category_groups` has a `groups` key with entries:
   - For each group in `groups`:
     - Kebab-case the group name (lowercase, replace spaces with hyphens)
     - Check for name collision with existing categories; if collision, append "-group" suffix
     - Map: `children[kebab_group_name] = group["categories"]`
     - Preserve the group's weight by adding `topic_weights[kebab_group_name] = group["weight"]` (the parent inherits the old group weight)
   - Build new `category_groups`:
     ```python
     {
         "children": children_map,
         "hidden_categories": old_cg.get("hidden_categories", []),
         "seen_categories": old_cg.get("seen_categories", []),
         "returned_categories": old_cg.get("returned_categories", []),
         "manually_created": [],
     }
     ```
   - Also add the new parent category names to `seen_categories` so they don't show "New" badges
   - Write both `category_groups` and `topic_weights` back to the database
4. If `category_groups` has no `groups` key or empty groups, just restructure to new format with empty `children: {}`

Add `_seed_category_hierarchy()` function for fresh installs:

1. Read `category_groups` from user_preferences
2. If `category_groups` is None (truly fresh, no data at all), seed with `DEFAULT_CATEGORY_HIERARCHY`:
   ```python
   {
       "children": DEFAULT_CATEGORY_HIERARCHY,
       "hidden_categories": [],
       "seen_categories": list(all_category_names),  # all parents + children
       "returned_categories": [],
       "manually_created": [],
   }
   ```
3. If `category_groups` already exists (migrated from groups or previously set), skip

Update `create_db_and_tables()` to call these new functions in order:
- After `_migrate_weight_names()`, call `_migrate_groups_to_children()` then `_seed_category_hierarchy()`

IMPORTANT: The `_migrate_weight_names` function references the old `groups` format in its seed logic. If `category_groups` is None, it creates `{"groups": [], ...}`. Update this: if `category_groups` is None, create with `{"children": {}, "hidden_categories": [], "seen_categories": [...], "returned_categories": [], "manually_created": []}` instead.
  </action>
  <verify>
Run `cd /Users/cstalhem/projects/rss-reader/backend && uv run python -c "from backend.prompts import DEFAULT_CATEGORY_HIERARCHY, build_categorization_prompt; print(DEFAULT_CATEGORY_HIERARCHY); print(build_categorization_prompt('test', 'test', ['technology'], {'technology': ['ai-ml']}))"` to verify the hierarchy dict and prompt include hierarchy info.

Run `cd /Users/cstalhem/projects/rss-reader/backend && uv run python -c "from backend.database import create_db_and_tables; print('Migration functions exist')"` to verify imports work.
  </verify>
  <done>
DEFAULT_CATEGORY_HIERARCHY exists with 8 parents. build_categorization_prompt includes hierarchy when provided. Migration function converts groups array to children map. Seed function populates hierarchy for fresh installs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Weight resolution, API endpoints, scoring queue updates</name>
  <files>
    backend/src/backend/scoring.py
    backend/src/backend/main.py
    backend/src/backend/scoring_queue.py
  </files>
  <action>
**scoring.py:**

Update `compute_composite_score()`:
- Replace the group_weights lookup that iterates `category_groups["groups"]` with a children-based lookup:
  ```python
  parent_weights: dict[str, str] = {}
  if category_groups and "children" in category_groups:
      for parent, children_list in category_groups["children"].items():
          for child in children_list:
              parent_weights[child.lower()] = parent.lower()
  ```
- Weight resolution logic becomes:
  1. `topic_weights[category]` exists? Use it (explicit override)
  2. Find parent via `parent_weights[category]`. If parent exists and `topic_weights[parent]` exists? Use parent's weight
  3. Default to "normal" (1.0)

Update `is_blocked()`:
- `hidden_categories` access remains the same (top-level key, not nested in groups)
- No changes needed here unless the structure changed — verify `hidden_categories` is still at `category_groups["hidden_categories"]`

Update `get_active_categories()`:
- Pass `category_hierarchy` to `build_categorization_prompt` calls
- Read hierarchy from preferences' `category_groups.children` if available
- This function is called from `scoring_queue.py` — verify the hierarchy flows through

**scoring_queue.py:**

Update the scoring queue's `_score_batch()` method:
- Where it calls `build_categorization_prompt`, also pass the hierarchy from `preferences.category_groups.get("children", {})` if `category_groups` exists
- Where it references `preferences.category_groups.get("hidden_categories", [])` — no change needed
- Where it references `preferences.category_groups.get("returned_categories", [])` — no change needed

**main.py:**

Update `_get_category_groups()` default structure:
```python
def _get_category_groups(preferences: UserPreferences) -> dict:
    if preferences.category_groups:
        return preferences.category_groups
    return {
        "children": {},
        "hidden_categories": [],
        "seen_categories": [],
        "returned_categories": [],
        "manually_created": [],
    }
```

Update `CategoryGroupsResponse` and `CategoryGroupsUpdate` Pydantic models:
```python
class CategoryGroupsResponse(BaseModel):
    children: dict[str, list[str]] = {}
    hidden_categories: list[str] = []
    seen_categories: list[str] = []
    returned_categories: list[str] = []
    manually_created: list[str] = []

class CategoryGroupsUpdate(BaseModel):
    children: dict[str, list[str]] = {}
    hidden_categories: list[str] = []
    seen_categories: list[str] = []
    returned_categories: list[str] = []
    manually_created: list[str] = []
```

Remove the old `groups: list[dict] = []` field from both.

Update `hide_category()` endpoint:
- Where it removes from groups' categories lists, instead remove from `children` map values:
  ```python
  children = dict(cg.get("children", {}))
  for parent, child_list in children.items():
      children[parent] = [c for c in child_list if c.lower() != cat_lower]
  # Also remove if the category is a parent key
  children.pop(cat_lower, None)
  ```

Update `get_new_category_count()` endpoint:
- Where it iterates `cg.get("groups", [])` to collect all categories, instead iterate `cg.get("children", {})`:
  ```python
  for parent, child_list in cg.get("children", {}).items():
      all_categories.add(parent.lower())
      for child in child_list:
          all_categories.add(child.lower())
  ```

No changes needed for: `get_category_groups`, `update_category_groups` (these use generic dict), `unhide_category`, `acknowledge_categories` (these only touch hidden/seen/returned lists).

Add a new endpoint `POST /api/categories/create` for manual category creation:
```python
@app.post("/api/categories/create")
def create_category(
    body: CategoryCreate,  # new model: name: str
    session: Session = Depends(get_session),
):
    """Create a manually-named category at root level."""
    preferences = _get_or_create_preferences(session)
    cg = _get_category_groups(preferences)

    # Normalize to kebab-case
    cat_name = body.name.strip().lower().replace(" ", "-")

    # Add to seen_categories and manually_created
    seen = list(cg.get("seen_categories", []))
    if cat_name not in [s.lower() for s in seen]:
        seen.append(cat_name)

    manually_created = list(cg.get("manually_created", []))
    if cat_name not in manually_created:
        manually_created.append(cat_name)

    preferences.category_groups = {
        **cg,
        "seen_categories": seen,
        "manually_created": manually_created,
    }
    preferences.updated_at = datetime.now()
    session.add(preferences)
    session.commit()
    session.refresh(preferences)

    return {"name": cat_name}
```

Add the `CategoryCreate` Pydantic model: `class CategoryCreate(BaseModel): name: str`

Add a new endpoint `DELETE /api/categories/{name}` for deleting categories:
```python
@app.delete("/api/categories/{name}")
def delete_category(
    name: str,
    session: Session = Depends(get_session),
):
    """Delete a category. If parent, children become ungrouped."""
    preferences = _get_or_create_preferences(session)
    cg = _get_category_groups(preferences)
    cat_lower = name.lower()

    children = dict(cg.get("children", {}))

    # If deleting a parent, release children (remove from children map)
    children.pop(cat_lower, None)

    # If deleting a child, remove from parent's children list
    for parent, child_list in children.items():
        children[parent] = [c for c in child_list if c.lower() != cat_lower]

    # Remove from manually_created if present
    manually_created = [m for m in cg.get("manually_created", []) if m.lower() != cat_lower]

    # Remove from topic_weights
    if preferences.topic_weights and cat_lower in preferences.topic_weights:
        new_weights = {k: v for k, v in preferences.topic_weights.items() if k != cat_lower}
        preferences.topic_weights = new_weights

    preferences.category_groups = {
        **cg,
        "children": children,
        "manually_created": manually_created,
    }
    preferences.updated_at = datetime.now()
    session.add(preferences)
    session.commit()

    return {"ok": True}
```

Add a new endpoint `PATCH /api/categories/{name}/rename` for renaming categories:
```python
@app.patch("/api/categories/{name}/rename")
def rename_category(
    name: str,
    body: CategoryRename,  # new model: new_name: str
    session: Session = Depends(get_session),
):
    """Rename a category. Updates children map, topic_weights, seen/hidden/returned lists."""
    preferences = _get_or_create_preferences(session)
    cg = _get_category_groups(preferences)
    old_name = name.lower()
    new_name = body.new_name.strip().lower().replace(" ", "-")

    children = dict(cg.get("children", {}))

    # If renaming a parent, update the key
    if old_name in children:
        children[new_name] = children.pop(old_name)

    # If renaming a child, update in parent's list
    for parent, child_list in children.items():
        children[parent] = [new_name if c.lower() == old_name else c for c in child_list]

    # Update topic_weights key
    if preferences.topic_weights and old_name in preferences.topic_weights:
        new_weights = dict(preferences.topic_weights)
        new_weights[new_name] = new_weights.pop(old_name)
        preferences.topic_weights = new_weights

    # Update in seen/hidden/returned/manually_created lists
    def rename_in_list(lst):
        return [new_name if item.lower() == old_name else item for item in lst]

    preferences.category_groups = {
        **cg,
        "children": children,
        "seen_categories": rename_in_list(cg.get("seen_categories", [])),
        "hidden_categories": rename_in_list(cg.get("hidden_categories", [])),
        "returned_categories": rename_in_list(cg.get("returned_categories", [])),
        "manually_created": rename_in_list(cg.get("manually_created", [])),
    }
    preferences.updated_at = datetime.now()
    session.add(preferences)
    session.commit()
    session.refresh(preferences)

    return {"old_name": old_name, "new_name": new_name}
```

Add `CategoryRename` model: `class CategoryRename(BaseModel): new_name: str`
  </action>
  <verify>
Run `cd /Users/cstalhem/projects/rss-reader/backend && uv run ruff check .` to verify no lint errors.

Run `cd /Users/cstalhem/projects/rss-reader/backend && uv run pytest` to verify existing tests still pass.

Run `cd /Users/cstalhem/projects/rss-reader/backend && uv run python -c "
from backend.scoring import compute_composite_score
# Test parent weight resolution
score = compute_composite_score(8, 7, ['python'], {'programming': 'boost'}, {'children': {'programming': ['python']}})
print(f'Parent weight resolution: {score}')
# Test explicit override
score2 = compute_composite_score(8, 7, ['python'], {'python': 'max', 'programming': 'boost'}, {'children': {'programming': ['python']}})
print(f'Explicit override: {score2}')
# Test default
score3 = compute_composite_score(8, 7, ['random'], {}, {'children': {}})
print(f'Default: {score3}')
"` to verify three-tier weight resolution works correctly.
  </verify>
  <done>
compute_composite_score uses children map for parent weight lookup. All API endpoints updated for new structure. Three new endpoints exist: POST /api/categories/create, DELETE /api/categories/{name}, PATCH /api/categories/{name}/rename. Existing tests pass. Lint clean.
  </done>
</task>

</tasks>

<verification>
1. `uv run ruff check .` passes with no errors
2. `uv run pytest` passes (existing tests)
3. Weight resolution correctly follows: explicit override > parent weight > default 1.0
4. Migration function converts old groups format to children map
5. Fresh install seeds 8 parent categories with default children
6. All existing API endpoints work with the new data structure
7. New CRUD endpoints (create, delete, rename) exist and are functional
</verification>

<success_criteria>
- Backend data model fully migrated from groups array to children map
- Three-tier weight resolution works with parent-child model
- LLM categorization prompt includes hierarchy for auto-assignment
- Existing data migrated safely, fresh installs get seeded hierarchy
- All API endpoints operational with new structure
</success_criteria>

<output>
After completion, create `.planning/phases/08.1-categories-settings-ui-redesign/08.1-01-SUMMARY.md`
</output>
