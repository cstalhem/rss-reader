# Phase 09.3: Settings Page Architecture Research and Audit - Research

**Researched:** 2026-02-22
**Domain:** Frontend settings page component architecture (Next.js App Router + Chakra UI v3)
**Confidence:** HIGH

## Summary

The settings page architecture follows a clean App Router pattern: a server component layout with sidebar navigation, six URL-routed pages, each rendering a single client component "section." The routing layer and layout are well-structured and already follow best practices. The complexity issues are concentrated in two areas: (1) **CategoriesSection** is a 491-line orchestrator with 11 mutations, 8+ state variables, and 15+ callback handlers that threads props 3-4 levels deep through CategoryTree to row components; and (2) **repeated inline patterns** across sections -- panel card wrappers, section headings, empty states, and inline progress bars are copy-pasted rather than shared.

The codebase is not broken -- everything works. The goal is to simplify toward a maintainable architecture where components have clear responsibilities, prop threading is minimal, and repeated patterns are extracted into shared primitives. The category tree hierarchy (CategoriesSection -> CategoryTree -> CategoryParentRow/CategoryChildRow/CategoryUngroupedRow -> CategoryRowShell) is the deepest nesting at 4 levels, with the heaviest prop threading occurring between CategoriesSection and CategoryTree (15 props passed down, most of which are just forwarded to child rows).

**Primary recommendation:** Reduce CategoriesSection by extracting state management into a context provider for the category tree, extract 3-4 shared layout primitives (SettingsPanel, SectionHeading, EmptyState, InlineProgressBar), and convert ModelManagement's inline Dialog.Root to ConfirmDialog.

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions
- Audit all settings sections equally -- no preconceived hot spots, let the audit surface them
- Cover all complexity dimensions: deep nesting, prop threading, component reuse, unclear responsibilities
- Flag repeated UI patterns (same form structures, toggle rows, section layouts copy-pasted across pages) -- this is a primary concern
- Propose specific shared component extractions (name them, list where they'd be used) -- not just catalogue
- Map component hierarchy using annotated tree diagrams for at-a-glance understanding
- Trace full data flow for key props: origin -> transforms -> consumption, identifying unnecessary pass-through layers
- Goal is a simple, maintainable architecture -- open to structural rethinking, not just incremental tweaks
- Simplify even working-but-complex components -- simplicity is a goal in itself
- Extract shared components when 3+ usages exist; tolerate some duplication if components stay self-contained
- Lean heavily toward Chakra UI built-ins over custom solutions -- custom only when clearly superior
- Evaluate whether we're using Chakra's composition patterns idiomatically (recipes, slots, compound components)
- Include file organization in the audit -- recommend moves if colocation would improve clarity
- Hard requirement: URL-based navigation between settings pages must be preserved (back/forward buttons work)
- All functionality must remain identical -- this is a pure architecture refactor
- Equal weight on external best practices and codebase-specific problems
- Find reference implementations of well-structured Next.js + Chakra settings pages in open-source projects
- Evaluate Chakra UI v3 idiomatic patterns -- are we using recipes, slots, compound components where we should be?
- Include TanStack Query data patterns within settings -- how data fetching/caching/mutation affects component design
- Recommendations grouped by theme (shared components, prop threading, file moves, etc.)
- Each recommendation includes specific targets: which files, what to extract/change, expected outcome
- Before/after tree diagrams for significant structural changes
- No effort estimates, no execution ordering -- planner handles that
- User wants to review findings before they feed into Phase 09.4 planning

### Claude's Discretion
- Server vs client component boundary analysis -- include as appropriate based on findings
- Document structure (single file vs split) -- optimize for GSD workflow consumption
- Research breadth on form libraries or other tooling -- surface if relevant, don't force it
- File organization recommendation (colocation approach) -- research and recommend based on best practices

### Deferred Ideas (OUT OF SCOPE)
None -- discussion stayed within phase scope
</user_constraints>

## Component Hierarchy

### Full Annotated Tree

```
app/settings/
  layout.tsx (SERVER) ................... 45 lines
  |-- Header (from layout/Header.tsx)
  |-- SettingsSidebar ................... 133 lines, CLIENT
  |   (queries: downloadStatus, newCategoryCount)
  |-- SettingsMobileNav ................. 36 lines, CLIENT
  |-- {children} <-- route-based page
  |
  page.tsx (SERVER) .................... redirect -> /settings/feeds
  |
  feeds/page.tsx (SERVER, 5 lines)
  |-- FeedsSection ..................... 259 lines, CLIENT
  |   |-- SortableFeedRow (co-located)
  |   |-- AddFeedDialog (from feed/)
  |   |-- DeleteFeedDialog (from feed/)
  |
  general/page.tsx (SERVER, 5 lines)
  |-- GeneralSection ................... 226 lines, CLIENT
  |   (hooks: usePreferences, countdown timer)
  |
  interests/page.tsx (SERVER, 5 lines)
  |-- InterestsSection ................. 126 lines, CLIENT
  |   |-- InterestsForm (co-located)
  |
  categories/page.tsx (SERVER, 5 lines)
  |-- CategoriesSection ................ 491 lines, CLIENT  <-- HOTSPOT
  |   |-- CategoryActionBar ............ 113 lines
  |   |-- CreateCategoryPopover ........ 85 lines
  |   |-- CategoryTree ................. 166 lines (React.memo)
  |   |   |-- CategoryParentRow ........ 103 lines (React.memo)
  |   |   |   |-- CategoryRowShell ..... 121 lines
  |   |   |   |   |-- WeightPresetStrip  105 lines (React.memo)
  |   |   |   |   |-- CategoryContextMenu 81 lines
  |   |   |   |-- NewCategoryBadge (from badge)
  |   |   |-- CategoryChildRow ......... 86 lines (React.memo)
  |   |   |   |-- CategoryRowShell (shared)
  |   |   |   |-- NewCategoryBadge
  |   |   |-- CategoryUngroupedRow ..... 76 lines (React.memo)
  |   |       |-- CategoryRowShell (shared)
  |   |       |-- NewCategoryBadge
  |   |-- DeleteCategoryDialog ......... 80 lines
  |   |-- MoveToGroupDialog ............ 174 lines
  |   |-- ConfirmDialog x2 (from ui/)
  |   |-- HiddenCategoriesSection ...... 70 lines
  |   |-- CategoriesTreeSkeleton ....... 62 lines
  |
  ollama/page.tsx (SERVER, 5 lines)
  |-- OllamaSection .................... 156 lines, CLIENT
  |   |-- OllamaHealthBadge ............ 44 lines
  |   |-- ModelSelector ................ 299 lines
  |   |   |-- ModelSelect (co-located)
  |   |-- ModelManagement .............. 364 lines  <-- SECONDARY HOTSPOT
  |   |   |-- InstalledModelRow (co-located)
  |   |   |-- ModelPullProgress ........ 75 lines
  |   |-- SystemPrompts ................ 77 lines
  |       |-- PromptSection (co-located)
  |
  feedback/page.tsx (SERVER, 5 lines)
  |-- FeedbackPlaceholder .............. 25 lines
```

**Nesting depth:** Max 5 levels (CategoriesSection -> CategoryTree -> CategoryChildRow -> CategoryRowShell -> WeightPresetStrip)

### Unused/Dead Components

- **OllamaPlaceholder.tsx** (25 lines) -- appears to be dead code, replaced by the connected/disconnected state in OllamaSection itself. No imports found.

## Data Flow Analysis

### Categories Data Flow (Most Complex)

```
useCategories() hook
  |-- categories: Category[] ............. source: TanStack Query
  |-- newCount: number ................... source: TanStack Query (polling)
  |-- updateCategory(id, data) ........... stable callback (useCallback)
  |-- 11 mutation objects ................ each with .mutate/.mutateAsync
  |
  v
CategoriesSection (491 lines)
  |-- useMemo: builds tree { parents, childrenMap, ungroupedCategories }
  |-- useMemo: builds newCategoryIds Set
  |-- useMemo: builds hiddenCategories array
  |-- useMemo: filteredParents/filteredChildrenMap/filteredUngrouped (search)
  |-- useState: selectedIds, searchQuery, moveDialogOpen, ungroupConfirmCount,
  |             deleteDialogState, ungroupParentConfirm, treeReady
  |-- useLocalStorage: expandedParents
  |-- 15+ useCallback handlers that bind category.id to mutation calls
  |
  v (15 PROPS passed to CategoryTree)
CategoryTree (React.memo)
  |-- parents, childrenMap, ungroupedCategories (data)
  |-- newCategoryIds (derived data)
  |-- onWeightChange, onResetWeight, onHide, onBadgeDismiss (callbacks)
  |-- onRename, onDelete, onUngroup (callbacks)
  |-- selectedIds, onToggleSelection (selection state)
  |-- expandedParents, onToggleParent (expansion state)
  |
  v (10-12 PROPS per row type, most are pass-through)
CategoryParentRow / CategoryChildRow / CategoryUngroupedRow
  |-- Each wraps callbacks with useCallback to bind category.id
  |
  v (8 PROPS)
CategoryRowShell
  |-- weight, onWeightChange -> WeightPresetStrip
  |-- renderContextMenu (render prop) -> CategoryContextMenu
  |-- badge (render prop or node) -> NewCategoryBadge
```

**Key observation:** CategoriesSection -> CategoryTree is the widest prop interface (15 props). Most are just forwarded to row components. The row components then re-bind each callback with `useCallback((w) => onWeightChange(category.id, w), ...)`. This is a classic "prop drilling" pattern that a context provider could eliminate.

### Ollama Data Flow

```
OllamaSection (orchestrator)
  |-- useOllamaHealth(true) -> health, isConnected
  |-- useOllamaModels(isConnected) -> models
  |-- useOllamaConfig() -> config, saveMutation, rescoreMutation
  |-- useModelPull() -> pullHook
  |-- useReducer: localEdits overlay
  |-- handleConfigChange, handleSave callbacks
  |
  v (6 props to ModelSelector)
  ModelSelector
  |-- models, config, savedConfig, onConfigChange, onSave, isSaving
  |-- internally queries downloadStatus, useScoringStatus
  |
  v (3 props to ModelManagement)
  ModelManagement
  |-- models, config, pullHook (ReturnType passed as prop)
  |-- internally queries downloadStatus
```

**Observation:** OllamaSection has a clean orchestrator pattern. ModelSelector and ModelManagement are self-contained. The only concern is ModelManagement at 364 lines with an inline Dialog.Root (should use ConfirmDialog).

### General/Interests Data Flow (Simplest)

```
GeneralSection -> usePreferences() + useQuery(refreshStatus)
  |-- All local: form state, countdown timer
  |-- No child component prop threading

InterestsSection -> usePreferences()
  |-- InterestsForm (co-located child)
  |-- Clean key-based reset pattern
```

These are well-structured and need minimal changes.

## Complexity Hotspots

### Hotspot 1: CategoriesSection (491 lines) -- CRITICAL

**Problems:**
1. **God component** -- Manages 8+ independent state concerns (selection, expansion, search, dialogs x4, tree computation)
2. **15+ useCallback handlers** -- Each wraps a mutation call with toast/dialog logic
3. **15-prop interface to CategoryTree** -- Most props just pass through to child rows
4. **4 dialog state objects** inlined (deleteDialogState, ungroupConfirmCount, ungroupParentConfirm, moveDialogOpen)
5. **4 useMemo computations** for tree building, filtering, and derived data

**Impact:** Hard to understand at a glance, difficult to modify one concern without reading the whole file, high cognitive load for future developers.

### Hotspot 2: ModelManagement (364 lines) -- MODERATE

**Problems:**
1. Uses inline `Dialog.Root` for delete confirmation instead of the project's `ConfirmDialog` component
2. Mixed concerns: installed model list, curated model list, custom pull form, active pull progress, error display, delete dialog all in one component
3. Inline progress bar markup in ModelSelector (3 repetitions of the same Box/Box/Text pattern) when ModelPullProgress already exists with a `compact` variant

**Impact:** The inline Dialog.Root is inconsistent with the rest of the codebase. The progress bar duplication creates maintenance burden.

### Hotspot 3: ModelSelector (299 lines) -- MODERATE

**Problems:**
1. Inline progress bar markup duplicated 3 times (for categorization model, scoring model, and single model views)
2. Each progress bar is a hand-rolled Box with height="4px", bg="bg.subtle", borderRadius="full", etc. -- identical to ModelPullProgress compact variant

**Impact:** Three copies of progress bar markup that should use ModelPullProgress compact variant or a simpler inline component.

## Repeated UI Patterns

### Pattern 1: Settings Panel Card (7+ usages)

**What:** `<Box bg="bg.subtle" borderRadius="md" borderWidth="1px" borderColor="border.subtle" p={5|6}>`

**Where used:**
- OllamaSection.tsx: 3 times (Model Configuration, Model Library, System Prompts panels)
- InterestsSection.tsx: 1 time (form wrapper)
- GeneralSection.tsx: 1 time (Feed Refresh Schedule panel, uses `bg="bg.panel"` variant)
- FeedsSection.tsx: 1 time (empty state)
- OllamaSection.tsx: 1 time (disconnected state)
- CategoriesSection.tsx: 1 time (empty state)

**Extraction target:** `SettingsPanel` -- a thin Box wrapper with consistent styling.

```tsx
// Proposed API
<SettingsPanel>
  <SettingsPanel.Heading>Model Configuration</SettingsPanel.Heading>
  {children}
</SettingsPanel>
```

### Pattern 2: Section Heading (9+ usages)

**What:** `<Text fontSize="lg" fontWeight="semibold" mb={4}>Title</Text>` inside panel cards, and `<Text fontSize="xl" fontWeight="semibold">Title</Text>` as page titles.

**Where used:** FeedsSection, GeneralSection, InterestsSection (x2), OllamaSection (x3 panel headings + 1 page title), FeedbackPlaceholder, OllamaPlaceholder, CategoriesSection

**Current inconsistency:**
- Page titles use `fontSize="xl"`
- Panel headings use `fontSize="lg"` with `mb={4}`
- FeedsSection uses `fontSize="lg"` as a page title (inconsistent with others)

**Extraction target:** Not a separate component (overkill for a single `<Text>` with props). Instead, standardize the heading pattern in the SettingsPanel compound component.

### Pattern 3: Empty State (4 usages)

**What:** Centered column with icon (40px), title, description, optional action button. Uses `Flex direction="column" alignItems="center" justifyContent="center" gap={4} py={16}`.

**Where used:**
- FeedsSection: "No feeds added yet" with Add Feed button
- OllamaSection: "Ollama is not connected" (no button)
- CategoriesSection: "Categories will appear here" (no button)
- FeedbackPlaceholder: "Coming soon" (no button)
- OllamaPlaceholder: "Coming soon" (no button, but this component appears dead)

**Extraction target:** `EmptyState` component.

```tsx
// Proposed API
<EmptyState icon={LuRss} title="No feeds added yet" description="Add your first RSS feed">
  <Button>Add Feed</Button>  {/* optional action slot */}
</EmptyState>
```

### Pattern 4: Inline Download Progress Bar (3 usages in ModelSelector)

**What:** Box with height="4px", bg="bg.subtle", borderRadius="full", inner Box with accent.solid background, plus "Downloading... X%" text.

**Where used:** ModelSelector.tsx lines 191-197, 213-219, 244-250 -- three identical blocks.

**Already exists:** `ModelPullProgress` has a `compact` variant that renders nearly the same thing.

**Fix:** Replace the 3 inline progress bars in ModelSelector with `<ModelPullProgress progress={{percentage: downloadPct ?? 0, status: 'downloading'}} onCancel={() => {}} compact />` or extract an even simpler `DownloadProgressBar` that takes just a percentage.

### Pattern 5: Dialog Confirmation Pattern (1 inconsistency)

**What:** ModelManagement uses inline `Dialog.Root` with Header/Body/Footer for delete confirmation.

**Already exists:** `ConfirmDialog` component used in CategoriesSection.

**Fix:** Replace ModelManagement's inline Dialog.Root with `<ConfirmDialog>`.

## Architecture Patterns (Best Practices)

### Current: Already Well-Applied Patterns

1. **App Router nested layout** -- `settings/layout.tsx` is a server component with sidebar, `page.tsx` files are thin server components that render a single client component section. This is the recommended pattern.

2. **URL-based navigation** -- Each section is its own route (`/settings/feeds`, `/settings/categories`, etc.) so back/forward navigation works. The `page.tsx` redirect from `/settings` to `/settings/feeds` is correct.

3. **Server/client boundary** -- Layout is a server component. SettingsSidebar and SettingsMobileNav carry the `"use client"` boundary. Each page imports a single client section component. This is efficient and well-placed.

4. **TanStack Query for data** -- All data flows through TanStack Query hooks (useCategories, usePreferences, useOllamaConfig, etc.). No `useEffect` + `useState` fetch patterns. Query key factory in use.

5. **React.memo on repeated rows** -- CategoryTree, CategoryParentRow, CategoryChildRow, CategoryUngroupedRow, WeightPresetStrip all use React.memo. CategoryRowShell is not memoized (it's the shell, not the repeated item).

6. **Co-located sub-components** -- SortableFeedRow in FeedsSection, InterestsForm in InterestsSection, ModelSelect in ModelSelector, InstalledModelRow in ModelManagement, PromptSection in SystemPrompts. This is good practice for single-consumer components.

### Recommended: Context for Category Tree Prop Drilling

The current CategoryTree receives 15 props from CategoriesSection, almost all of which are just forwarded to child row components. This is the classic case for React Context.

**Pattern: Category tree action context**

```tsx
// CategoryTreeContext.tsx
interface CategoryTreeActions {
  onWeightChange: (categoryId: number, weight: string) => void;
  onResetWeight: (categoryId: number) => void;
  onHide: (categoryId: number) => void;
  onBadgeDismiss: (categoryId: number) => void;
  onRename: (categoryId: number, newName: string) => void;
  onDelete: (categoryId: number) => void;
  onUngroup: (categoryId: number) => void;
  onToggleSelection: (id: number) => void;
  selectedIds: Set<number>;
  newCategoryIds: Set<number>;
}

const CategoryTreeContext = createContext<CategoryTreeActions>(...)
```

**Before:**
```
CategoriesSection (15 props) -> CategoryTree (15 props) -> CategoryParentRow (12 props)
                                                         -> CategoryChildRow (12 props)
                                                         -> CategoryUngroupedRow (10 props)
```

**After:**
```
CategoriesSection
  |-- <CategoryTreeProvider value={actions}>
  |     |-- CategoryTree (parents, childrenMap, ungroupedCategories, expandedParents, onToggleParent)
  |           |-- CategoryParentRow (category, weight, childCount, isExpanded, newChildCount)
  |           |-- CategoryChildRow (category, weight, isOverridden, parentWeight, isNew)
  |           |-- CategoryUngroupedRow (category, weight, isNew)
  |               // Each row uses useContext(CategoryTreeContext) for actions
  |-- </CategoryTreeProvider>
```

**Result:** CategoryTree drops from 15 props to ~5 (data only). Row components drop from 10-12 props to 3-5 (their own data only). Actions are consumed from context where needed.

### Recommended: CategoriesSection State Decomposition

CategoriesSection manages too many concerns. Decompose into:

1. **Category tree data** (parents, childrenMap, ungrouped, filtered) -- already computed via useMemo, could move to a custom hook `useCategoryTree(categories, searchQuery)`
2. **Selection state** -- could move to a custom hook `useCategorySelection()` or stay in CategoriesSection since it's small
3. **Dialog orchestration** -- the 4 dialog states and their open/close/confirm handlers could be a single `useCategoryDialogs()` hook

This would reduce CategoriesSection from ~491 lines to ~200-250 lines focused on composition.

### Chakra UI v3 Idiomatic Patterns

**Current usage evaluation:**

| Pattern | Used correctly? | Notes |
|---------|----------------|-------|
| Semantic tokens | Yes | All colors use tokens, no hardcoded values |
| Portal/Positioner | Yes | Select, Menu, Popover all use Portal correctly |
| Collapsible | Yes | HiddenCategoriesSection, SystemPrompts use it well |
| ActionBar | Yes | CategoryActionBar uses desktop Flex + mobile ActionBar.Root |
| React.memo | Yes | Applied to repeated row components |
| Fieldset | No (opportunity) | Could group form fields in GeneralSection, InterestsSection |
| Slot recipes | Not applicable | No need -- existing components are simple enough |
| Compound components | Not applicable | The project's components don't have variant complexity warranting custom slot recipes |

**Verdict:** Chakra UI v3's advanced patterns (recipes, slots, compound components) are designed for design system libraries, not application code. The project is using Chakra idiomatically for an application. There is no benefit to adopting slot recipes for settings components.

**One applicable improvement:** Chakra's `Card` component could replace the repeated panel card pattern, but a simple `SettingsPanel` wrapper is more project-specific and lighter.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Confirmation dialogs | Inline Dialog.Root | `ConfirmDialog` from `ui/confirm-dialog` | Already exists, used elsewhere in the project |
| Download progress | Inline Box/Box/Text progress bar | `ModelPullProgress compact` | Already exists with same markup |
| Category tree context | 15-prop drilling | React.createContext | Standard React pattern for cross-tree communication |

## Common Pitfalls

### Pitfall 1: Context Over-Extraction
**What goes wrong:** Moving too much state into context causes unnecessary re-renders across the tree when any value changes.
**Why it happens:** Treating context as a global store rather than a scoped communication channel.
**How to avoid:** Only put callback functions and slowly-changing state (selectedIds, newCategoryIds) into context. Keep frequently-changing data (weight values, category names) as props to specific rows. Callbacks are referentially stable (via useCallback) so context value changes are minimal.
**Warning signs:** Row components re-rendering when unrelated context values change.

### Pitfall 2: Breaking React.memo with Context
**What goes wrong:** Adding useContext to a memoized component defeats React.memo since context changes trigger re-renders regardless of props.
**Why it happens:** React.memo checks props but not context.
**How to avoid:** Put only stable references in context (useCallback-wrapped functions, Sets that change infrequently). Split context if needed: `CategoryTreeActionsContext` (stable callbacks) vs `CategoryTreeSelectionContext` (changes on every checkbox click).
**Warning signs:** All rows re-rendering on single checkbox toggle.

### Pitfall 3: Extracting Components Too Aggressively
**What goes wrong:** Creating wrappers that add indirection without reducing complexity.
**Why it happens:** Treating extraction as inherently good without measuring the benefit.
**How to avoid:** Apply the 3+ usage rule from CONTEXT.md. A single-use wrapper just moves code, it doesn't simplify. Co-located sub-components (like InterestsForm, InstalledModelRow) are the right pattern for single consumers.
**Warning signs:** Components with 1 consumer that just forward props.

### Pitfall 4: Losing URL Navigation
**What goes wrong:** Switching from route-based pages to client-side tab state breaks browser back/forward.
**How to avoid:** Keep the current `app/settings/{section}/page.tsx` pattern. This is already correct and must not change.
**Warning signs:** Any proposal to use `useState` for section switching instead of routes.

## Recommendations Summary

Grouped by theme for natural decomposition into plan waves.

### Theme A: Shared Layout Primitives

| Recommendation | Files Affected | What Changes |
|---------------|---------------|--------------|
| A1. Extract `SettingsPanel` component | OllamaSection, InterestsSection, GeneralSection, FeedsSection, CategoriesSection | Replace 7+ instances of Box with identical card styling |
| A2. Extract `EmptyState` component | FeedsSection, OllamaSection, CategoriesSection, FeedbackPlaceholder | Replace 4+ instances of centered icon + text + optional action |
| A3. Remove `OllamaPlaceholder.tsx` (dead code) | OllamaPlaceholder.tsx | Delete unused file |

**Expected outcome:** Consistent visual language for settings panels and empty states. ~50 lines of repeated markup eliminated across 5+ files.

### Theme B: Category Section Simplification

| Recommendation | Files Affected | What Changes |
|---------------|---------------|--------------|
| B1. Extract `useCategoryTree()` hook | CategoriesSection, new hook file | Move 4 useMemo computations (tree build, filtering, newCategoryIds, hiddenCategories) into a hook |
| B2. Create `CategoryTreeContext` | CategoriesSection, CategoryTree, CategoryParentRow, CategoryChildRow, CategoryUngroupedRow | Move 8 action callbacks + selectedIds + newCategoryIds into context, eliminating prop drilling |
| B3. Extract `useCategoryDialogs()` hook | CategoriesSection, new hook file | Move 4 dialog state objects and their open/close/confirm handlers into a hook |

**Before tree:**
```
CategoriesSection (491 lines, 15+ callbacks, 8+ state variables)
  -> CategoryTree (15 props)
    -> Row components (10-12 props each)
```

**After tree:**
```
CategoriesSection (~200 lines, composition only)
  -> useCategoryTree() for data
  -> useCategoryDialogs() for dialog state
  -> CategoryTreeProvider for actions
    -> CategoryTree (5 props: parents, childrenMap, ungrouped, expanded, onToggleParent)
      -> Row components (3-5 props each + useContext for actions)
```

### Theme C: Ollama Section Cleanup

| Recommendation | Files Affected | What Changes |
|---------------|---------------|--------------|
| C1. Replace ModelManagement inline Dialog with ConfirmDialog | ModelManagement.tsx | Replace 30-line inline Dialog.Root with ConfirmDialog component |
| C2. Replace ModelSelector inline progress bars with ModelPullProgress | ModelSelector.tsx | Replace 3 copy-pasted progress bar blocks with ModelPullProgress compact or a tiny DownloadProgressBar |
| C3. Consider splitting ModelManagement into sub-sections | ModelManagement.tsx | Optionally extract InstalledModelsList and DownloadModelsSection as co-located sub-components (reduces the 364-line file) |

**Expected outcome:** Consistent dialog usage, eliminated progress bar duplication, clearer ModelManagement structure.

### Theme D: Heading/Title Consistency

| Recommendation | Files Affected | What Changes |
|---------------|---------------|--------------|
| D1. Standardize page title pattern | FeedsSection, GeneralSection, InterestsSection, CategoriesSection, OllamaSection | All pages use `fontSize="xl"` for page title (FeedsSection currently uses `fontSize="lg"`) |

**Expected outcome:** Visual consistency across all settings pages.

### Theme E: SettingsMobileNav Missing Items

| Recommendation | Files Affected | What Changes |
|---------------|---------------|--------------|
| E1. Add "General" to SettingsMobileNav SECTIONS | SettingsMobileNav.tsx | Currently missing "general" from the mobile dropdown, though it's in SettingsSidebar |

**Expected outcome:** Mobile nav matches desktop sidebar.

## Server/Client Component Boundary Analysis

The current boundaries are well-placed:

| Component | Type | Correct? | Notes |
|-----------|------|----------|-------|
| `settings/layout.tsx` | Server | Yes | No hooks, no events, just composition |
| `settings/page.tsx` | Server | Yes | Just a redirect |
| `settings/*/page.tsx` (x6) | Server | Yes | Thin wrappers importing client sections |
| `SettingsSidebar` | Client | Yes | Uses TanStack Query, pathname |
| `SettingsMobileNav` | Client | Yes | Uses router, pathname |
| All `*Section` components | Client | Yes | Use hooks, state, events |

**No changes recommended.** The pattern of "server page.tsx imports single client section component" is the ideal App Router pattern. Adding `loading.tsx` or `error.tsx` per section is possible but unnecessary for this app's complexity.

## File Organization Analysis

**Current structure:**
```
components/settings/     # 28 files, ALL settings components flat in one directory
```

**Assessment:** All 28 component files live flat in `components/settings/`. For 28 files this is borderline -- still navigable but getting crowded. The alternative is sub-grouping by section:

```
components/settings/
  categories/           # CategoriesSection + 11 related components
  ollama/               # OllamaSection + 6 related components
  FeedsSection.tsx      # Self-contained (uses feed/ for dialogs)
  GeneralSection.tsx    # Self-contained
  InterestsSection.tsx  # Self-contained
  FeedbackPlaceholder.tsx
  SettingsSidebar.tsx
  SettingsMobileNav.tsx
  shared/               # SettingsPanel, EmptyState (new shared primitives)
```

**Trade-off:** Sub-grouping improves navigability for categories/ (12 files) and ollama/ (7 files), but adds indirection for simple sections. The flat structure is not a blocker.

**Recommendation:** Sub-group only if the planner finds it natural during implementation. It's a nice-to-have, not essential. The current flat structure works.

## Open Questions

1. **CategoryRowShell: should it be memoized?**
   - What we know: It's used by 3 memoized row components (ParentRow, ChildRow, UngroupedRow). The rows are memoized but the shell is not.
   - What's unclear: Whether the shell's lack of memoization causes re-renders that bypass the row-level memo.
   - Recommendation: Likely fine since the memo is on the parent component. Verify during implementation if performance is an issue.

2. **WeightPresetStrip hover state on mobile**
   - What we know: Desktop expand/collapse uses onMouseEnter/Leave. Mobile shows all buttons via responsive display.
   - What's unclear: Whether the hover state management creates unnecessary re-renders on touch devices.
   - Recommendation: Low priority, investigate only if profiling shows an issue.

## Sources

### Primary (HIGH confidence)
- Codebase audit: All 28 component files in `frontend/src/components/settings/`, all 8 page files in `frontend/src/app/settings/`, 3 hooks (useCategories, usePreferences, useRenameState) read in full
- Context7 `/websites/chakra-ui` -- compound components, slot recipes, form patterns
- Context7 `/llmstxt/nextjs_llms_txt` -- App Router composition patterns, server/client boundaries, nested layouts

### Secondary (MEDIUM confidence)
- [Next.js App Router Guides](https://nextjs.org/docs/app/guides) -- official docs on routing patterns
- [Chakra UI Slot Recipes](https://chakra-ui.com/docs/theming/slot-recipes) -- compound component creation patterns
- WebSearch for Next.js settings page architecture patterns (2025/2026), cross-verified with official docs

## Metadata

**Confidence breakdown:**
- Component hierarchy: HIGH -- direct codebase audit, every file read
- Complexity hotspots: HIGH -- line counts, prop counts, state variable counts all verified
- Repeated patterns: HIGH -- grep-verified across all files
- Architecture recommendations: HIGH -- standard React patterns (context, custom hooks), verified with official docs
- Chakra UI idiomatic assessment: HIGH -- verified via Context7 that recipes/slots are for design systems, not apps

**Research date:** 2026-02-22
**Valid until:** No expiration (codebase-specific findings, not library-version-dependent)
