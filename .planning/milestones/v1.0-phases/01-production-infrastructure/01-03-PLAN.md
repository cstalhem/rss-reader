---
phase: 01-production-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - docker-compose.yml
  - config/app.yaml
  - .env.example
  - .gitignore
autonomous: false

must_haves:
  truths:
    - "docker-compose up starts both backend and frontend services"
    - "Services auto-restart on failure (restart: unless-stopped)"
    - "Frontend waits for backend health check before starting"
    - "SQLite database persists across container restarts"
    - "Data survives docker-compose down && docker-compose up"
  artifacts:
    - path: "docker-compose.yml"
      provides: "Service orchestration with health checks"
      contains: "condition: service_healthy"
    - path: "config/app.yaml"
      provides: "Optional configuration template"
      contains: "database:"
    - path: ".env.example"
      provides: "Environment variable template"
      min_lines: 3
  key_links:
    - from: "docker-compose.yml"
      to: "named volume"
      via: "volumes section"
      pattern: "db-data:"
    - from: "docker-compose.yml"
      to: "backend health"
      via: "depends_on condition"
      pattern: "service_healthy"
---

<objective>
Create Docker Compose configuration that orchestrates backend and frontend services with proper health checks, restart policies, and persistent storage.

Purpose: Enable production deployment with `docker-compose up` that is robust, persistent, and self-healing.
Output: Complete Docker Compose setup with configuration templates and documentation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-production-infrastructure/01-CONTEXT.md
@.planning/phases/01-production-infrastructure/01-RESEARCH.md
@.planning/phases/01-production-infrastructure/01-01-SUMMARY.md
@.planning/phases/01-production-infrastructure/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Docker Compose and configuration files</name>
  <files>
    docker-compose.yml
    config/app.yaml
    .env.example
    .gitignore
  </files>
  <action>
    1. Create docker-compose.yml at project root:

       services:
         backend:
           build:
             context: ./backend
             dockerfile: Dockerfile
           image: rss-reader-backend:latest
           container_name: rss-reader-backend
           restart: unless-stopped
           volumes:
             - db-data:/data
             - ./config:/config:ro
           environment:
             - CONFIG_FILE=/config/app.yaml
             - PYTHONUNBUFFERED=1
           env_file:
             - .env
           healthcheck:
             test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
             interval: 10s
             timeout: 5s
             retries: 3
             start_period: 10s
           stop_grace_period: 30s
           ports:
             - "8000:8000"
           networks:
             - rss-reader

         frontend:
           build:
             context: ./frontend
             dockerfile: Dockerfile
           image: rss-reader-frontend:latest
           container_name: rss-reader-frontend
           restart: unless-stopped
           depends_on:
             backend:
               condition: service_healthy
               restart: true
           environment:
             - NEXT_PUBLIC_API_URL=http://backend:8000
           healthcheck:
             test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/"]
             interval: 10s
             timeout: 5s
             retries: 3
           stop_grace_period: 10s
           ports:
             - "3000:3000"
           networks:
             - rss-reader

       volumes:
         db-data:
           driver: local

       networks:
         rss-reader:
           driver: bridge

    2. Create config/ directory and config/app.yaml:
       ```yaml
       # RSS Reader Configuration
       # Environment variables override these settings (e.g., DATABASE__PATH)

       database:
         path: /data/rss-reader.db

       logging:
         level: INFO
         format: plain

       scheduler:
         feed_refresh_interval: 1800  # 30 minutes
         log_job_execution: false
       ```

    3. Create .env.example:
       ```
       # RSS Reader Environment Variables
       # Copy to .env and customize

       # Override config file settings
       # DATABASE__PATH=/data/rss-reader.db
       # LOGGING__LEVEL=DEBUG
       # SCHEDULER__LOG_JOB_EXECUTION=true
       ```

    4. Update .gitignore to add:
       - .env (if not already present)
       - data/*.db (local dev database)
       - data/*.db-wal
       - data/*.db-shm
  </action>
  <verify>
    Verify compose file syntax:
    cd /Users/cstalhem/projects/rss-reader && docker compose config

    Build all services:
    docker compose build

    Verify config directory exists:
    ls -la config/app.yaml
  </verify>
  <done>
    docker-compose.yml exists with both services, config template exists, .env.example documents available variables.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete Docker Compose infrastructure with:
    - Backend service with health check, WAL mode, named volume
    - Frontend service waiting for backend health
    - Restart policies (unless-stopped)
    - Configuration system (YAML + env overrides)
  </what-built>
  <how-to-verify>
    1. Start the full stack:
       cd /Users/cstalhem/projects/rss-reader
       docker compose up -d

    2. Wait for services to become healthy (watch logs):
       docker compose logs -f
       (Wait until both services show healthy status)

    3. Verify frontend is accessible:
       Open http://localhost:3000 in browser
       (Should see Next.js default page)

    4. Verify backend health:
       curl http://localhost:8000/health
       (Should return {"status": "healthy"})

    5. Test data persistence:
       docker compose down
       docker compose up -d
       curl http://localhost:8000/api/articles
       (Articles should persist - same data as before)

    6. Test restart behavior:
       docker stop rss-reader-backend
       docker ps -a
       (Backend should auto-restart within ~30 seconds)
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. Docker Compose validates: `docker compose config` shows no errors
2. Services build: `docker compose build` completes successfully
3. Services start: `docker compose up -d` starts both containers
4. Health checks pass: `docker compose ps` shows both services as "healthy"
5. Backend responds: `curl http://localhost:8000/health` returns 200
6. Frontend responds: `curl http://localhost:3000/` returns HTML
7. Persistence test: Data survives `docker compose down && docker compose up`
8. Restart test: Manually stopping backend triggers auto-restart
</verification>

<success_criteria>
- `docker compose up` starts both services successfully
- Backend health check passes before frontend starts
- Both services use `restart: unless-stopped`
- SQLite database stored in named volume (db-data)
- Data persists across container restarts
- Configuration can be customized via config/app.yaml or environment variables
- Human verification confirms all functionality works as expected
</success_criteria>

<output>
After completion, create `.planning/phases/01-production-infrastructure/01-03-SUMMARY.md`
</output>
